
build/bin/lunaix.bin:     file format elf32-i386


Disassembly of section .hhk_init_text:

00100000 <start_-0xc>:
  100000:	02 b0 ad 1b 03 00    	add    0x31bad(%eax),%dh
  100006:	00 00                	add    %al,(%eax)
  100008:	fb                   	sti    
  100009:	4f                   	dec    %edi
  10000a:	52                   	push   %edx
  10000b:	e4                   	.byte 0xe4

0010000c <start_>:
  10000c:	fc                   	cld    
  10000d:	fa                   	cli    
  10000e:	bc 7c 9f 10 00       	mov    $0x109f7c,%esp
  100013:	83 ec 10             	sub    $0x10,%esp
  100016:	c7 44 24 04 00 10 10 	movl   $0x101000,0x4(%esp)
  10001d:	00 
  10001e:	89 1c 24             	mov    %ebx,(%esp)
  100021:	e8 5e 01 00 00       	call   100184 <_save_multiboot_info>
  100026:	c7 44 24 04 00 a0 00 	movl   $0xa000,0x4(%esp)
  10002d:	00 
  10002e:	c7 04 24 00 40 d1 00 	movl   $0xd14000,(%esp)
  100035:	e8 b0 01 00 00       	call   1001ea <_hhk_init>
  10003a:	8b 04 24             	mov    (%esp),%eax
  10003d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  100042:	0f 22 d8             	mov    %eax,%cr3
  100045:	0f 20 c0             	mov    %cr0,%eax
  100048:	0d 00 00 01 80       	or     $0x80010000,%eax
  10004d:	0f 22 c0             	mov    %eax,%cr0
  100050:	83 c4 10             	add    $0x10,%esp
  100053:	68 07 c1 10 c0       	push   $0xc010c107
  100058:	c3                   	ret    

00100059 <_init_page>:
extern uint8_t __init_hhk_end;
extern uint8_t _k_stack;

void
_init_page(ptd_t* ptd)
{
  100059:	55                   	push   %ebp
  10005a:	89 e5                	mov    %esp,%ebp
  10005c:	57                   	push   %edi
  10005d:	56                   	push   %esi
  10005e:	53                   	push   %ebx
  10005f:	83 ec 04             	sub    $0x4,%esp
  100062:	8b 45 08             	mov    0x8(%ebp),%eax
    SET_PDE(ptd, 0, NEW_L1_ENTRY(PG_PREM_RW, ptd + PG_MAX_ENTRIES))
  100065:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
  10006b:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
  100071:	83 ca 0b             	or     $0xb,%edx
  100074:	89 10                	mov    %edx,(%eax)

    // 对低1MiB空间进行对等映射（Identity
    // mapping），也包括了我们的VGA，方便内核操作。
    for (uint32_t i = 0; i < 256; i++) {
  100076:	ba 00 00 00 00       	mov    $0x0,%edx
  10007b:	eb 12                	jmp    10008f <_init_page+0x36>
        SET_PTE(ptd,
  10007d:	89 d1                	mov    %edx,%ecx
  10007f:	c1 e1 0c             	shl    $0xc,%ecx
  100082:	83 c9 03             	or     $0x3,%ecx
  100085:	89 8c 90 00 10 00 00 	mov    %ecx,0x1000(%eax,%edx,4)
    for (uint32_t i = 0; i < 256; i++) {
  10008c:	83 c2 01             	add    $0x1,%edx
  10008f:	81 fa ff 00 00 00    	cmp    $0xff,%edx
  100095:	76 e6                	jbe    10007d <_init_page+0x24>
    }

    // 对等映射我们的hhk_init，这样一来，当分页与地址转换开启后，我们依然能够照常执行最终的
    // jmp 指令来跳转至
    //  内核的入口点
    for (uint32_t i = 0; i < HHK_PAGE_COUNT; i++) {
  100097:	b9 00 00 00 00       	mov    $0x0,%ecx
  10009c:	eb 18                	jmp    1000b6 <_init_page+0x5d>
        SET_PTE(ptd,
  10009e:	89 ca                	mov    %ecx,%edx
  1000a0:	c1 e2 0c             	shl    $0xc,%edx
  1000a3:	81 c2 00 00 10 00    	add    $0x100000,%edx
  1000a9:	83 ca 03             	or     $0x3,%edx
  1000ac:	89 94 88 00 14 00 00 	mov    %edx,0x1400(%eax,%ecx,4)
    for (uint32_t i = 0; i < HHK_PAGE_COUNT; i++) {
  1000b3:	83 c1 01             	add    $0x1,%ecx
  1000b6:	ba ff af 00 00       	mov    $0xafff,%edx
  1000bb:	c1 ea 0c             	shr    $0xc,%edx
  1000be:	39 ca                	cmp    %ecx,%edx
  1000c0:	77 dc                	ja     10009e <_init_page+0x45>

    // --- 将内核重映射至高半区 ---

    // 这里是一些计算，主要是计算应当映射进的 页目录 与 页表 的条目索引（Entry
    // Index）
    uint32_t kernel_pde_index = L1_INDEX(sym_val(__kernel_start));
  1000c2:	be 00 a0 10 c0       	mov    $0xc010a000,%esi
  1000c7:	89 f3                	mov    %esi,%ebx
  1000c9:	c1 eb 16             	shr    $0x16,%ebx
  1000cc:	89 5d f0             	mov    %ebx,-0x10(%ebp)
    uint32_t kernel_pte_index = L2_INDEX(sym_val(__kernel_start));
  1000cf:	c1 ee 0c             	shr    $0xc,%esi
  1000d2:	81 e6 ff 03 00 00    	and    $0x3ff,%esi
    uint32_t kernel_pg_counts = KERNEL_PAGE_COUNT;
  1000d8:	bb ff ef d1 c0       	mov    $0xc0d1efff,%ebx
  1000dd:	81 eb 00 a0 10 c0    	sub    $0xc010a000,%ebx
  1000e3:	c1 eb 0c             	shr    $0xc,%ebx

    // 将内核所需要的页表注册进页目录
    //  当然，就现在而言，我们的内核只占用不到50个页（每个页表包含1024个页）
    //  这里分配了3个页表（12MiB），未雨绸缪。
    for (uint32_t i = 0; i < PG_TABLE_STACK - PG_TABLE_KERNEL; i++) {
  1000e6:	b9 00 00 00 00       	mov    $0x0,%ecx
  1000eb:	eb 1c                	jmp    100109 <_init_page+0xb0>
        SET_PDE(ptd,
  1000ed:	8d 51 02             	lea    0x2(%ecx),%edx
  1000f0:	c1 e2 0c             	shl    $0xc,%edx
  1000f3:	01 c2                	add    %eax,%edx
  1000f5:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
  1000fb:	8b 7d f0             	mov    -0x10(%ebp),%edi
  1000fe:	01 cf                	add    %ecx,%edi
  100100:	83 ca 0f             	or     $0xf,%edx
  100103:	89 14 b8             	mov    %edx,(%eax,%edi,4)
    for (uint32_t i = 0; i < PG_TABLE_STACK - PG_TABLE_KERNEL; i++) {
  100106:	83 c1 01             	add    $0x1,%ecx
  100109:	83 f9 06             	cmp    $0x6,%ecx
  10010c:	76 df                	jbe    1000ed <_init_page+0x94>
                kernel_pde_index + i,
                NEW_L1_ENTRY(PG_PREM_URW, PT_ADDR(ptd, PG_TABLE_KERNEL + i)))
    }

    // 首先，检查内核的大小是否可以fit进我们这几个表（12MiB）
    if (kernel_pg_counts >
  10010e:	81 fb 00 1c 00 00    	cmp    $0x1c00,%ebx
  100114:	76 02                	jbe    100118 <_init_page+0xbf>
        (PG_TABLE_STACK - PG_TABLE_KERNEL) * PG_MAX_ENTRIES) {
        // ERROR: require more pages
        //  here should do something else other than head into blocking
        asm("ud2");
  100116:	0f 0b                	ud2    

    // 计算内核.text段的物理地址
    uintptr_t kernel_pm = V2P(&__kernel_start);

    // 重映射内核至高半区地址（>=0xC0000000）
    for (uint32_t i = 0; i < kernel_pg_counts; i++) {
  100118:	b9 00 00 00 00       	mov    $0x0,%ecx
  10011d:	eb 21                	jmp    100140 <_init_page+0xe7>
        // FIXME: 只是用作用户模式（R3）测试！
        //        在实际中，内核代码除了极少部分需要暴露给R3（如从信号返回），其余的应为R0。
        SET_PTE(ptd,
  10011f:	89 ca                	mov    %ecx,%edx
  100121:	c1 e2 0c             	shl    $0xc,%edx
  100124:	81 c2 00 a0 10 00    	add    $0x10a000,%edx
  10012a:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
  100130:	8d bc 31 00 08 00 00 	lea    0x800(%ecx,%esi,1),%edi
  100137:	83 ca 07             	or     $0x7,%edx
  10013a:	89 14 b8             	mov    %edx,(%eax,%edi,4)
    for (uint32_t i = 0; i < kernel_pg_counts; i++) {
  10013d:	83 c1 01             	add    $0x1,%ecx
  100140:	39 d9                	cmp    %ebx,%ecx
  100142:	72 db                	jb     10011f <_init_page+0xc6>
                kernel_pte_index + i,
                NEW_L2_ENTRY(PG_PREM_URW, kernel_pm + (i << PG_SIZE_BITS)))
    }

    // 最后一个entry用于循环映射
    SET_PDE(ptd, PG_MAX_ENTRIES - 1, NEW_L1_ENTRY(T_SELF_REF_PERM, ptd));
  100144:	89 c2                	mov    %eax,%edx
  100146:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
  10014c:	83 ca 1b             	or     $0x1b,%edx
  10014f:	89 90 fc 0f 00 00    	mov    %edx,0xffc(%eax)
}
  100155:	83 c4 04             	add    $0x4,%esp
  100158:	5b                   	pop    %ebx
  100159:	5e                   	pop    %esi
  10015a:	5f                   	pop    %edi
  10015b:	5d                   	pop    %ebp
  10015c:	c3                   	ret    

0010015d <__save_subset>:

uint32_t
__save_subset(uint8_t* destination, uint8_t* base, unsigned int size)
{
  10015d:	55                   	push   %ebp
  10015e:	89 e5                	mov    %esp,%ebp
  100160:	56                   	push   %esi
  100161:	53                   	push   %ebx
  100162:	8b 75 08             	mov    0x8(%ebp),%esi
  100165:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  100168:	8b 4d 10             	mov    0x10(%ebp),%ecx
    unsigned int i = 0;
  10016b:	b8 00 00 00 00       	mov    $0x0,%eax
    for (; i < size; i++) {
  100170:	eb 0a                	jmp    10017c <__save_subset+0x1f>
        *(destination + i) = *(base + i);
  100172:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
  100176:	88 14 06             	mov    %dl,(%esi,%eax,1)
    for (; i < size; i++) {
  100179:	83 c0 01             	add    $0x1,%eax
  10017c:	39 c8                	cmp    %ecx,%eax
  10017e:	72 f2                	jb     100172 <__save_subset+0x15>
    }
    return i;
}
  100180:	5b                   	pop    %ebx
  100181:	5e                   	pop    %esi
  100182:	5d                   	pop    %ebp
  100183:	c3                   	ret    

00100184 <_save_multiboot_info>:

void
_save_multiboot_info(multiboot_info_t* info, uint8_t* destination)
{
  100184:	55                   	push   %ebp
  100185:	89 e5                	mov    %esp,%ebp
  100187:	57                   	push   %edi
  100188:	56                   	push   %esi
  100189:	53                   	push   %ebx
  10018a:	83 ec 0c             	sub    $0xc,%esp
  10018d:	8b 75 08             	mov    0x8(%ebp),%esi
  100190:	8b 7d 0c             	mov    0xc(%ebp),%edi
    uint32_t current = 0;
  100193:	bb 00 00 00 00       	mov    $0x0,%ebx
    uint8_t* info_b = (uint8_t*)info;
    for (; current < sizeof(multiboot_info_t); current++) {
  100198:	eb 0a                	jmp    1001a4 <_save_multiboot_info+0x20>
        *(destination + current) = *(info_b + current);
  10019a:	0f b6 04 1e          	movzbl (%esi,%ebx,1),%eax
  10019e:	88 04 1f             	mov    %al,(%edi,%ebx,1)
    for (; current < sizeof(multiboot_info_t); current++) {
  1001a1:	83 c3 01             	add    $0x1,%ebx
  1001a4:	83 fb 77             	cmp    $0x77,%ebx
  1001a7:	76 f1                	jbe    10019a <_save_multiboot_info+0x16>
    }

    ((multiboot_info_t*)destination)->mmap_addr =
      (uintptr_t)destination + current;
  1001a9:	8d 04 1f             	lea    (%edi,%ebx,1),%eax
    ((multiboot_info_t*)destination)->mmap_addr =
  1001ac:	89 47 30             	mov    %eax,0x30(%edi)
    current += __save_subset(
  1001af:	83 ec 04             	sub    $0x4,%esp
  1001b2:	ff 76 2c             	push   0x2c(%esi)
  1001b5:	ff 76 30             	push   0x30(%esi)
  1001b8:	50                   	push   %eax
  1001b9:	e8 9f ff ff ff       	call   10015d <__save_subset>
  1001be:	01 c3                	add    %eax,%ebx
      destination + current, (uint8_t*)info->mmap_addr, info->mmap_length);

    if (present(info->flags, MULTIBOOT_INFO_DRIVE_INFO)) {
  1001c0:	83 c4 10             	add    $0x10,%esp
  1001c3:	f6 06 80             	testb  $0x80,(%esi)
  1001c6:	75 08                	jne    1001d0 <_save_multiboot_info+0x4c>
          (uintptr_t)destination + current;
        current += __save_subset(destination + current,
                                 (uint8_t*)info->drives_addr,
                                 info->drives_length);
    }
}
  1001c8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1001cb:	5b                   	pop    %ebx
  1001cc:	5e                   	pop    %esi
  1001cd:	5f                   	pop    %edi
  1001ce:	5d                   	pop    %ebp
  1001cf:	c3                   	ret    
          (uintptr_t)destination + current;
  1001d0:	8d 04 1f             	lea    (%edi,%ebx,1),%eax
        ((multiboot_info_t*)destination)->drives_addr =
  1001d3:	89 47 38             	mov    %eax,0x38(%edi)
        current += __save_subset(destination + current,
  1001d6:	83 ec 04             	sub    $0x4,%esp
  1001d9:	ff 76 34             	push   0x34(%esi)
  1001dc:	ff 76 38             	push   0x38(%esi)
  1001df:	50                   	push   %eax
  1001e0:	e8 78 ff ff ff       	call   10015d <__save_subset>
  1001e5:	83 c4 10             	add    $0x10,%esp
}
  1001e8:	eb de                	jmp    1001c8 <_save_multiboot_info+0x44>

001001ea <_hhk_init>:

void
_hhk_init(ptd_t* ptd, uint32_t kpg_size)
{
  1001ea:	55                   	push   %ebp
  1001eb:	89 e5                	mov    %esp,%ebp
  1001ed:	8b 55 08             	mov    0x8(%ebp),%edx
  1001f0:	8b 4d 0c             	mov    0xc(%ebp),%ecx

    // 初始化 kpg 全为0
    //      P.s. 真没想到GRUB会在这里留下一堆垃圾！ 老子的页表全乱套了！
    uint8_t* kpg = (uint8_t*)ptd;
    for (uint32_t i = 0; i < kpg_size; i++) {
  1001f3:	b8 00 00 00 00       	mov    $0x0,%eax
  1001f8:	eb 07                	jmp    100201 <_hhk_init+0x17>
        *(kpg + i) = 0;
  1001fa:	c6 04 02 00          	movb   $0x0,(%edx,%eax,1)
    for (uint32_t i = 0; i < kpg_size; i++) {
  1001fe:	83 c0 01             	add    $0x1,%eax
  100201:	39 c8                	cmp    %ecx,%eax
  100203:	72 f5                	jb     1001fa <_hhk_init+0x10>
    }

    _init_page(ptd);
  100205:	52                   	push   %edx
  100206:	e8 4e fe ff ff       	call   100059 <_init_page>
  10020b:	83 c4 04             	add    $0x4,%esp
  10020e:	c9                   	leave  
  10020f:	c3                   	ret    

Disassembly of section .text:

c010a000 <coalesce>:
    }
}

void*
coalesce(uint8_t* chunk_ptr)
{
c010a000:	55                   	push   %ebp
c010a001:	89 e5                	mov    %esp,%ebp
c010a003:	57                   	push   %edi
c010a004:	56                   	push   %esi
c010a005:	53                   	push   %ebx
c010a006:	8b 4d 08             	mov    0x8(%ebp),%ecx
    uint32_t hdr = LW(chunk_ptr);
c010a009:	8b 01                	mov    (%ecx),%eax
    uint32_t pf = CHUNK_PF(hdr);
c010a00b:	89 c3                	mov    %eax,%ebx
c010a00d:	83 e3 02             	and    $0x2,%ebx
    uint32_t sz = CHUNK_S(hdr);
c010a010:	83 e0 fc             	and    $0xfffffffc,%eax

    uint32_t n_hdr = LW(chunk_ptr + sz);
c010a013:	8b 14 01             	mov    (%ecx,%eax,1),%edx

    if (CHUNK_A(n_hdr) && pf) {
c010a016:	89 d6                	mov    %edx,%esi
c010a018:	83 e6 01             	and    $0x1,%esi
c010a01b:	74 27                	je     c010a044 <coalesce+0x44>
c010a01d:	85 db                	test   %ebx,%ebx
c010a01f:	74 23                	je     c010a044 <coalesce+0x44>
        // case 1: prev is free
        uint32_t prev_ftr = LW(chunk_ptr - WSIZE);
c010a021:	8b 59 fc             	mov    -0x4(%ecx),%ebx
        size_t prev_chunk_sz = CHUNK_S(prev_ftr);
c010a024:	89 de                	mov    %ebx,%esi
c010a026:	83 e6 fc             	and    $0xfffffffc,%esi
        uint32_t new_hdr = PACK(prev_chunk_sz + sz, CHUNK_PF(prev_ftr));
c010a029:	8d 14 30             	lea    (%eax,%esi,1),%edx
c010a02c:	83 e3 02             	and    $0x2,%ebx
c010a02f:	09 da                	or     %ebx,%edx
        SW(chunk_ptr - prev_chunk_sz, new_hdr);
c010a031:	89 cb                	mov    %ecx,%ebx
c010a033:	29 f3                	sub    %esi,%ebx
c010a035:	89 13                	mov    %edx,(%ebx)
        SW(FPTR(chunk_ptr, sz), new_hdr);
c010a037:	89 54 01 fc          	mov    %edx,-0x4(%ecx,%eax,1)
        chunk_ptr -= prev_chunk_sz;
c010a03b:	89 d9                	mov    %ebx,%ecx
        chunk_ptr -= prev_chunk_sz;
    }

    // (fall through) case 4: prev and next are not free
    return chunk_ptr;
}
c010a03d:	89 c8                	mov    %ecx,%eax
c010a03f:	5b                   	pop    %ebx
c010a040:	5e                   	pop    %esi
c010a041:	5f                   	pop    %edi
c010a042:	5d                   	pop    %ebp
c010a043:	c3                   	ret    
    } else if (!CHUNK_A(n_hdr) && !pf) {
c010a044:	85 f6                	test   %esi,%esi
c010a046:	75 17                	jne    c010a05f <coalesce+0x5f>
c010a048:	85 db                	test   %ebx,%ebx
c010a04a:	75 13                	jne    c010a05f <coalesce+0x5f>
        size_t next_chunk_sz = CHUNK_S(n_hdr);
c010a04c:	83 e2 fc             	and    $0xfffffffc,%edx
        uint32_t new_hdr = PACK(next_chunk_sz + sz, pf);
c010a04f:	8d 34 10             	lea    (%eax,%edx,1),%esi
c010a052:	09 f3                	or     %esi,%ebx
        SW(chunk_ptr, new_hdr);
c010a054:	89 19                	mov    %ebx,(%ecx)
        SW(FPTR(chunk_ptr, sz + next_chunk_sz), new_hdr);
c010a056:	8d 44 10 fc          	lea    -0x4(%eax,%edx,1),%eax
c010a05a:	89 1c 01             	mov    %ebx,(%ecx,%eax,1)
    } else if (!CHUNK_A(n_hdr) && !pf) {
c010a05d:	eb de                	jmp    c010a03d <coalesce+0x3d>
    } else if (!CHUNK_A(n_hdr) && pf) {
c010a05f:	85 f6                	test   %esi,%esi
c010a061:	75 da                	jne    c010a03d <coalesce+0x3d>
c010a063:	85 db                	test   %ebx,%ebx
c010a065:	74 d6                	je     c010a03d <coalesce+0x3d>
        uint32_t prev_ftr = LW(chunk_ptr - WSIZE);
c010a067:	8b 59 fc             	mov    -0x4(%ecx),%ebx
        size_t next_chunk_sz = CHUNK_S(n_hdr);
c010a06a:	83 e2 fc             	and    $0xfffffffc,%edx
        size_t prev_chunk_sz = CHUNK_S(prev_ftr);
c010a06d:	89 de                	mov    %ebx,%esi
c010a06f:	83 e6 fc             	and    $0xfffffffc,%esi
          PACK(next_chunk_sz + prev_chunk_sz + sz, CHUNK_PF(prev_ftr));
c010a072:	8d 3c 32             	lea    (%edx,%esi,1),%edi
c010a075:	01 c7                	add    %eax,%edi
c010a077:	83 e3 02             	and    $0x2,%ebx
        uint32_t new_hdr =
c010a07a:	09 fb                	or     %edi,%ebx
        SW(chunk_ptr - prev_chunk_sz, new_hdr);
c010a07c:	89 cf                	mov    %ecx,%edi
c010a07e:	29 f7                	sub    %esi,%edi
c010a080:	89 1f                	mov    %ebx,(%edi)
        SW(FPTR(chunk_ptr, sz + next_chunk_sz), new_hdr);
c010a082:	8d 44 10 fc          	lea    -0x4(%eax,%edx,1),%eax
c010a086:	89 1c 01             	mov    %ebx,(%ecx,%eax,1)
        chunk_ptr -= prev_chunk_sz;
c010a089:	89 f9                	mov    %edi,%ecx
c010a08b:	eb b0                	jmp    c010a03d <coalesce+0x3d>

c010a08d <lxfree>:
{
c010a08d:	55                   	push   %ebp
c010a08e:	89 e5                	mov    %esp,%ebp
c010a090:	57                   	push   %edi
c010a091:	56                   	push   %esi
c010a092:	53                   	push   %ebx
c010a093:	83 ec 0c             	sub    $0xc,%esp
c010a096:	8b 5d 08             	mov    0x8(%ebp),%ebx
    if (!ptr) {
c010a099:	85 db                	test   %ebx,%ebx
c010a09b:	74 59                	je     c010a0f6 <lxfree+0x69>
static inline unsigned int mutex_on_hold(mutex_t *mutex) {
    return !atomic_load(&mutex->counter);
}

static inline void mutex_lock(mutex_t *mutex) {
    sem_wait(mutex);
c010a09d:	83 ec 0c             	sub    $0xc,%esp
c010a0a0:	68 0c 00 11 c0       	push   $0xc011000c
c010a0a5:	e8 e6 15 00 00       	call   c010b690 <sem_wait>
    uint8_t* chunk_ptr = (uint8_t*)ptr - WSIZE;
c010a0aa:	8d 4b fc             	lea    -0x4(%ebx),%ecx
    uint32_t hdr = LW(chunk_ptr);
c010a0ad:	8b 43 fc             	mov    -0x4(%ebx),%eax
    size_t sz = CHUNK_S(hdr);
c010a0b0:	89 c2                	mov    %eax,%edx
c010a0b2:	83 e2 fc             	and    $0xfffffffc,%edx
    uint8_t* next_hdr = chunk_ptr + sz;
c010a0b5:	8d 34 11             	lea    (%ecx,%edx,1),%esi
    assert_msg(((uintptr_t)ptr < (uintptr_t)(-sz)) && !((uintptr_t)ptr & 0x3),
c010a0b8:	89 d7                	mov    %edx,%edi
c010a0ba:	f7 df                	neg    %edi
c010a0bc:	83 c4 10             	add    $0x10,%esp
c010a0bf:	39 df                	cmp    %ebx,%edi
c010a0c1:	76 3b                	jbe    c010a0fe <lxfree+0x71>
c010a0c3:	f6 c3 03             	test   $0x3,%bl
c010a0c6:	75 36                	jne    c010a0fe <lxfree+0x71>
    assert_msg(sz > WSIZE, "free(): invalid size");
c010a0c8:	83 fa 04             	cmp    $0x4,%edx
c010a0cb:	76 48                	jbe    c010a115 <lxfree+0x88>
    SW(chunk_ptr, hdr & ~M_ALLOCATED);
c010a0cd:	83 e0 fe             	and    $0xfffffffe,%eax
c010a0d0:	89 43 fc             	mov    %eax,-0x4(%ebx)
    SW(FPTR(chunk_ptr, sz), hdr & ~M_ALLOCATED);
c010a0d3:	89 44 11 fc          	mov    %eax,-0x4(%ecx,%edx,1)
    SW(next_hdr, LW(next_hdr) | M_PREV_FREE);
c010a0d7:	8b 06                	mov    (%esi),%eax
c010a0d9:	83 c8 02             	or     $0x2,%eax
c010a0dc:	89 06                	mov    %eax,(%esi)
    coalesce(chunk_ptr);
c010a0de:	83 ec 0c             	sub    $0xc,%esp
c010a0e1:	51                   	push   %ecx
c010a0e2:	e8 19 ff ff ff       	call   c010a000 <coalesce>
}

static inline void mutex_unlock(mutex_t *mutex) {
    sem_post(mutex);
c010a0e7:	c7 04 24 0c 00 11 c0 	movl   $0xc011000c,(%esp)
c010a0ee:	e8 af 15 00 00       	call   c010b6a2 <sem_post>
}
c010a0f3:	83 c4 10             	add    $0x10,%esp
}
c010a0f6:	8d 65 f4             	lea    -0xc(%ebp),%esp
c010a0f9:	5b                   	pop    %ebx
c010a0fa:	5e                   	pop    %esi
c010a0fb:	5f                   	pop    %edi
c010a0fc:	5d                   	pop    %ebp
c010a0fd:	c3                   	ret    
    assert_msg(((uintptr_t)ptr < (uintptr_t)(-sz)) && !((uintptr_t)ptr & 0x3),
c010a0fe:	83 ec 04             	sub    $0x4,%esp
c010a101:	68 88 00 00 00       	push   $0x88
c010a106:	68 9a 31 d1 c0       	push   $0xc0d1319a
c010a10b:	68 ad 31 d1 c0       	push   $0xc0d131ad
c010a110:	e8 4e 0e 00 00       	call   c010af63 <__assert_fail>
    assert_msg(sz > WSIZE, "free(): invalid size");
c010a115:	83 ec 04             	sub    $0x4,%esp
c010a118:	68 8b 00 00 00       	push   $0x8b
c010a11d:	68 9a 31 d1 c0       	push   $0xc0d1319a
c010a122:	68 c5 31 d1 c0       	push   $0xc0d131c5
c010a127:	e8 37 0e 00 00       	call   c010af63 <__assert_fail>

c010a12c <place_chunk>:
{
c010a12c:	55                   	push   %ebp
c010a12d:	89 e5                	mov    %esp,%ebp
c010a12f:	53                   	push   %ebx
c010a130:	83 ec 04             	sub    $0x4,%esp
c010a133:	8b 45 08             	mov    0x8(%ebp),%eax
    uint32_t header = *((uint32_t*)ptr);
c010a136:	8b 18                	mov    (%eax),%ebx
    size_t chunk_size = CHUNK_S(header);
c010a138:	89 d9                	mov    %ebx,%ecx
c010a13a:	83 e1 fc             	and    $0xfffffffc,%ecx
    *((uint32_t*)ptr) = PACK(size, CHUNK_PF(header) | M_ALLOCATED);
c010a13d:	8b 55 0c             	mov    0xc(%ebp),%edx
c010a140:	83 e2 fc             	and    $0xfffffffc,%edx
c010a143:	83 e3 02             	and    $0x2,%ebx
c010a146:	09 da                	or     %ebx,%edx
c010a148:	83 ca 01             	or     $0x1,%edx
c010a14b:	89 10                	mov    %edx,(%eax)
    uint8_t* n_hdrptr = (uint8_t*)(ptr + size);
c010a14d:	03 45 0c             	add    0xc(%ebp),%eax
    if (!diff) {
c010a150:	2b 4d 0c             	sub    0xc(%ebp),%ecx
c010a153:	75 0c                	jne    c010a161 <place_chunk+0x35>
        SW(n_hdrptr, n_hdr & ~0x2);
c010a155:	8b 10                	mov    (%eax),%edx
c010a157:	83 e2 fd             	and    $0xfffffffd,%edx
c010a15a:	89 10                	mov    %edx,(%eax)
}
c010a15c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c010a15f:	c9                   	leave  
c010a160:	c3                   	ret    
        uint32_t remainder_hdr = PACK(diff, M_NOT_ALLOCATED | M_PREV_ALLOCATED);
c010a161:	89 ca                	mov    %ecx,%edx
c010a163:	83 e2 fc             	and    $0xfffffffc,%edx
        SW(n_hdrptr, remainder_hdr);
c010a166:	89 10                	mov    %edx,(%eax)
        SW(FPTR(n_hdrptr, diff), remainder_hdr);
c010a168:	89 54 08 fc          	mov    %edx,-0x4(%eax,%ecx,1)
        coalesce(n_hdrptr);
c010a16c:	83 ec 0c             	sub    $0xc,%esp
c010a16f:	50                   	push   %eax
c010a170:	e8 8b fe ff ff       	call   c010a000 <coalesce>
c010a175:	83 c4 10             	add    $0x10,%esp
}
c010a178:	eb e2                	jmp    c010a15c <place_chunk+0x30>

c010a17a <lx_grow_heap>:

void*
lx_grow_heap(heap_context_t* heap, size_t sz)
{
c010a17a:	55                   	push   %ebp
c010a17b:	89 e5                	mov    %esp,%ebp
c010a17d:	56                   	push   %esi
c010a17e:	53                   	push   %ebx
c010a17f:	8b 75 08             	mov    0x8(%ebp),%esi
c010a182:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    void* start;

    // The "+ WSIZE" capture the overhead for epilogue marker
    if (!(start = lxsbrk(heap, sz + WSIZE, 0))) {
c010a185:	83 ec 04             	sub    $0x4,%esp
c010a188:	6a 00                	push   $0x0
c010a18a:	8d 43 04             	lea    0x4(%ebx),%eax
c010a18d:	50                   	push   %eax
c010a18e:	56                   	push   %esi
c010a18f:	e8 4b 05 00 00       	call   c010a6df <lxsbrk>
c010a194:	83 c4 10             	add    $0x10,%esp
c010a197:	85 c0                	test   %eax,%eax
c010a199:	74 2d                	je     c010a1c8 <lx_grow_heap+0x4e>
        return NULL;
    }
    sz = ROUNDUP(sz, BOUNDARY);
c010a19b:	83 c3 03             	add    $0x3,%ebx
c010a19e:	83 e3 fc             	and    $0xfffffffc,%ebx

    // minus the overhead for epilogue, keep the invariant.
    heap->brk -= WSIZE;
c010a1a1:	83 6e 04 04          	subl   $0x4,0x4(%esi)

    uint32_t old_marker = *((uint32_t*)start);
    uint32_t free_hdr = PACK(sz, CHUNK_PF(old_marker));
c010a1a5:	8b 10                	mov    (%eax),%edx
c010a1a7:	83 e2 02             	and    $0x2,%edx
c010a1aa:	09 da                	or     %ebx,%edx
    SW(start, free_hdr);
c010a1ac:	89 10                	mov    %edx,(%eax)
    SW(FPTR(start, sz), free_hdr);
c010a1ae:	89 54 18 fc          	mov    %edx,-0x4(%eax,%ebx,1)
    SW(NEXT_CHK(start), PACK(0, M_ALLOCATED | M_PREV_FREE));
c010a1b2:	83 e2 fc             	and    $0xfffffffc,%edx
c010a1b5:	c7 04 10 03 00 00 00 	movl   $0x3,(%eax,%edx,1)

    return coalesce(start);
c010a1bc:	83 ec 0c             	sub    $0xc,%esp
c010a1bf:	50                   	push   %eax
c010a1c0:	e8 3b fe ff ff       	call   c010a000 <coalesce>
c010a1c5:	83 c4 10             	add    $0x10,%esp
c010a1c8:	8d 65 f8             	lea    -0x8(%ebp),%esp
c010a1cb:	5b                   	pop    %ebx
c010a1cc:	5e                   	pop    %esi
c010a1cd:	5d                   	pop    %ebp
c010a1ce:	c3                   	ret    

c010a1cf <kalloc_init>:
{
c010a1cf:	55                   	push   %ebp
c010a1d0:	89 e5                	mov    %esp,%ebp
c010a1d2:	53                   	push   %ebx
c010a1d3:	83 ec 04             	sub    $0x4,%esp
    kheap.start = KHEAP_START;
c010a1d6:	c7 05 00 00 11 c0 00 	movl   $0xc0400000,0xc0110000
c010a1dd:	00 40 c0 
    kheap.brk = NULL;
c010a1e0:	c7 05 04 00 11 c0 00 	movl   $0x0,0xc0110004
c010a1e7:	00 00 00 
    kheap.max_addr =
c010a1ea:	c7 05 08 00 11 c0 00 	movl   $0xd0400000,0xc0110008
c010a1f1:	00 40 d0 
    for (size_t i = 0; i < KHEAP_SIZE_MB >> 2; i++) {
c010a1f4:	bb 00 00 00 00       	mov    $0x0,%ebx
c010a1f9:	eb 25                	jmp    c010a220 <kalloc_init+0x51>
                        (uintptr_t)kheap.start + (i << 22),
c010a1fb:	89 d8                	mov    %ebx,%eax
c010a1fd:	c1 e0 16             	shl    $0x16,%eax
        vmm_set_mapping(PD_REFERENCED,
c010a200:	83 ec 0c             	sub    $0xc,%esp
c010a203:	6a 02                	push   $0x2
c010a205:	6a 03                	push   $0x3
c010a207:	6a 00                	push   $0x0
c010a209:	03 05 00 00 11 c0    	add    0xc0110000,%eax
c010a20f:	50                   	push   %eax
c010a210:	68 00 00 c0 ff       	push   $0xffc00000
c010a215:	e8 26 02 00 00       	call   c010a440 <vmm_set_mapping>
    for (size_t i = 0; i < KHEAP_SIZE_MB >> 2; i++) {
c010a21a:	83 c3 01             	add    $0x1,%ebx
c010a21d:	83 c4 20             	add    $0x20,%esp
c010a220:	83 fb 3f             	cmp    $0x3f,%ebx
c010a223:	76 d6                	jbe    c010a1fb <kalloc_init+0x2c>
    if (!dmm_init(&kheap)) {
c010a225:	83 ec 0c             	sub    $0xc,%esp
c010a228:	68 00 00 11 c0       	push   $0xc0110000
c010a22d:	e8 38 04 00 00       	call   c010a66a <dmm_init>
c010a232:	83 c4 10             	add    $0x10,%esp
c010a235:	85 c0                	test   %eax,%eax
c010a237:	75 05                	jne    c010a23e <kalloc_init+0x6f>
}
c010a239:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c010a23c:	c9                   	leave  
c010a23d:	c3                   	ret    
    SW(kheap.start, PACK(4, M_ALLOCATED));
c010a23e:	a1 00 00 11 c0       	mov    0xc0110000,%eax
c010a243:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
    SW(kheap.start + WSIZE, PACK(0, M_ALLOCATED));
c010a249:	a1 00 00 11 c0       	mov    0xc0110000,%eax
c010a24e:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
    kheap.brk += WSIZE;
c010a255:	a1 04 00 11 c0       	mov    0xc0110004,%eax
c010a25a:	83 c0 04             	add    $0x4,%eax
c010a25d:	a3 04 00 11 c0       	mov    %eax,0xc0110004
    return lx_grow_heap(&kheap, HEAP_INIT_SIZE) != NULL;
c010a262:	83 ec 08             	sub    $0x8,%esp
c010a265:	68 00 10 00 00       	push   $0x1000
c010a26a:	68 00 00 11 c0       	push   $0xc0110000
c010a26f:	e8 06 ff ff ff       	call   c010a17a <lx_grow_heap>
c010a274:	83 c4 10             	add    $0x10,%esp
c010a277:	85 c0                	test   %eax,%eax
c010a279:	0f 95 c0             	setne  %al
c010a27c:	0f b6 c0             	movzbl %al,%eax
c010a27f:	eb b8                	jmp    c010a239 <kalloc_init+0x6a>

c010a281 <lx_malloc_internal>:
{
c010a281:	55                   	push   %ebp
c010a282:	89 e5                	mov    %esp,%ebp
c010a284:	56                   	push   %esi
c010a285:	53                   	push   %ebx
c010a286:	8b 4d 08             	mov    0x8(%ebp),%ecx
c010a289:	8b 75 0c             	mov    0xc(%ebp),%esi
    if (!size) {
c010a28c:	85 f6                	test   %esi,%esi
c010a28e:	74 64                	je     c010a2f4 <lx_malloc_internal+0x73>
    uint8_t* ptr = heap->start;
c010a290:	8b 19                	mov    (%ecx),%ebx
    size = ROUNDUP(size + WSIZE, BOUNDARY);
c010a292:	83 c6 07             	add    $0x7,%esi
c010a295:	83 e6 fc             	and    $0xfffffffc,%esi
    while (ptr < (uint8_t*)heap->brk) {
c010a298:	eb 02                	jmp    c010a29c <lx_malloc_internal+0x1b>
        ptr += chunk_size;
c010a29a:	01 d3                	add    %edx,%ebx
    while (ptr < (uint8_t*)heap->brk) {
c010a29c:	39 59 04             	cmp    %ebx,0x4(%ecx)
c010a29f:	76 27                	jbe    c010a2c8 <lx_malloc_internal+0x47>
        uint32_t header = *((uint32_t*)ptr);
c010a2a1:	8b 03                	mov    (%ebx),%eax
        if (!chunk_size && CHUNK_A(header)) {
c010a2a3:	89 c2                	mov    %eax,%edx
c010a2a5:	83 e2 fc             	and    $0xfffffffc,%edx
c010a2a8:	75 04                	jne    c010a2ae <lx_malloc_internal+0x2d>
c010a2aa:	a8 01                	test   $0x1,%al
c010a2ac:	75 1a                	jne    c010a2c8 <lx_malloc_internal+0x47>
        if (chunk_size >= size && !CHUNK_A(header)) {
c010a2ae:	39 d6                	cmp    %edx,%esi
c010a2b0:	77 e8                	ja     c010a29a <lx_malloc_internal+0x19>
c010a2b2:	a8 01                	test   $0x1,%al
c010a2b4:	75 e4                	jne    c010a29a <lx_malloc_internal+0x19>
            place_chunk(ptr, size);
c010a2b6:	83 ec 08             	sub    $0x8,%esp
c010a2b9:	56                   	push   %esi
c010a2ba:	53                   	push   %ebx
c010a2bb:	e8 6c fe ff ff       	call   c010a12c <place_chunk>
            return BPTR(ptr);
c010a2c0:	83 c3 04             	add    $0x4,%ebx
c010a2c3:	83 c4 10             	add    $0x10,%esp
c010a2c6:	eb 23                	jmp    c010a2eb <lx_malloc_internal+0x6a>
    if ((ptr = lx_grow_heap(heap, size))) {
c010a2c8:	83 ec 08             	sub    $0x8,%esp
c010a2cb:	56                   	push   %esi
c010a2cc:	51                   	push   %ecx
c010a2cd:	e8 a8 fe ff ff       	call   c010a17a <lx_grow_heap>
c010a2d2:	89 c3                	mov    %eax,%ebx
c010a2d4:	83 c4 10             	add    $0x10,%esp
c010a2d7:	85 c0                	test   %eax,%eax
c010a2d9:	74 10                	je     c010a2eb <lx_malloc_internal+0x6a>
        place_chunk(ptr, size);
c010a2db:	83 ec 08             	sub    $0x8,%esp
c010a2de:	56                   	push   %esi
c010a2df:	50                   	push   %eax
c010a2e0:	e8 47 fe ff ff       	call   c010a12c <place_chunk>
        return BPTR(ptr);
c010a2e5:	83 c3 04             	add    $0x4,%ebx
c010a2e8:	83 c4 10             	add    $0x10,%esp
}
c010a2eb:	89 d8                	mov    %ebx,%eax
c010a2ed:	8d 65 f8             	lea    -0x8(%ebp),%esp
c010a2f0:	5b                   	pop    %ebx
c010a2f1:	5e                   	pop    %esi
c010a2f2:	5d                   	pop    %ebp
c010a2f3:	c3                   	ret    
        return NULL;
c010a2f4:	bb 00 00 00 00       	mov    $0x0,%ebx
c010a2f9:	eb f0                	jmp    c010a2eb <lx_malloc_internal+0x6a>

c010a2fb <lxmalloc>:
{
c010a2fb:	55                   	push   %ebp
c010a2fc:	89 e5                	mov    %esp,%ebp
c010a2fe:	53                   	push   %ebx
c010a2ff:	83 ec 10             	sub    $0x10,%esp
    sem_wait(mutex);
c010a302:	68 0c 00 11 c0       	push   $0xc011000c
c010a307:	e8 84 13 00 00       	call   c010b690 <sem_wait>
    void* r = lx_malloc_internal(&kheap, size);
c010a30c:	83 c4 08             	add    $0x8,%esp
c010a30f:	ff 75 08             	push   0x8(%ebp)
c010a312:	68 00 00 11 c0       	push   $0xc0110000
c010a317:	e8 65 ff ff ff       	call   c010a281 <lx_malloc_internal>
c010a31c:	89 c3                	mov    %eax,%ebx
    sem_post(mutex);
c010a31e:	c7 04 24 0c 00 11 c0 	movl   $0xc011000c,(%esp)
c010a325:	e8 78 13 00 00       	call   c010b6a2 <sem_post>
}
c010a32a:	89 d8                	mov    %ebx,%eax
c010a32c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c010a32f:	c9                   	leave  
c010a330:	c3                   	ret    

c010a331 <lxcalloc>:
{
c010a331:	55                   	push   %ebp
c010a332:	89 e5                	mov    %esp,%ebp
c010a334:	53                   	push   %ebx
c010a335:	83 ec 04             	sub    $0x4,%esp
c010a338:	8b 45 08             	mov    0x8(%ebp),%eax
c010a33b:	8b 55 0c             	mov    0xc(%ebp),%edx
    size_t pd = n * elem;
c010a33e:	89 c3                	mov    %eax,%ebx
c010a340:	0f af da             	imul   %edx,%ebx
    if (pd < elem || pd < n) {
c010a343:	39 d0                	cmp    %edx,%eax
c010a345:	0f 42 c2             	cmovb  %edx,%eax
c010a348:	39 c3                	cmp    %eax,%ebx
c010a34a:	72 24                	jb     c010a370 <lxcalloc+0x3f>
    void* ptr = lxmalloc(pd);
c010a34c:	83 ec 0c             	sub    $0xc,%esp
c010a34f:	53                   	push   %ebx
c010a350:	e8 a6 ff ff ff       	call   c010a2fb <lxmalloc>
    if (!ptr) {
c010a355:	83 c4 10             	add    $0x10,%esp
c010a358:	85 c0                	test   %eax,%eax
c010a35a:	74 0f                	je     c010a36b <lxcalloc+0x3a>
    return memset(ptr, 0, pd);
c010a35c:	83 ec 04             	sub    $0x4,%esp
c010a35f:	53                   	push   %ebx
c010a360:	6a 00                	push   $0x0
c010a362:	50                   	push   %eax
c010a363:	e8 13 49 00 00       	call   c010ec7b <memset>
c010a368:	83 c4 10             	add    $0x10,%esp
}
c010a36b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c010a36e:	c9                   	leave  
c010a36f:	c3                   	ret    
        return NULL;
c010a370:	b8 00 00 00 00       	mov    $0x0,%eax
c010a375:	eb f4                	jmp    c010a36b <lxcalloc+0x3a>

c010a377 <vmm_dup_page>:
#include <lunaix/mm/vmm.h>

void*
vmm_dup_page(pid_t pid, void* pa)
{
c010a377:	55                   	push   %ebp
c010a378:	89 e5                	mov    %esp,%ebp
c010a37a:	57                   	push   %edi
c010a37b:	56                   	push   %esi
c010a37c:	53                   	push   %ebx
c010a37d:	83 ec 14             	sub    $0x14,%esp
    void* new_ppg = pmm_alloc_page(pid, 0);
c010a380:	6a 00                	push   $0x0
c010a382:	ff 75 08             	push   0x8(%ebp)
c010a385:	e8 3d 07 00 00       	call   c010aac7 <pmm_alloc_page>
c010a38a:	89 c3                	mov    %eax,%ebx
    vmm_set_mapping(PD_REFERENCED, PG_MOUNT_3, new_ppg, PG_PREM_RW, VMAP_NULL);
c010a38c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c010a393:	6a 03                	push   $0x3
c010a395:	50                   	push   %eax
c010a396:	68 00 20 40 d1       	push   $0xd1402000
c010a39b:	68 00 00 c0 ff       	push   $0xffc00000
c010a3a0:	e8 9b 00 00 00       	call   c010a440 <vmm_set_mapping>
    vmm_set_mapping(PD_REFERENCED, PG_MOUNT_4, pa, PG_PREM_RW, VMAP_NULL);
c010a3a5:	83 c4 14             	add    $0x14,%esp
c010a3a8:	6a 00                	push   $0x0
c010a3aa:	6a 03                	push   $0x3
c010a3ac:	ff 75 0c             	push   0xc(%ebp)
c010a3af:	68 00 30 40 d1       	push   $0xd1403000
c010a3b4:	68 00 00 c0 ff       	push   $0xffc00000
c010a3b9:	e8 82 00 00 00       	call   c010a440 <vmm_set_mapping>

    asm volatile("movl %1, %%edi\n"
c010a3be:	b9 00 04 00 00       	mov    $0x400,%ecx
c010a3c3:	b8 00 20 40 d1       	mov    $0xd1402000,%eax
c010a3c8:	ba 00 30 40 d1       	mov    $0xd1403000,%edx
c010a3cd:	89 c7                	mov    %eax,%edi
c010a3cf:	89 d6                	mov    %edx,%esi
c010a3d1:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
                 "rep movsl\n" ::"c"(1024),
                 "r"(PG_MOUNT_3),
                 "r"(PG_MOUNT_4)
                 : "memory", "%edi", "%esi");

    vmm_del_mapping(PD_REFERENCED, PG_MOUNT_3);
c010a3d3:	83 c4 18             	add    $0x18,%esp
c010a3d6:	68 00 20 40 d1       	push   $0xd1402000
c010a3db:	68 00 00 c0 ff       	push   $0xffc00000
c010a3e0:	e8 69 01 00 00       	call   c010a54e <vmm_del_mapping>
    vmm_del_mapping(PD_REFERENCED, PG_MOUNT_4);
c010a3e5:	83 c4 08             	add    $0x8,%esp
c010a3e8:	68 00 30 40 d1       	push   $0xd1403000
c010a3ed:	68 00 00 c0 ff       	push   $0xffc00000
c010a3f2:	e8 57 01 00 00       	call   c010a54e <vmm_del_mapping>

    return new_ppg;
c010a3f7:	89 d8                	mov    %ebx,%eax
c010a3f9:	8d 65 f4             	lea    -0xc(%ebp),%esp
c010a3fc:	5b                   	pop    %ebx
c010a3fd:	5e                   	pop    %esi
c010a3fe:	5f                   	pop    %edi
c010a3ff:	5d                   	pop    %ebp
c010a400:	c3                   	ret    

c010a401 <vmm_init>:

void
vmm_init()
{
    // XXX: something here?
}
c010a401:	c3                   	ret    

c010a402 <vmm_init_pd>:

x86_page_table*
vmm_init_pd()
{
c010a402:	55                   	push   %ebp
c010a403:	89 e5                	mov    %esp,%ebp
c010a405:	83 ec 10             	sub    $0x10,%esp
    x86_page_table* dir =
      (x86_page_table*)pmm_alloc_page(KERNEL_PID, PP_FGPERSIST);
c010a408:	6a 01                	push   $0x1
c010a40a:	6a ff                	push   $0xffffffff
c010a40c:	e8 b6 06 00 00       	call   c010aac7 <pmm_alloc_page>
    for (size_t i = 0; i < PG_MAX_ENTRIES; i++) {
c010a411:	83 c4 10             	add    $0x10,%esp
c010a414:	ba 00 00 00 00       	mov    $0x0,%edx
c010a419:	eb 0a                	jmp    c010a425 <vmm_init_pd+0x23>
        dir->entry[i] = PTE_NULL;
c010a41b:	c7 04 90 00 00 00 00 	movl   $0x0,(%eax,%edx,4)
    for (size_t i = 0; i < PG_MAX_ENTRIES; i++) {
c010a422:	83 c2 01             	add    $0x1,%edx
c010a425:	81 fa ff 03 00 00    	cmp    $0x3ff,%edx
c010a42b:	76 ee                	jbe    c010a41b <vmm_init_pd+0x19>
    }

    // 递归映射，方便我们在软件层面进行查表地址转换
    dir->entry[PG_MAX_ENTRIES - 1] = NEW_L1_ENTRY(T_SELF_REF_PERM, dir);
c010a42d:	89 c2                	mov    %eax,%edx
c010a42f:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
c010a435:	83 ca 1b             	or     $0x1b,%edx
c010a438:	89 90 fc 0f 00 00    	mov    %edx,0xffc(%eax)

    return dir;
}
c010a43e:	c9                   	leave  
c010a43f:	c3                   	ret    

c010a440 <vmm_set_mapping>:
vmm_set_mapping(uintptr_t mnt,
                uintptr_t va,
                uintptr_t pa,
                pt_attr attr,
                int options)
{
c010a440:	55                   	push   %ebp
c010a441:	89 e5                	mov    %esp,%ebp
c010a443:	57                   	push   %edi
c010a444:	56                   	push   %esi
c010a445:	53                   	push   %ebx
c010a446:	83 ec 1c             	sub    $0x1c,%esp
    assert((uintptr_t)va % PG_SIZE == 0);
c010a449:	f7 45 0c ff 0f 00 00 	testl  $0xfff,0xc(%ebp)
c010a450:	75 4d                	jne    c010a49f <vmm_set_mapping+0x5f>

    uintptr_t l1_inx = L1_INDEX(va);
c010a452:	8b 75 0c             	mov    0xc(%ebp),%esi
c010a455:	c1 ee 16             	shr    $0x16,%esi
    uintptr_t l2_inx = L2_INDEX(va);
c010a458:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a45b:	c1 e8 0c             	shr    $0xc,%eax
c010a45e:	25 ff 03 00 00       	and    $0x3ff,%eax
c010a463:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x86_page_table* l1pt = (x86_page_table*)(mnt | (1023 << 12));
c010a466:	8b 7d 08             	mov    0x8(%ebp),%edi
c010a469:	81 cf 00 f0 3f 00    	or     $0x3ff000,%edi
    x86_page_table* l2pt = (x86_page_table*)(mnt | (l1_inx << 12));
c010a46f:	89 f3                	mov    %esi,%ebx
c010a471:	c1 e3 0c             	shl    $0xc,%ebx
c010a474:	0b 5d 08             	or     0x8(%ebp),%ebx

    // See if attr make sense
    assert(attr <= 128);
c010a477:	81 7d 14 80 00 00 00 	cmpl   $0x80,0x14(%ebp)
c010a47e:	77 33                	ja     c010a4b3 <vmm_set_mapping+0x73>

    if (!l1pt->entry[l1_inx]) {
c010a480:	83 3c b7 00          	cmpl   $0x0,(%edi,%esi,4)
c010a484:	74 41                	je     c010a4c7 <vmm_set_mapping+0x87>
          NEW_L1_ENTRY(attr | PG_WRITE | PG_PRESENT, new_l1pt_pa);

        memset((void*)l2pt, 0, PG_SIZE);
    } else {
        x86_pte_t pte = l2pt->entry[l2_inx];
        if (pte && (options & VMAP_IGNORE)) {
c010a486:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010a489:	83 3c 83 00          	cmpl   $0x0,(%ebx,%eax,4)
c010a48d:	74 74                	je     c010a503 <vmm_set_mapping+0xc3>
c010a48f:	f6 45 18 01          	testb  $0x1,0x18(%ebp)
c010a493:	74 6e                	je     c010a503 <vmm_set_mapping+0xc3>
            return 1;
c010a495:	b8 01 00 00 00       	mov    $0x1,%eax
c010a49a:	e9 91 00 00 00       	jmp    c010a530 <vmm_set_mapping+0xf0>
    assert((uintptr_t)va % PG_SIZE == 0);
c010a49f:	83 ec 04             	sub    $0x4,%esp
c010a4a2:	6a 23                	push   $0x23
c010a4a4:	68 da 31 d1 c0       	push   $0xc0d131da
c010a4a9:	68 ea 31 d1 c0       	push   $0xc0d131ea
c010a4ae:	e8 b0 0a 00 00       	call   c010af63 <__assert_fail>
    assert(attr <= 128);
c010a4b3:	83 ec 04             	sub    $0x4,%esp
c010a4b6:	6a 2b                	push   $0x2b
c010a4b8:	68 da 31 d1 c0       	push   $0xc0d131da
c010a4bd:	68 07 32 d1 c0       	push   $0xc0d13207
c010a4c2:	e8 9c 0a 00 00       	call   c010af63 <__assert_fail>
        x86_page_table* new_l1pt_pa = pmm_alloc_page(KERNEL_PID, PP_FGPERSIST);
c010a4c7:	83 ec 08             	sub    $0x8,%esp
c010a4ca:	6a 01                	push   $0x1
c010a4cc:	6a ff                	push   $0xffffffff
c010a4ce:	e8 f4 05 00 00       	call   c010aac7 <pmm_alloc_page>
        if (!new_l1pt_pa) {
c010a4d3:	83 c4 10             	add    $0x10,%esp
c010a4d6:	85 c0                	test   %eax,%eax
c010a4d8:	74 66                	je     c010a540 <vmm_set_mapping+0x100>
          NEW_L1_ENTRY(attr | PG_WRITE | PG_PRESENT, new_l1pt_pa);
c010a4da:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c010a4df:	8b 55 14             	mov    0x14(%ebp),%edx
c010a4e2:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
c010a4e8:	83 ca 0b             	or     $0xb,%edx
c010a4eb:	09 d0                	or     %edx,%eax
        l1pt->entry[l1_inx] =
c010a4ed:	89 04 b7             	mov    %eax,(%edi,%esi,4)
        memset((void*)l2pt, 0, PG_SIZE);
c010a4f0:	83 ec 04             	sub    $0x4,%esp
c010a4f3:	68 00 10 00 00       	push   $0x1000
c010a4f8:	6a 00                	push   $0x0
c010a4fa:	53                   	push   %ebx
c010a4fb:	e8 7b 47 00 00       	call   c010ec7b <memset>
c010a500:	83 c4 10             	add    $0x10,%esp
        }
    }

    if (mnt == PD_REFERENCED) {
c010a503:	81 7d 08 00 00 c0 ff 	cmpl   $0xffc00000,0x8(%ebp)
c010a50a:	74 2c                	je     c010a538 <vmm_set_mapping+0xf8>
        cpu_invplg(va);
    }

    if ((options & VMAP_NOMAP)) {
c010a50c:	f6 45 18 02          	testb  $0x2,0x18(%ebp)
c010a510:	75 35                	jne    c010a547 <vmm_set_mapping+0x107>
        return 1;
    }

    l2pt->entry[l2_inx] = NEW_L2_ENTRY(attr, pa);
c010a512:	8b 55 10             	mov    0x10(%ebp),%edx
c010a515:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
c010a51b:	8b 45 14             	mov    0x14(%ebp),%eax
c010a51e:	25 ff 0f 00 00       	and    $0xfff,%eax
c010a523:	09 d0                	or     %edx,%eax
c010a525:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
c010a528:	89 04 8b             	mov    %eax,(%ebx,%ecx,4)
    return 1;
c010a52b:	b8 01 00 00 00       	mov    $0x1,%eax
}
c010a530:	8d 65 f4             	lea    -0xc(%ebp),%esp
c010a533:	5b                   	pop    %ebx
c010a534:	5e                   	pop    %esi
c010a535:	5f                   	pop    %edi
c010a536:	5d                   	pop    %ebp
c010a537:	c3                   	ret    
}

static inline void
cpu_invplg(void* va)
{
    asm volatile("invlpg (%0)" ::"r"((uintptr_t)va) : "memory");
c010a538:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a53b:	0f 01 38             	invlpg (%eax)
}
c010a53e:	eb cc                	jmp    c010a50c <vmm_set_mapping+0xcc>
            return 0;
c010a540:	b8 00 00 00 00       	mov    $0x0,%eax
c010a545:	eb e9                	jmp    c010a530 <vmm_set_mapping+0xf0>
        return 1;
c010a547:	b8 01 00 00 00       	mov    $0x1,%eax
c010a54c:	eb e2                	jmp    c010a530 <vmm_set_mapping+0xf0>

c010a54e <vmm_del_mapping>:

uintptr_t
vmm_del_mapping(uintptr_t mnt, uintptr_t va)
{
c010a54e:	55                   	push   %ebp
c010a54f:	89 e5                	mov    %esp,%ebp
c010a551:	53                   	push   %ebx
c010a552:	83 ec 04             	sub    $0x4,%esp
c010a555:	8b 55 0c             	mov    0xc(%ebp),%edx
    assert(((uintptr_t)va & 0xFFFU) == 0);
c010a558:	89 d0                	mov    %edx,%eax
c010a55a:	25 ff 0f 00 00       	and    $0xfff,%eax
c010a55f:	75 2c                	jne    c010a58d <vmm_del_mapping+0x3f>

    uint32_t l1_index = L1_INDEX(va);
c010a561:	89 d1                	mov    %edx,%ecx
c010a563:	c1 e9 16             	shr    $0x16,%ecx
    uint32_t l2_index = L2_INDEX(va);
c010a566:	89 d3                	mov    %edx,%ebx
c010a568:	c1 eb 0c             	shr    $0xc,%ebx
c010a56b:	81 e3 ff 03 00 00    	and    $0x3ff,%ebx

    // prevent unmap of recursive mapping region
    if (l1_index == 1023) {
c010a571:	81 f9 ff 03 00 00    	cmp    $0x3ff,%ecx
c010a577:	74 0f                	je     c010a588 <vmm_del_mapping+0x3a>
        return 0;
    }

    x86_page_table* l1pt = (x86_page_table*)(mnt | (1023 << 12));
c010a579:	8b 45 08             	mov    0x8(%ebp),%eax
c010a57c:	0d 00 f0 3f 00       	or     $0x3ff000,%eax

    x86_pte_t l1pte = l1pt->entry[l1_index];
c010a581:	8b 04 88             	mov    (%eax,%ecx,4),%eax

    if (l1pte) {
c010a584:	85 c0                	test   %eax,%eax
c010a586:	75 19                	jne    c010a5a1 <vmm_del_mapping+0x53>

        return PG_ENTRY_ADDR(l2pte);
    }

    return 0;
}
c010a588:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c010a58b:	c9                   	leave  
c010a58c:	c3                   	ret    
    assert(((uintptr_t)va & 0xFFFU) == 0);
c010a58d:	83 ec 04             	sub    $0x4,%esp
c010a590:	6a 50                	push   $0x50
c010a592:	68 da 31 d1 c0       	push   $0xc0d131da
c010a597:	68 13 32 d1 c0       	push   $0xc0d13213
c010a59c:	e8 c2 09 00 00       	call   c010af63 <__assert_fail>
        x86_page_table* l2pt = (x86_page_table*)(mnt | (l1_index << 12));
c010a5a1:	c1 e1 0c             	shl    $0xc,%ecx
c010a5a4:	0b 4d 08             	or     0x8(%ebp),%ecx
        x86_pte_t l2pte = l2pt->entry[l2_index];
c010a5a7:	8b 04 99             	mov    (%ecx,%ebx,4),%eax
    asm volatile("invlpg (%0)" ::"r"((uintptr_t)va) : "memory");
c010a5aa:	0f 01 3a             	invlpg (%edx)
        l2pt->entry[l2_index] = PTE_NULL;
c010a5ad:	c7 04 99 00 00 00 00 	movl   $0x0,(%ecx,%ebx,4)
        return PG_ENTRY_ADDR(l2pte);
c010a5b4:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c010a5b9:	eb cd                	jmp    c010a588 <vmm_del_mapping+0x3a>

c010a5bb <vmm_lookup>:

int
vmm_lookup(uintptr_t va, v_mapping* mapping)
{
c010a5bb:	55                   	push   %ebp
c010a5bc:	89 e5                	mov    %esp,%ebp
c010a5be:	57                   	push   %edi
c010a5bf:	56                   	push   %esi
c010a5c0:	53                   	push   %ebx
c010a5c1:	8b 4d 08             	mov    0x8(%ebp),%ecx
c010a5c4:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    uint32_t l1_index = L1_INDEX(va);
c010a5c7:	89 c8                	mov    %ecx,%eax
c010a5c9:	c1 e8 16             	shr    $0x16,%eax
    uint32_t l2_index = L2_INDEX(va);
c010a5cc:	89 ca                	mov    %ecx,%edx
c010a5ce:	c1 ea 0c             	shr    $0xc,%edx
c010a5d1:	81 e2 ff 03 00 00    	and    $0x3ff,%edx

    x86_page_table* l1pt = (x86_page_table*)L1_BASE_VADDR;
    x86_pte_t l1pte = l1pt->entry[l1_index];

    if (l1pte) {
c010a5d7:	83 3c 85 00 f0 ff ff 	cmpl   $0x0,-0x1000(,%eax,4)
c010a5de:	00 
c010a5df:	74 39                	je     c010a61a <vmm_lookup+0x5f>
        x86_pte_t* l2pte =
          &((x86_page_table*)L2_VADDR(l1_index))->entry[l2_index];
c010a5e1:	c1 e0 0c             	shl    $0xc,%eax
c010a5e4:	0d 00 00 c0 ff       	or     $0xffc00000,%eax
        x86_pte_t* l2pte =
c010a5e9:	8d 34 90             	lea    (%eax,%edx,4),%esi
        if (l2pte) {
c010a5ec:	85 f6                	test   %esi,%esi
c010a5ee:	74 34                	je     c010a624 <vmm_lookup+0x69>
            mapping->flags = PG_ENTRY_FLAGS(*l2pte);
c010a5f0:	0f b7 3c 90          	movzwl (%eax,%edx,4),%edi
c010a5f4:	66 81 e7 ff 0f       	and    $0xfff,%di
c010a5f9:	66 89 7b 0c          	mov    %di,0xc(%ebx)
            mapping->pa = PG_ENTRY_ADDR(*l2pte);
c010a5fd:	8b 04 90             	mov    (%eax,%edx,4),%eax
c010a600:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c010a605:	89 43 08             	mov    %eax,0x8(%ebx)
            mapping->pn = mapping->pa >> PG_SIZE_BITS;
c010a608:	c1 e8 0c             	shr    $0xc,%eax
c010a60b:	89 43 04             	mov    %eax,0x4(%ebx)
            mapping->pte = l2pte;
c010a60e:	89 73 10             	mov    %esi,0x10(%ebx)
            mapping->va = va;
c010a611:	89 0b                	mov    %ecx,(%ebx)
            return 1;
c010a613:	b8 01 00 00 00       	mov    $0x1,%eax
c010a618:	eb 05                	jmp    c010a61f <vmm_lookup+0x64>
        }
    }
    return 0;
c010a61a:	b8 00 00 00 00       	mov    $0x0,%eax
}
c010a61f:	5b                   	pop    %ebx
c010a620:	5e                   	pop    %esi
c010a621:	5f                   	pop    %edi
c010a622:	5d                   	pop    %ebp
c010a623:	c3                   	ret    
    return 0;
c010a624:	b8 00 00 00 00       	mov    $0x0,%eax
c010a629:	eb f4                	jmp    c010a61f <vmm_lookup+0x64>

c010a62b <vmm_mount_pd>:

void*
vmm_mount_pd(uintptr_t mnt, void* pde)
{
c010a62b:	55                   	push   %ebp
c010a62c:	89 e5                	mov    %esp,%ebp
c010a62e:	8b 55 08             	mov    0x8(%ebp),%edx
    x86_page_table* l1pt = (x86_page_table*)L1_BASE_VADDR;
    l1pt->entry[(mnt >> 22)] = NEW_L1_ENTRY(T_SELF_REF_PERM, pde);
c010a631:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a634:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c010a639:	89 d1                	mov    %edx,%ecx
c010a63b:	c1 e9 16             	shr    $0x16,%ecx
c010a63e:	83 c8 1b             	or     $0x1b,%eax
c010a641:	89 04 8d 00 f0 ff ff 	mov    %eax,-0x1000(,%ecx,4)
c010a648:	0f 01 3a             	invlpg (%edx)
    cpu_invplg(mnt);
    return mnt;
}
c010a64b:	89 d0                	mov    %edx,%eax
c010a64d:	5d                   	pop    %ebp
c010a64e:	c3                   	ret    

c010a64f <vmm_unmount_pd>:

void*
vmm_unmount_pd(uintptr_t mnt)
{
c010a64f:	55                   	push   %ebp
c010a650:	89 e5                	mov    %esp,%ebp
c010a652:	8b 45 08             	mov    0x8(%ebp),%eax
    x86_page_table* l1pt = (x86_page_table*)L1_BASE_VADDR;
    l1pt->entry[(mnt >> 22)] = 0;
c010a655:	89 c2                	mov    %eax,%edx
c010a657:	c1 ea 16             	shr    $0x16,%edx
c010a65a:	c7 04 95 00 f0 ff ff 	movl   $0x0,-0x1000(,%edx,4)
c010a661:	00 00 00 00 
c010a665:	0f 01 38             	invlpg (%eax)
    cpu_invplg(mnt);
c010a668:	5d                   	pop    %ebp
c010a669:	c3                   	ret    

c010a66a <dmm_init>:
    return r;
}

int
dmm_init(heap_context_t* heap)
{
c010a66a:	55                   	push   %ebp
c010a66b:	89 e5                	mov    %esp,%ebp
c010a66d:	53                   	push   %ebx
c010a66e:	83 ec 04             	sub    $0x4,%esp
c010a671:	8b 5d 08             	mov    0x8(%ebp),%ebx
    assert((uintptr_t)heap->start % BOUNDARY == 0);
c010a674:	8b 03                	mov    (%ebx),%eax
c010a676:	a8 03                	test   $0x3,%al
c010a678:	75 4a                	jne    c010a6c4 <dmm_init+0x5a>

    heap->brk = heap->start;
c010a67a:	89 43 04             	mov    %eax,0x4(%ebx)
    mutex_init(&heap->lock);
c010a67d:	8d 43 0c             	lea    0xc(%ebx),%eax
    sem_init(mutex, 1);
c010a680:	83 ec 08             	sub    $0x8,%esp
c010a683:	6a 01                	push   $0x1
c010a685:	50                   	push   %eax
c010a686:	e8 f8 0f 00 00       	call   c010b683 <sem_init>

    int perm = PG_ALLOW_USER;
    if (heap->brk >= KHEAP_START) {
c010a68b:	8b 53 04             	mov    0x4(%ebx),%edx
c010a68e:	83 c4 10             	add    $0x10,%esp
c010a691:	81 fa ff ff 3f c0    	cmp    $0xc03fffff,%edx
c010a697:	77 3f                	ja     c010a6d8 <dmm_init+0x6e>
    int perm = PG_ALLOW_USER;
c010a699:	b8 04 00 00 00       	mov    $0x4,%eax
        perm = 0;
    }

    return vmm_set_mapping(
             PD_REFERENCED, heap->brk, 0, PG_WRITE | perm, VMAP_NULL) != NULL;
c010a69e:	83 c8 02             	or     $0x2,%eax
    return vmm_set_mapping(
c010a6a1:	83 ec 0c             	sub    $0xc,%esp
c010a6a4:	6a 00                	push   $0x0
c010a6a6:	50                   	push   %eax
c010a6a7:	6a 00                	push   $0x0
c010a6a9:	52                   	push   %edx
c010a6aa:	68 00 00 c0 ff       	push   $0xffc00000
c010a6af:	e8 8c fd ff ff       	call   c010a440 <vmm_set_mapping>
             PD_REFERENCED, heap->brk, 0, PG_WRITE | perm, VMAP_NULL) != NULL;
c010a6b4:	83 c4 20             	add    $0x20,%esp
c010a6b7:	85 c0                	test   %eax,%eax
c010a6b9:	0f 95 c0             	setne  %al
c010a6bc:	0f b6 c0             	movzbl %al,%eax
}
c010a6bf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c010a6c2:	c9                   	leave  
c010a6c3:	c3                   	ret    
    assert((uintptr_t)heap->start % BOUNDARY == 0);
c010a6c4:	83 ec 04             	sub    $0x4,%esp
c010a6c7:	6a 30                	push   $0x30
c010a6c9:	68 31 32 d1 c0       	push   $0xc0d13231
c010a6ce:	68 c8 35 d1 c0       	push   $0xc0d135c8
c010a6d3:	e8 8b 08 00 00       	call   c010af63 <__assert_fail>
        perm = 0;
c010a6d8:	b8 00 00 00 00       	mov    $0x0,%eax
c010a6dd:	eb bf                	jmp    c010a69e <dmm_init+0x34>

c010a6df <lxsbrk>:
    return -(lxsbrk(heap, addr - heap->brk, user) == (void*)-1);
}

void*
lxsbrk(heap_context_t* heap, size_t size, int user)
{
c010a6df:	55                   	push   %ebp
c010a6e0:	89 e5                	mov    %esp,%ebp
c010a6e2:	57                   	push   %edi
c010a6e3:	56                   	push   %esi
c010a6e4:	53                   	push   %ebx
c010a6e5:	83 ec 1c             	sub    $0x1c,%esp
    if (size == 0) {
c010a6e8:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c010a6ec:	74 39                	je     c010a727 <lxsbrk+0x48>
        return heap->brk;
    }

    void* current_brk = heap->brk;
c010a6ee:	8b 45 08             	mov    0x8(%ebp),%eax
c010a6f1:	8b 70 04             	mov    0x4(%eax),%esi

    // The upper bound of our next brk of heap given the size.
    // This will be used to calculate the page we need to allocate.
    void* next = current_brk + ROUNDUP(size, BOUNDARY);
c010a6f4:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a6f7:	83 c0 03             	add    $0x3,%eax
c010a6fa:	83 e0 fc             	and    $0xfffffffc,%eax
c010a6fd:	01 f0                	add    %esi,%eax

    // any invalid situations
    if (next >= heap->max_addr || next < current_brk) {
c010a6ff:	8b 55 08             	mov    0x8(%ebp),%edx
c010a702:	39 42 08             	cmp    %eax,0x8(%edx)
c010a705:	76 28                	jbe    c010a72f <lxsbrk+0x50>
c010a707:	39 c6                	cmp    %eax,%esi
c010a709:	77 24                	ja     c010a72f <lxsbrk+0x50>
        __current->k_status = LXINVLDPTR;
        return (void*)-1;
    }

    uintptr_t diff = PG_ALIGN(next) - PG_ALIGN(current_brk);
c010a70b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c010a710:	89 f7                	mov    %esi,%edi
c010a712:	81 e7 00 f0 ff ff    	and    $0xfffff000,%edi
    if (diff) {
c010a718:	29 f8                	sub    %edi,%eax
c010a71a:	75 63                	jne    c010a77f <lxsbrk+0xa0>
                            PG_WRITE | user,
                            VMAP_NULL);
        }
    }

    heap->brk += size;
c010a71c:	8b 45 08             	mov    0x8(%ebp),%eax
c010a71f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c010a722:	01 48 04             	add    %ecx,0x4(%eax)
    return current_brk;
c010a725:	eb 1c                	jmp    c010a743 <lxsbrk+0x64>
        return heap->brk;
c010a727:	8b 45 08             	mov    0x8(%ebp),%eax
c010a72a:	8b 70 04             	mov    0x4(%eax),%esi
c010a72d:	eb 14                	jmp    c010a743 <lxsbrk+0x64>
        __current->k_status = LXINVLDPTR;
c010a72f:	a1 8c 05 d1 c0       	mov    0xc0d1058c,%eax
c010a734:	c7 80 b4 00 00 00 fe 	movl   $0xfffffffe,0xb4(%eax)
c010a73b:	ff ff ff 
        return (void*)-1;
c010a73e:	be ff ff ff ff       	mov    $0xffffffff,%esi
c010a743:	89 f0                	mov    %esi,%eax
c010a745:	8d 65 f4             	lea    -0xc(%ebp),%esp
c010a748:	5b                   	pop    %ebx
c010a749:	5e                   	pop    %esi
c010a74a:	5f                   	pop    %edi
c010a74b:	5d                   	pop    %ebp
c010a74c:	c3                   	ret    
                            PG_WRITE | user,
c010a74d:	8b 45 10             	mov    0x10(%ebp),%eax
c010a750:	83 c8 02             	or     $0x2,%eax
            vmm_set_mapping(PD_REFERENCED,
c010a753:	83 ec 0c             	sub    $0xc,%esp
c010a756:	6a 00                	push   $0x0
c010a758:	50                   	push   %eax
c010a759:	6a 00                	push   $0x0
c010a75b:	8d 84 1f 00 10 00 00 	lea    0x1000(%edi,%ebx,1),%eax
c010a762:	50                   	push   %eax
c010a763:	68 00 00 c0 ff       	push   $0xffc00000
c010a768:	e8 d3 fc ff ff       	call   c010a440 <vmm_set_mapping>
        for (size_t i = 0; i < diff; i += PG_SIZE) {
c010a76d:	81 c3 00 10 00 00    	add    $0x1000,%ebx
c010a773:	83 c4 20             	add    $0x20,%esp
c010a776:	39 f3                	cmp    %esi,%ebx
c010a778:	72 d3                	jb     c010a74d <lxsbrk+0x6e>
c010a77a:	8b 75 e4             	mov    -0x1c(%ebp),%esi
c010a77d:	eb 9d                	jmp    c010a71c <lxsbrk+0x3d>
c010a77f:	bb 00 00 00 00       	mov    $0x0,%ebx
c010a784:	89 75 e4             	mov    %esi,-0x1c(%ebp)
c010a787:	89 c6                	mov    %eax,%esi
c010a789:	eb eb                	jmp    c010a776 <lxsbrk+0x97>

c010a78b <__lxsys_sbrk>:
{
c010a78b:	55                   	push   %ebp
c010a78c:	89 e5                	mov    %esp,%ebp
c010a78e:	56                   	push   %esi
c010a78f:	53                   	push   %ebx
    heap_context_t* uheap = &__current->mm.u_heap;
c010a790:	8b 1d 8c 05 d1 c0    	mov    0xc0d1058c,%ebx
c010a796:	8d b3 84 00 00 00    	lea    0x84(%ebx),%esi
    mutex_lock(&uheap->lock);
c010a79c:	81 c3 90 00 00 00    	add    $0x90,%ebx
    sem_wait(mutex);
c010a7a2:	83 ec 0c             	sub    $0xc,%esp
c010a7a5:	53                   	push   %ebx
c010a7a6:	e8 e5 0e 00 00       	call   c010b690 <sem_wait>
    void* r = lxsbrk(uheap, size, PG_ALLOW_USER);
c010a7ab:	83 c4 0c             	add    $0xc,%esp
c010a7ae:	6a 04                	push   $0x4
c010a7b0:	ff 75 08             	push   0x8(%ebp)
c010a7b3:	56                   	push   %esi
c010a7b4:	e8 26 ff ff ff       	call   c010a6df <lxsbrk>
c010a7b9:	89 c6                	mov    %eax,%esi
    sem_post(mutex);
c010a7bb:	89 1c 24             	mov    %ebx,(%esp)
c010a7be:	e8 df 0e 00 00       	call   c010b6a2 <sem_post>
}
c010a7c3:	89 f0                	mov    %esi,%eax
c010a7c5:	8d 65 f8             	lea    -0x8(%ebp),%esp
c010a7c8:	5b                   	pop    %ebx
c010a7c9:	5e                   	pop    %esi
c010a7ca:	5d                   	pop    %ebp
c010a7cb:	c3                   	ret    

c010a7cc <lxbrk>:
{
c010a7cc:	55                   	push   %ebp
c010a7cd:	89 e5                	mov    %esp,%ebp
c010a7cf:	83 ec 0c             	sub    $0xc,%esp
c010a7d2:	8b 55 08             	mov    0x8(%ebp),%edx
    return -(lxsbrk(heap, addr - heap->brk, user) == (void*)-1);
c010a7d5:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a7d8:	2b 42 04             	sub    0x4(%edx),%eax
c010a7db:	ff 75 10             	push   0x10(%ebp)
c010a7de:	50                   	push   %eax
c010a7df:	52                   	push   %edx
c010a7e0:	e8 fa fe ff ff       	call   c010a6df <lxsbrk>
c010a7e5:	83 c4 10             	add    $0x10,%esp
c010a7e8:	83 f8 ff             	cmp    $0xffffffff,%eax
c010a7eb:	0f 94 c0             	sete   %al
c010a7ee:	0f b6 c0             	movzbl %al,%eax
c010a7f1:	f7 d8                	neg    %eax
}
c010a7f3:	c9                   	leave  
c010a7f4:	c3                   	ret    

c010a7f5 <__lxsys_brk>:
{
c010a7f5:	55                   	push   %ebp
c010a7f6:	89 e5                	mov    %esp,%ebp
c010a7f8:	56                   	push   %esi
c010a7f9:	53                   	push   %ebx
    heap_context_t* uheap = &__current->mm.u_heap;
c010a7fa:	8b 1d 8c 05 d1 c0    	mov    0xc0d1058c,%ebx
c010a800:	8d b3 84 00 00 00    	lea    0x84(%ebx),%esi
    mutex_lock(&uheap->lock);
c010a806:	81 c3 90 00 00 00    	add    $0x90,%ebx
    sem_wait(mutex);
c010a80c:	83 ec 0c             	sub    $0xc,%esp
c010a80f:	53                   	push   %ebx
c010a810:	e8 7b 0e 00 00       	call   c010b690 <sem_wait>
    int r = lxbrk(uheap, addr, PG_ALLOW_USER);
c010a815:	83 c4 0c             	add    $0xc,%esp
c010a818:	6a 04                	push   $0x4
c010a81a:	ff 75 08             	push   0x8(%ebp)
c010a81d:	56                   	push   %esi
c010a81e:	e8 a9 ff ff ff       	call   c010a7cc <lxbrk>
c010a823:	89 c6                	mov    %eax,%esi
    sem_post(mutex);
c010a825:	89 1c 24             	mov    %ebx,(%esp)
c010a828:	e8 75 0e 00 00       	call   c010b6a2 <sem_post>
}
c010a82d:	89 f0                	mov    %esi,%eax
c010a82f:	8d 65 f8             	lea    -0x8(%ebp),%esp
c010a832:	5b                   	pop    %ebx
c010a833:	5e                   	pop    %esi
c010a834:	5d                   	pop    %ebp
c010a835:	c3                   	ret    

c010a836 <region_add>:
void
region_add(struct mm_region* regions,
           unsigned long start,
           unsigned long end,
           unsigned int attr)
{
c010a836:	55                   	push   %ebp
c010a837:	89 e5                	mov    %esp,%ebp
c010a839:	53                   	push   %ebx
c010a83a:	83 ec 10             	sub    $0x10,%esp
c010a83d:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct mm_region* region = lxmalloc(sizeof(struct mm_region));
c010a840:	6a 14                	push   $0x14
c010a842:	e8 b4 fa ff ff       	call   c010a2fb <lxmalloc>

    *region = (struct mm_region){ .attr = attr, .end = end, .start = start };
c010a847:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
c010a84d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
c010a854:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
c010a85b:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
c010a862:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
c010a869:	8b 55 0c             	mov    0xc(%ebp),%edx
c010a86c:	89 50 08             	mov    %edx,0x8(%eax)
c010a86f:	8b 55 10             	mov    0x10(%ebp),%edx
c010a872:	89 50 0c             	mov    %edx,0xc(%eax)
c010a875:	8b 55 14             	mov    0x14(%ebp),%edx
c010a878:	89 50 10             	mov    %edx,0x10(%eax)
}

static inline void
llist_append(struct llist_header* head, struct llist_header* elem)
{
    __llist_add(elem, head, head->next);
c010a87b:	8b 53 04             	mov    0x4(%ebx),%edx
    next->prev = elem;
c010a87e:	89 02                	mov    %eax,(%edx)
    elem->next = next;
c010a880:	89 50 04             	mov    %edx,0x4(%eax)
    elem->prev = prev;
c010a883:	89 18                	mov    %ebx,(%eax)
    prev->next = elem;
c010a885:	89 43 04             	mov    %eax,0x4(%ebx)

    llist_append(&regions->head, &region->head);
}
c010a888:	83 c4 10             	add    $0x10,%esp
c010a88b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c010a88e:	c9                   	leave  
c010a88f:	c3                   	ret    

c010a890 <region_release_all>:

void
region_release_all(struct mm_region* regions)
{
c010a890:	55                   	push   %ebp
c010a891:	89 e5                	mov    %esp,%ebp
c010a893:	56                   	push   %esi
c010a894:	53                   	push   %ebx
c010a895:	8b 75 08             	mov    0x8(%ebp),%esi
    struct mm_region *pos, *n;

    llist_for_each(pos, n, &regions->head, head)
c010a898:	8b 46 04             	mov    0x4(%esi),%eax
c010a89b:	8b 58 04             	mov    0x4(%eax),%ebx
c010a89e:	eb 11                	jmp    c010a8b1 <region_release_all+0x21>
    {
        lxfree(pos);
c010a8a0:	83 ec 0c             	sub    $0xc,%esp
c010a8a3:	50                   	push   %eax
c010a8a4:	e8 e4 f7 ff ff       	call   c010a08d <lxfree>
    llist_for_each(pos, n, &regions->head, head)
c010a8a9:	83 c4 10             	add    $0x10,%esp
c010a8ac:	89 d8                	mov    %ebx,%eax
c010a8ae:	8b 5b 04             	mov    0x4(%ebx),%ebx
c010a8b1:	39 f0                	cmp    %esi,%eax
c010a8b3:	75 eb                	jne    c010a8a0 <region_release_all+0x10>
    }
}
c010a8b5:	8d 65 f8             	lea    -0x8(%ebp),%esp
c010a8b8:	5b                   	pop    %ebx
c010a8b9:	5e                   	pop    %esi
c010a8ba:	5d                   	pop    %ebp
c010a8bb:	c3                   	ret    

c010a8bc <region_copy>:

void
region_copy(struct mm_region* src, struct mm_region* dest)
{
c010a8bc:	55                   	push   %ebp
c010a8bd:	89 e5                	mov    %esp,%ebp
c010a8bf:	57                   	push   %edi
c010a8c0:	56                   	push   %esi
c010a8c1:	53                   	push   %ebx
c010a8c2:	83 ec 0c             	sub    $0xc,%esp
c010a8c5:	8b 75 08             	mov    0x8(%ebp),%esi
c010a8c8:	8b 7d 0c             	mov    0xc(%ebp),%edi
    if (!src) {
c010a8cb:	85 f6                	test   %esi,%esi
c010a8cd:	74 23                	je     c010a8f2 <region_copy+0x36>
        return;
    }

    struct mm_region *pos, *n;

    llist_for_each(pos, n, &src->head, head)
c010a8cf:	8b 46 04             	mov    0x4(%esi),%eax
c010a8d2:	8b 58 04             	mov    0x4(%eax),%ebx
c010a8d5:	eb 17                	jmp    c010a8ee <region_copy+0x32>
    {
        region_add(dest, pos->start, pos->end, pos->attr);
c010a8d7:	ff 70 10             	push   0x10(%eax)
c010a8da:	ff 70 0c             	push   0xc(%eax)
c010a8dd:	ff 70 08             	push   0x8(%eax)
c010a8e0:	57                   	push   %edi
c010a8e1:	e8 50 ff ff ff       	call   c010a836 <region_add>
    llist_for_each(pos, n, &src->head, head)
c010a8e6:	83 c4 10             	add    $0x10,%esp
c010a8e9:	89 d8                	mov    %ebx,%eax
c010a8eb:	8b 5b 04             	mov    0x4(%ebx),%ebx
c010a8ee:	39 f0                	cmp    %esi,%eax
c010a8f0:	75 e5                	jne    c010a8d7 <region_copy+0x1b>
    }
}
c010a8f2:	8d 65 f4             	lea    -0xc(%ebp),%esp
c010a8f5:	5b                   	pop    %ebx
c010a8f6:	5e                   	pop    %esi
c010a8f7:	5f                   	pop    %edi
c010a8f8:	5d                   	pop    %ebp
c010a8f9:	c3                   	ret    

c010a8fa <region_get>:

struct mm_region*
region_get(struct mm_region* regions, unsigned long vaddr)
{
c010a8fa:	55                   	push   %ebp
c010a8fb:	89 e5                	mov    %esp,%ebp
c010a8fd:	53                   	push   %ebx
c010a8fe:	8b 5d 08             	mov    0x8(%ebp),%ebx
c010a901:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    if (!regions) {
c010a904:	85 db                	test   %ebx,%ebx
c010a906:	74 27                	je     c010a92f <region_get+0x35>
        return NULL;
    }

    struct mm_region *pos, *n;

    llist_for_each(pos, n, &regions->head, head)
c010a908:	8b 43 04             	mov    0x4(%ebx),%eax
c010a90b:	8b 50 04             	mov    0x4(%eax),%edx
c010a90e:	eb 05                	jmp    c010a915 <region_get+0x1b>
c010a910:	89 d0                	mov    %edx,%eax
c010a912:	8b 52 04             	mov    0x4(%edx),%edx
c010a915:	39 d8                	cmp    %ebx,%eax
c010a917:	74 0c                	je     c010a925 <region_get+0x2b>
    {
        if (pos->start <= vaddr && vaddr < pos->end) {
c010a919:	39 48 08             	cmp    %ecx,0x8(%eax)
c010a91c:	77 f2                	ja     c010a910 <region_get+0x16>
c010a91e:	39 48 0c             	cmp    %ecx,0xc(%eax)
c010a921:	76 ed                	jbe    c010a910 <region_get+0x16>
c010a923:	eb 05                	jmp    c010a92a <region_get+0x30>
            return pos;
        }
    }
    return NULL;
c010a925:	b8 00 00 00 00       	mov    $0x0,%eax
}
c010a92a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c010a92d:	c9                   	leave  
c010a92e:	c3                   	ret    
        return NULL;
c010a92f:	89 d8                	mov    %ebx,%eax
c010a931:	eb f7                	jmp    c010a92a <region_get+0x30>

c010a933 <pmm_mark_page_free>:

static uintptr_t max_pg;

void
pmm_mark_page_free(uintptr_t ppn)
{
c010a933:	55                   	push   %ebp
c010a934:	89 e5                	mov    %esp,%ebp
c010a936:	8b 45 08             	mov    0x8(%ebp),%eax
    pm_table[ppn].ref_counts = 0;
c010a939:	8d 14 40             	lea    (%eax,%eax,2),%edx
c010a93c:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
c010a943:	c7 80 44 00 11 c0 00 	movl   $0x0,-0x3feeffbc(%eax)
c010a94a:	00 00 00 
}
c010a94d:	5d                   	pop    %ebp
c010a94e:	c3                   	ret    

c010a94f <pmm_mark_page_occupied>:

void
pmm_mark_page_occupied(pid_t owner, uintptr_t ppn, pp_attr_t attr)
{
c010a94f:	55                   	push   %ebp
c010a950:	89 e5                	mov    %esp,%ebp
c010a952:	53                   	push   %ebx
c010a953:	8b 55 0c             	mov    0xc(%ebp),%edx
    pm_table[ppn] =
c010a956:	8d 04 12             	lea    (%edx,%edx,1),%eax
c010a959:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
c010a95c:	8d 0c 9d 00 00 00 00 	lea    0x0(,%ebx,4),%ecx
c010a963:	8b 5d 08             	mov    0x8(%ebp),%ebx
c010a966:	89 99 40 00 11 c0    	mov    %ebx,-0x3feeffc0(%ecx)
c010a96c:	c7 81 44 00 11 c0 01 	movl   $0x1,-0x3feeffbc(%ecx)
c010a973:	00 00 00 
c010a976:	8b 45 10             	mov    0x10(%ebp),%eax
c010a979:	89 81 48 00 11 c0    	mov    %eax,-0x3feeffb8(%ecx)
      (struct pp_struct){ .owner = owner, .ref_counts = 1, .attr = attr };
}
c010a97f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c010a982:	c9                   	leave  
c010a983:	c3                   	ret    

c010a984 <pmm_mark_chunk_free>:

void
pmm_mark_chunk_free(uintptr_t start_ppn, size_t page_count)
{
c010a984:	55                   	push   %ebp
c010a985:	89 e5                	mov    %esp,%ebp
c010a987:	56                   	push   %esi
c010a988:	53                   	push   %ebx
c010a989:	8b 5d 08             	mov    0x8(%ebp),%ebx
c010a98c:	8b 75 0c             	mov    0xc(%ebp),%esi
    for (size_t i = start_ppn; i < start_ppn + page_count && i < max_pg; i++) {
c010a98f:	89 d8                	mov    %ebx,%eax
c010a991:	eb 17                	jmp    c010a9aa <pmm_mark_chunk_free+0x26>
        pm_table[i].ref_counts = 0;
c010a993:	8d 0c 40             	lea    (%eax,%eax,2),%ecx
c010a996:	8d 14 8d 00 00 00 00 	lea    0x0(,%ecx,4),%edx
c010a99d:	c7 82 44 00 11 c0 00 	movl   $0x0,-0x3feeffbc(%edx)
c010a9a4:	00 00 00 
    for (size_t i = start_ppn; i < start_ppn + page_count && i < max_pg; i++) {
c010a9a7:	83 c0 01             	add    $0x1,%eax
c010a9aa:	8d 14 33             	lea    (%ebx,%esi,1),%edx
c010a9ad:	39 c2                	cmp    %eax,%edx
c010a9af:	76 08                	jbe    c010a9b9 <pmm_mark_chunk_free+0x35>
c010a9b1:	39 05 24 00 11 c0    	cmp    %eax,0xc0110024
c010a9b7:	77 da                	ja     c010a993 <pmm_mark_chunk_free+0xf>
    }
}
c010a9b9:	5b                   	pop    %ebx
c010a9ba:	5e                   	pop    %esi
c010a9bb:	5d                   	pop    %ebp
c010a9bc:	c3                   	ret    

c010a9bd <pmm_mark_chunk_occupied>:
void
pmm_mark_chunk_occupied(pid_t owner,
                        uint32_t start_ppn,
                        size_t page_count,
                        pp_attr_t attr)
{
c010a9bd:	55                   	push   %ebp
c010a9be:	89 e5                	mov    %esp,%ebp
c010a9c0:	57                   	push   %edi
c010a9c1:	56                   	push   %esi
c010a9c2:	53                   	push   %ebx
c010a9c3:	8b 7d 08             	mov    0x8(%ebp),%edi
c010a9c6:	8b 5d 0c             	mov    0xc(%ebp),%ebx
c010a9c9:	8b 75 14             	mov    0x14(%ebp),%esi
    for (size_t i = start_ppn; i < start_ppn + page_count && i < max_pg; i++) {
c010a9cc:	89 d8                	mov    %ebx,%eax
c010a9ce:	eb 25                	jmp    c010a9f5 <pmm_mark_chunk_occupied+0x38>
        pm_table[i] =
c010a9d0:	8d 14 00             	lea    (%eax,%eax,1),%edx
c010a9d3:	01 c2                	add    %eax,%edx
c010a9d5:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
c010a9dc:	89 b9 40 00 11 c0    	mov    %edi,-0x3feeffc0(%ecx)
c010a9e2:	c7 81 44 00 11 c0 01 	movl   $0x1,-0x3feeffbc(%ecx)
c010a9e9:	00 00 00 
c010a9ec:	89 b1 48 00 11 c0    	mov    %esi,-0x3feeffb8(%ecx)
    for (size_t i = start_ppn; i < start_ppn + page_count && i < max_pg; i++) {
c010a9f2:	83 c0 01             	add    $0x1,%eax
c010a9f5:	89 da                	mov    %ebx,%edx
c010a9f7:	03 55 10             	add    0x10(%ebp),%edx
c010a9fa:	39 c2                	cmp    %eax,%edx
c010a9fc:	76 08                	jbe    c010aa06 <pmm_mark_chunk_occupied+0x49>
c010a9fe:	39 05 24 00 11 c0    	cmp    %eax,0xc0110024
c010aa04:	77 ca                	ja     c010a9d0 <pmm_mark_chunk_occupied+0x13>
          (struct pp_struct){ .owner = owner, .ref_counts = 1, .attr = attr };
    }
}
c010aa06:	5b                   	pop    %ebx
c010aa07:	5e                   	pop    %esi
c010aa08:	5f                   	pop    %edi
c010aa09:	5d                   	pop    %ebp
c010aa0a:	c3                   	ret    

c010aa0b <pmm_init>:

size_t pg_lookup_ptr;

void
pmm_init(uintptr_t mem_upper_lim)
{
c010aa0b:	55                   	push   %ebp
c010aa0c:	89 e5                	mov    %esp,%ebp
    max_pg = (PG_ALIGN(mem_upper_lim) >> 12);
c010aa0e:	8b 45 08             	mov    0x8(%ebp),%eax
c010aa11:	c1 e8 0c             	shr    $0xc,%eax
c010aa14:	a3 24 00 11 c0       	mov    %eax,0xc0110024

    pg_lookup_ptr = LOOKUP_START;
c010aa19:	c7 05 20 00 11 c0 01 	movl   $0x1,0xc0110020
c010aa20:	00 00 00 

    // mark all as occupied
    for (size_t i = 0; i < PM_BMP_MAX_SIZE; i++) {
c010aa23:	b8 00 00 00 00       	mov    $0x0,%eax
c010aa28:	eb 2d                	jmp    c010aa57 <pmm_init+0x4c>
        pm_table[i] =
c010aa2a:	8d 14 00             	lea    (%eax,%eax,1),%edx
c010aa2d:	01 c2                	add    %eax,%edx
c010aa2f:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
c010aa36:	c7 81 40 00 11 c0 00 	movl   $0x0,-0x3feeffc0(%ecx)
c010aa3d:	00 00 00 
c010aa40:	c7 81 44 00 11 c0 01 	movl   $0x1,-0x3feeffbc(%ecx)
c010aa47:	00 00 00 
c010aa4a:	c7 81 48 00 11 c0 00 	movl   $0x0,-0x3feeffb8(%ecx)
c010aa51:	00 00 00 
    for (size_t i = 0; i < PM_BMP_MAX_SIZE; i++) {
c010aa54:	83 c0 01             	add    $0x1,%eax
c010aa57:	3d ff ff 0f 00       	cmp    $0xfffff,%eax
c010aa5c:	76 cc                	jbe    c010aa2a <pmm_init+0x1f>
          (struct pp_struct){ .owner = 0, .attr = 0, .ref_counts = 1 };
    }
}
c010aa5e:	5d                   	pop    %ebp
c010aa5f:	c3                   	ret    

c010aa60 <pmm_alloc_cpage>:

void*
pmm_alloc_cpage(pid_t owner, size_t num_pages, pp_attr_t attr)
{
c010aa60:	55                   	push   %ebp
c010aa61:	89 e5                	mov    %esp,%ebp
c010aa63:	56                   	push   %esi
c010aa64:	53                   	push   %ebx
c010aa65:	8b 75 0c             	mov    0xc(%ebp),%esi
    size_t p1 = 0;
    size_t p2 = 0;
c010aa68:	b8 00 00 00 00       	mov    $0x0,%eax
    size_t p1 = 0;
c010aa6d:	bb 00 00 00 00       	mov    $0x0,%ebx

    while (p2 < max_pg && p2 - p1 < num_pages) {
c010aa72:	8b 15 24 00 11 c0    	mov    0xc0110024,%edx
c010aa78:	39 c2                	cmp    %eax,%edx
c010aa7a:	76 24                	jbe    c010aaa0 <pmm_alloc_cpage+0x40>
c010aa7c:	89 c1                	mov    %eax,%ecx
c010aa7e:	29 d9                	sub    %ebx,%ecx
c010aa80:	39 f1                	cmp    %esi,%ecx
c010aa82:	73 1c                	jae    c010aaa0 <pmm_alloc_cpage+0x40>
        (!(&pm_table[p2])->ref_counts) ? (p2++) : (p1 = p2);
c010aa84:	8d 0c 40             	lea    (%eax,%eax,2),%ecx
c010aa87:	8d 14 8d 00 00 00 00 	lea    0x0(,%ecx,4),%edx
c010aa8e:	83 ba 44 00 11 c0 00 	cmpl   $0x0,-0x3feeffbc(%edx)
c010aa95:	74 04                	je     c010aa9b <pmm_alloc_cpage+0x3b>
c010aa97:	89 c3                	mov    %eax,%ebx
c010aa99:	eb d7                	jmp    c010aa72 <pmm_alloc_cpage+0x12>
c010aa9b:	83 c0 01             	add    $0x1,%eax
c010aa9e:	eb d2                	jmp    c010aa72 <pmm_alloc_cpage+0x12>
    }

    if (p2 < max_pg) {
c010aaa0:	39 c2                	cmp    %eax,%edx
c010aaa2:	77 1c                	ja     c010aac0 <pmm_alloc_cpage+0x60>
        return NULL;
    }

    pmm_mark_chunk_occupied(owner, p1, num_pages, attr);
c010aaa4:	ff 75 10             	push   0x10(%ebp)
c010aaa7:	56                   	push   %esi
c010aaa8:	53                   	push   %ebx
c010aaa9:	ff 75 08             	push   0x8(%ebp)
c010aaac:	e8 0c ff ff ff       	call   c010a9bd <pmm_mark_chunk_occupied>

    return p1 << 12;
c010aab1:	89 d8                	mov    %ebx,%eax
c010aab3:	c1 e0 0c             	shl    $0xc,%eax
c010aab6:	83 c4 10             	add    $0x10,%esp
}
c010aab9:	8d 65 f8             	lea    -0x8(%ebp),%esp
c010aabc:	5b                   	pop    %ebx
c010aabd:	5e                   	pop    %esi
c010aabe:	5d                   	pop    %ebp
c010aabf:	c3                   	ret    
        return NULL;
c010aac0:	b8 00 00 00 00       	mov    $0x0,%eax
c010aac5:	eb f2                	jmp    c010aab9 <pmm_alloc_cpage+0x59>

c010aac7 <pmm_alloc_page>:

void*
pmm_alloc_page(pid_t owner, pp_attr_t attr)
{
c010aac7:	55                   	push   %ebp
c010aac8:	89 e5                	mov    %esp,%ebp
c010aaca:	56                   	push   %esi
c010aacb:	53                   	push   %ebx
    // Next fit approach. Maximize the throughput!
    uintptr_t good_page_found = (uintptr_t)NULL;
    size_t old_pg_ptr = pg_lookup_ptr;
c010aacc:	8b 35 20 00 11 c0    	mov    0xc0110020,%esi
    size_t upper_lim = max_pg;
c010aad2:	8b 1d 24 00 11 c0    	mov    0xc0110024,%ebx
    struct pp_struct* pm;
    while (!good_page_found && pg_lookup_ptr < upper_lim) {
c010aad8:	a1 20 00 11 c0       	mov    0xc0110020,%eax
c010aadd:	39 d8                	cmp    %ebx,%eax
c010aadf:	73 62                	jae    c010ab43 <pmm_alloc_page+0x7c>
        pm = &pm_table[pg_lookup_ptr];

        if (!pm->ref_counts) {
c010aae1:	8d 0c 40             	lea    (%eax,%eax,2),%ecx
c010aae4:	8d 14 8d 00 00 00 00 	lea    0x0(,%ecx,4),%edx
c010aaeb:	83 ba 44 00 11 c0 00 	cmpl   $0x0,-0x3feeffbc(%edx)
c010aaf2:	74 24                	je     c010ab18 <pmm_alloc_page+0x51>
                                      .owner = owner,
                                      .ref_counts = 1 };
            good_page_found = pg_lookup_ptr << 12;
            break;
        } else {
            pg_lookup_ptr++;
c010aaf4:	83 c0 01             	add    $0x1,%eax
c010aaf7:	a3 20 00 11 c0       	mov    %eax,0xc0110020

            // We've searched the interval [old_pg_ptr, max_pg) but failed
            //   may be chances in [1, old_pg_ptr) ?
            // Let's find out!
            if (pg_lookup_ptr >= upper_lim && old_pg_ptr != LOOKUP_START) {
c010aafc:	39 d8                	cmp    %ebx,%eax
c010aafe:	72 d8                	jb     c010aad8 <pmm_alloc_page+0x11>
c010ab00:	83 fe 01             	cmp    $0x1,%esi
c010ab03:	74 d3                	je     c010aad8 <pmm_alloc_page+0x11>
                upper_lim = old_pg_ptr;
                pg_lookup_ptr = LOOKUP_START;
c010ab05:	c7 05 20 00 11 c0 01 	movl   $0x1,0xc0110020
c010ab0c:	00 00 00 
                upper_lim = old_pg_ptr;
c010ab0f:	89 f3                	mov    %esi,%ebx
                old_pg_ptr = LOOKUP_START;
c010ab11:	be 01 00 00 00       	mov    $0x1,%esi
c010ab16:	eb c0                	jmp    c010aad8 <pmm_alloc_page+0x11>
            *pm = (struct pp_struct){ .attr = attr,
c010ab18:	8d 0c 8d 00 00 00 00 	lea    0x0(,%ecx,4),%ecx
c010ab1f:	8d 91 40 00 11 c0    	lea    -0x3feeffc0(%ecx),%edx
c010ab25:	8b 5d 08             	mov    0x8(%ebp),%ebx
c010ab28:	89 99 40 00 11 c0    	mov    %ebx,-0x3feeffc0(%ecx)
c010ab2e:	c7 81 44 00 11 c0 01 	movl   $0x1,-0x3feeffbc(%ecx)
c010ab35:	00 00 00 
c010ab38:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c010ab3b:	89 4a 08             	mov    %ecx,0x8(%edx)
            good_page_found = pg_lookup_ptr << 12;
c010ab3e:	c1 e0 0c             	shl    $0xc,%eax
            break;
c010ab41:	eb 05                	jmp    c010ab48 <pmm_alloc_page+0x81>
    uintptr_t good_page_found = (uintptr_t)NULL;
c010ab43:	b8 00 00 00 00       	mov    $0x0,%eax
            }
        }
    }
    if (!good_page_found) {
c010ab48:	85 c0                	test   %eax,%eax
c010ab4a:	75 10                	jne    c010ab5c <pmm_alloc_page+0x95>
        __current->k_status = LXOUTOFMEM;
c010ab4c:	8b 15 8c 05 d1 c0    	mov    0xc0d1058c,%edx
c010ab52:	c7 82 b4 00 00 00 fd 	movl   $0xfffffffd,0xb4(%edx)
c010ab59:	ff ff ff 
    }
    return (void*)good_page_found;
}
c010ab5c:	5b                   	pop    %ebx
c010ab5d:	5e                   	pop    %esi
c010ab5e:	5d                   	pop    %ebp
c010ab5f:	c3                   	ret    

c010ab60 <pmm_free_page>:

int
pmm_free_page(pid_t owner, void* page)
{
c010ab60:	55                   	push   %ebp
c010ab61:	89 e5                	mov    %esp,%ebp
c010ab63:	53                   	push   %ebx
    struct pp_struct* pm = &pm_table[(intptr_t)page >> 12];
c010ab64:	8b 45 0c             	mov    0xc(%ebp),%eax
c010ab67:	c1 f8 0c             	sar    $0xc,%eax

    // Is this a MMIO mapping or double free?
    if (((intptr_t)page >> 12) >= max_pg || !(pm->ref_counts)) {
c010ab6a:	3b 05 24 00 11 c0    	cmp    0xc0110024,%eax
c010ab70:	73 3d                	jae    c010abaf <pmm_free_page+0x4f>
c010ab72:	8d 0c 40             	lea    (%eax,%eax,2),%ecx
c010ab75:	8d 14 8d 00 00 00 00 	lea    0x0(,%ecx,4),%edx
c010ab7c:	8b 92 44 00 11 c0    	mov    -0x3feeffbc(%edx),%edx
c010ab82:	85 d2                	test   %edx,%edx
c010ab84:	74 33                	je     c010abb9 <pmm_free_page+0x59>
        return 0;
    }

    // 如果是锁定页，则不作处理
    if ((pm->attr & PP_FGLOCKED)) {
c010ab86:	89 cb                	mov    %ecx,%ebx
c010ab88:	8d 0c 8d 00 00 00 00 	lea    0x0(,%ecx,4),%ecx
c010ab8f:	f6 81 48 00 11 c0 02 	testb  $0x2,-0x3feeffb8(%ecx)
c010ab96:	75 28                	jne    c010abc0 <pmm_free_page+0x60>
        return 0;
    }

    // TODO: 检查权限，保证：1) 只有正在使用该页（包括被分享者）的进程可以释放；
    // 2) 内核可释放所有页。
    pm->ref_counts--;
c010ab98:	8d 04 9d 00 00 00 00 	lea    0x0(,%ebx,4),%eax
c010ab9f:	83 ea 01             	sub    $0x1,%edx
c010aba2:	89 90 44 00 11 c0    	mov    %edx,-0x3feeffbc(%eax)
    return 1;
c010aba8:	b8 01 00 00 00       	mov    $0x1,%eax
c010abad:	eb 05                	jmp    c010abb4 <pmm_free_page+0x54>
        return 0;
c010abaf:	b8 00 00 00 00       	mov    $0x0,%eax
}
c010abb4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c010abb7:	c9                   	leave  
c010abb8:	c3                   	ret    
        return 0;
c010abb9:	b8 00 00 00 00       	mov    $0x0,%eax
c010abbe:	eb f4                	jmp    c010abb4 <pmm_free_page+0x54>
        return 0;
c010abc0:	b8 00 00 00 00       	mov    $0x0,%eax
c010abc5:	eb ed                	jmp    c010abb4 <pmm_free_page+0x54>

c010abc7 <pmm_ref_page>:

int
pmm_ref_page(pid_t owner, void* page)
{
c010abc7:	55                   	push   %ebp
c010abc8:	89 e5                	mov    %esp,%ebp
    (void*)owner; // TODO: do smth with owner

    uint32_t ppn = (uintptr_t)page >> 12;
c010abca:	8b 45 0c             	mov    0xc(%ebp),%eax
c010abcd:	c1 e8 0c             	shr    $0xc,%eax
    if (ppn >= PM_BMP_MAX_SIZE) {
        return 0;
    }

    struct pp_struct* pm = &pm_table[ppn];
    if (ppn >= max_pg || !pm->ref_counts) {
c010abd0:	39 05 24 00 11 c0    	cmp    %eax,0xc0110024
c010abd6:	76 2b                	jbe    c010ac03 <pmm_ref_page+0x3c>
c010abd8:	8d 0c 40             	lea    (%eax,%eax,2),%ecx
c010abdb:	8d 14 8d 00 00 00 00 	lea    0x0(,%ecx,4),%edx
c010abe2:	8b 92 44 00 11 c0    	mov    -0x3feeffbc(%edx),%edx
c010abe8:	85 d2                	test   %edx,%edx
c010abea:	74 1e                	je     c010ac0a <pmm_ref_page+0x43>
        return 0;
    }

    pm->ref_counts++;
c010abec:	8d 04 8d 00 00 00 00 	lea    0x0(,%ecx,4),%eax
c010abf3:	83 c2 01             	add    $0x1,%edx
c010abf6:	89 90 44 00 11 c0    	mov    %edx,-0x3feeffbc(%eax)
    return 1;
c010abfc:	b8 01 00 00 00       	mov    $0x1,%eax
}
c010ac01:	5d                   	pop    %ebp
c010ac02:	c3                   	ret    
        return 0;
c010ac03:	b8 00 00 00 00       	mov    $0x0,%eax
c010ac08:	eb f7                	jmp    c010ac01 <pmm_ref_page+0x3a>
c010ac0a:	b8 00 00 00 00       	mov    $0x0,%eax
c010ac0f:	eb f0                	jmp    c010ac01 <pmm_ref_page+0x3a>

c010ac11 <pmm_query>:

struct pp_struct*
pmm_query(void* pa)
{
c010ac11:	55                   	push   %ebp
c010ac12:	89 e5                	mov    %esp,%ebp
    uint32_t ppn = (uintptr_t)pa >> 12;
c010ac14:	8b 45 08             	mov    0x8(%ebp),%eax
c010ac17:	c1 e8 0c             	shr    $0xc,%eax

    if (ppn >= PM_BMP_MAX_SIZE) {
        return NULL;
    }

    return &pm_table[ppn];
c010ac1a:	8d 14 40             	lea    (%eax,%eax,2),%edx
c010ac1d:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
c010ac24:	05 40 00 11 c0       	add    $0xc0110040,%eax
c010ac29:	5d                   	pop    %ebp
c010ac2a:	c3                   	ret    

c010ac2b <tty_init>:
                 "a"(tty_theme_color)                                          \
                 : "memory");

void
tty_init(void* vga_buf)
{
c010ac2b:	55                   	push   %ebp
c010ac2c:	89 e5                	mov    %esp,%ebp
c010ac2e:	57                   	push   %edi
c010ac2f:	53                   	push   %ebx
c010ac30:	8b 7d 08             	mov    0x8(%ebp),%edi
    tty_vga_buffer = (vga_attribute*)vga_buf;
c010ac33:	89 3d 00 20 d1 c0    	mov    %edi,0xc0d12000

    TTY_CLEAR
c010ac39:	b9 d0 07 00 00       	mov    $0x7d0,%ecx
c010ac3e:	0f b7 05 40 00 d1 c0 	movzwl 0xc0d10040,%eax
c010ac45:	66 f3 ab             	rep stos %ax,%es:(%edi)
}

static inline void
io_outb(int port, uint8_t data)
{
    asm volatile("outb %0, %w1" : : "a"(data), "d"(port));
c010ac48:	bb d4 03 00 00       	mov    $0x3d4,%ebx
c010ac4d:	b8 0a 00 00 00       	mov    $0xa,%eax
c010ac52:	89 da                	mov    %ebx,%edx
c010ac54:	ee                   	out    %al,(%dx)
    asm volatile("inb %w1,%0" : "=a"(data) : "d"(port));
c010ac55:	b9 d5 03 00 00       	mov    $0x3d5,%ecx
c010ac5a:	89 ca                	mov    %ecx,%edx
c010ac5c:	ec                   	in     (%dx),%al

    io_outb(0x3D4, 0x0A);
    io_outb(0x3D5, (io_inb(0x3D5) & 0xC0) | 13);
c010ac5d:	83 e0 c0             	and    $0xffffffc0,%eax
c010ac60:	83 c8 0d             	or     $0xd,%eax
    asm volatile("outb %0, %w1" : : "a"(data), "d"(port));
c010ac63:	ee                   	out    %al,(%dx)
c010ac64:	b8 0b 00 00 00       	mov    $0xb,%eax
c010ac69:	89 da                	mov    %ebx,%edx
c010ac6b:	ee                   	out    %al,(%dx)
    asm volatile("inb %w1,%0" : "=a"(data) : "d"(port));
c010ac6c:	89 ca                	mov    %ecx,%edx
c010ac6e:	ec                   	in     (%dx),%al

    io_outb(0x3D4, 0x0B);
    io_outb(0x3D5, (io_inb(0x3D5) & 0xE0) | 15);
c010ac6f:	83 e0 e0             	and    $0xffffffe0,%eax
c010ac72:	83 c8 0f             	or     $0xf,%eax
    asm volatile("outb %0, %w1" : : "a"(data), "d"(port));
c010ac75:	ee                   	out    %al,(%dx)
}
c010ac76:	5b                   	pop    %ebx
c010ac77:	5f                   	pop    %edi
c010ac78:	5d                   	pop    %ebp
c010ac79:	c3                   	ret    

c010ac7a <tty_set_theme>:

void
tty_set_theme(vga_attribute fg, vga_attribute bg)
{
c010ac7a:	55                   	push   %ebp
c010ac7b:	89 e5                	mov    %esp,%ebp
    tty_theme_color = (bg << 4 | fg) << 8;
c010ac7d:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
c010ac81:	c1 e0 04             	shl    $0x4,%eax
c010ac84:	66 0b 45 08          	or     0x8(%ebp),%ax
c010ac88:	c1 e0 08             	shl    $0x8,%eax
c010ac8b:	66 a3 40 00 d1 c0    	mov    %ax,0xc0d10040
}
c010ac91:	5d                   	pop    %ebp
c010ac92:	c3                   	ret    

c010ac93 <tty_set_cursor>:
    return pos;
}

void
tty_set_cursor(uint8_t x, uint8_t y)
{
c010ac93:	55                   	push   %ebp
c010ac94:	89 e5                	mov    %esp,%ebp
c010ac96:	56                   	push   %esi
c010ac97:	53                   	push   %ebx
c010ac98:	8b 55 08             	mov    0x8(%ebp),%edx
c010ac9b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
c010ac9e:	89 d1                	mov    %edx,%ecx
c010aca0:	89 d8                	mov    %ebx,%eax
    if (x >= TTY_WIDTH || y >= TTY_HEIGHT) {
c010aca2:	80 fa 4f             	cmp    $0x4f,%dl
c010aca5:	0f 97 c2             	seta   %dl
c010aca8:	80 fb 18             	cmp    $0x18,%bl
c010acab:	0f 97 c3             	seta   %bl
c010acae:	08 da                	or     %bl,%dl
c010acb0:	74 0a                	je     c010acbc <tty_set_cursor+0x29>
        x = y = 0;
c010acb2:	b8 00 00 00 00       	mov    $0x0,%eax
c010acb7:	b9 00 00 00 00       	mov    $0x0,%ecx
    }
    uint32_t pos = y * TTY_WIDTH + x;
c010acbc:	0f b6 c0             	movzbl %al,%eax
c010acbf:	8d 14 80             	lea    (%eax,%eax,4),%edx
c010acc2:	89 d0                	mov    %edx,%eax
c010acc4:	c1 e0 04             	shl    $0x4,%eax
c010acc7:	0f b6 c9             	movzbl %cl,%ecx
c010acca:	01 c1                	add    %eax,%ecx
c010accc:	be d4 03 00 00       	mov    $0x3d4,%esi
c010acd1:	b8 0e 00 00 00       	mov    $0xe,%eax
c010acd6:	89 f2                	mov    %esi,%edx
c010acd8:	ee                   	out    %al,(%dx)
    io_outb(0x3D4, 14);
    io_outb(0x3D5, pos / 256);
c010acd9:	0f b6 c5             	movzbl %ch,%eax
c010acdc:	bb d5 03 00 00       	mov    $0x3d5,%ebx
c010ace1:	89 da                	mov    %ebx,%edx
c010ace3:	ee                   	out    %al,(%dx)
c010ace4:	b8 0f 00 00 00       	mov    $0xf,%eax
c010ace9:	89 f2                	mov    %esi,%edx
c010aceb:	ee                   	out    %al,(%dx)
c010acec:	89 c8                	mov    %ecx,%eax
c010acee:	89 da                	mov    %ebx,%edx
c010acf0:	ee                   	out    %al,(%dx)
    io_outb(0x3D4, 15);
    io_outb(0x3D5, pos % 256);
}
c010acf1:	5b                   	pop    %ebx
c010acf2:	5e                   	pop    %esi
c010acf3:	5d                   	pop    %ebp
c010acf4:	c3                   	ret    

c010acf5 <tty_flush_buffer>:
{
c010acf5:	55                   	push   %ebp
c010acf6:	89 e5                	mov    %esp,%ebp
c010acf8:	57                   	push   %edi
c010acf9:	56                   	push   %esi
c010acfa:	53                   	push   %ebx
c010acfb:	83 ec 2c             	sub    $0x2c,%esp
c010acfe:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    TTY_CLEAR
c010ad01:	8b 3d 00 20 d1 c0    	mov    0xc0d12000,%edi
c010ad07:	b9 d0 07 00 00       	mov    $0x7d0,%ecx
c010ad0c:	0f b7 05 40 00 d1 c0 	movzwl 0xc0d10040,%eax
c010ad13:	66 f3 ab             	rep stos %ax,%es:(%edi)
    int g[2] = { 0, 0 };
c010ad16:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
c010ad1d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    vga_attribute current_theme = tty_theme_color;
c010ad24:	0f b7 05 40 00 d1 c0 	movzwl 0xc0d10040,%eax
c010ad2b:	66 89 45 ca          	mov    %ax,-0x36(%ebp)
    int state = 0;
c010ad2f:	ba 00 00 00 00       	mov    $0x0,%edx
    int x = 0, y = 0;
c010ad34:	bf 00 00 00 00       	mov    $0x0,%edi
c010ad39:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
c010ad40:	89 7d cc             	mov    %edi,-0x34(%ebp)
c010ad43:	89 55 d4             	mov    %edx,-0x2c(%ebp)
c010ad46:	8b 7d 08             	mov    0x8(%ebp),%edi
c010ad49:	e9 0f 01 00 00       	jmp    c010ae5d <tty_flush_buffer+0x168>
            } else if (chr == ';' && state == 2) {
c010ad4e:	3c 3b                	cmp    $0x3b,%al
c010ad50:	0f 94 c0             	sete   %al
c010ad53:	83 7d d4 02          	cmpl   $0x2,-0x2c(%ebp)
c010ad57:	0f 94 c2             	sete   %dl
c010ad5a:	84 d0                	test   %dl,%al
c010ad5c:	0f 85 62 01 00 00    	jne    c010aec4 <tty_flush_buffer+0x1cf>
                if (g[0] == 39 && g[1] == 49) {
c010ad62:	8b 55 e0             	mov    -0x20(%ebp),%edx
c010ad65:	83 fa 27             	cmp    $0x27,%edx
c010ad68:	74 29                	je     c010ad93 <tty_flush_buffer+0x9e>
                    current_theme = (g[1] << 4 | g[0]) << 8;
c010ad6a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010ad6d:	c1 e0 04             	shl    $0x4,%eax
c010ad70:	09 d0                	or     %edx,%eax
c010ad72:	c1 e0 08             	shl    $0x8,%eax
c010ad75:	66 89 45 ca          	mov    %ax,-0x36(%ebp)
                g[0] = 0;
c010ad79:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
                g[1] = 0;
c010ad80:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
                state = 0;
c010ad87:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
c010ad8e:	e9 c7 00 00 00       	jmp    c010ae5a <tty_flush_buffer+0x165>
                if (g[0] == 39 && g[1] == 49) {
c010ad93:	83 7d e4 31          	cmpl   $0x31,-0x1c(%ebp)
c010ad97:	75 d1                	jne    c010ad6a <tty_flush_buffer+0x75>
                    current_theme = tty_theme_color;
c010ad99:	0f b7 05 40 00 d1 c0 	movzwl 0xc0d10040,%eax
c010ada0:	66 89 45 ca          	mov    %ax,-0x36(%ebp)
c010ada4:	eb d3                	jmp    c010ad79 <tty_flush_buffer+0x84>
            switch (chr) {
c010ada6:	3c 0a                	cmp    $0xa,%al
c010ada8:	74 3b                	je     c010ade5 <tty_flush_buffer+0xf0>
c010adaa:	7f 1f                	jg     c010adcb <tty_flush_buffer+0xd6>
c010adac:	3c 08                	cmp    $0x8,%al
c010adae:	74 42                	je     c010adf2 <tty_flush_buffer+0xfd>
c010adb0:	3c 09                	cmp    $0x9,%al
c010adb2:	75 6c                	jne    c010ae20 <tty_flush_buffer+0x12b>
                    x += 4;
c010adb4:	83 45 d0 04          	addl   $0x4,-0x30(%ebp)
            if (x >= TTY_WIDTH) {
c010adb8:	83 7d d0 4f          	cmpl   $0x4f,-0x30(%ebp)
c010adbc:	7e 18                	jle    c010add6 <tty_flush_buffer+0xe1>
                y++;
c010adbe:	83 45 cc 01          	addl   $0x1,-0x34(%ebp)
                x = 0;
c010adc2:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
c010adc9:	eb 0b                	jmp    c010add6 <tty_flush_buffer+0xe1>
            switch (chr) {
c010adcb:	3c 0d                	cmp    $0xd,%al
c010adcd:	75 51                	jne    c010ae20 <tty_flush_buffer+0x12b>
c010adcf:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
            if (y >= TTY_HEIGHT) {
c010add6:	83 7d cc 18          	cmpl   $0x18,-0x34(%ebp)
c010adda:	7f 6f                	jg     c010ae4b <tty_flush_buffer+0x156>
            state = 0;
c010addc:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
c010ade3:	eb 75                	jmp    c010ae5a <tty_flush_buffer+0x165>
                    y++;
c010ade5:	83 45 cc 01          	addl   $0x1,-0x34(%ebp)
                    x = 0;
c010ade9:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
c010adf0:	eb e4                	jmp    c010add6 <tty_flush_buffer+0xe1>
                    x = x ? x - 1 : 0;
c010adf2:	8b 45 d0             	mov    -0x30(%ebp),%eax
c010adf5:	85 c0                	test   %eax,%eax
c010adf7:	74 06                	je     c010adff <tty_flush_buffer+0x10a>
c010adf9:	83 e8 01             	sub    $0x1,%eax
c010adfc:	89 45 d0             	mov    %eax,-0x30(%ebp)
                    *(tty_vga_buffer + x + y * TTY_WIDTH) =
c010adff:	8b 45 cc             	mov    -0x34(%ebp),%eax
c010ae02:	8d 14 80             	lea    (%eax,%eax,4),%edx
c010ae05:	89 d0                	mov    %edx,%eax
c010ae07:	c1 e0 04             	shl    $0x4,%eax
c010ae0a:	03 45 d0             	add    -0x30(%ebp),%eax
c010ae0d:	0f b7 4d ca          	movzwl -0x36(%ebp),%ecx
c010ae11:	83 c9 20             	or     $0x20,%ecx
c010ae14:	8b 15 00 20 d1 c0    	mov    0xc0d12000,%edx
c010ae1a:	66 89 0c 42          	mov    %cx,(%edx,%eax,2)
                    break;
c010ae1e:	eb 98                	jmp    c010adb8 <tty_flush_buffer+0xc3>
                    *(tty_vga_buffer + x + y * TTY_WIDTH) =
c010ae20:	8b 75 cc             	mov    -0x34(%ebp),%esi
c010ae23:	8d 0c b6             	lea    (%esi,%esi,4),%ecx
c010ae26:	89 ca                	mov    %ecx,%edx
c010ae28:	c1 e2 04             	shl    $0x4,%edx
c010ae2b:	8b 75 d0             	mov    -0x30(%ebp),%esi
c010ae2e:	01 f2                	add    %esi,%edx
                      (current_theme | chr);
c010ae30:	66 98                	cbtw   
c010ae32:	66 0b 45 ca          	or     -0x36(%ebp),%ax
                    *(tty_vga_buffer + x + y * TTY_WIDTH) =
c010ae36:	8b 0d 00 20 d1 c0    	mov    0xc0d12000,%ecx
c010ae3c:	66 89 04 51          	mov    %ax,(%ecx,%edx,2)
                    (x)++;
c010ae40:	83 c6 01             	add    $0x1,%esi
c010ae43:	89 75 d0             	mov    %esi,-0x30(%ebp)
                    break;
c010ae46:	e9 6d ff ff ff       	jmp    c010adb8 <tty_flush_buffer+0xc3>
                y--;
c010ae4b:	8b 7d cc             	mov    -0x34(%ebp),%edi
c010ae4e:	83 ef 01             	sub    $0x1,%edi
                break;
c010ae51:	eb 7d                	jmp    c010aed0 <tty_flush_buffer+0x1db>
            state = 1;
c010ae53:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
        pos++;
c010ae5a:	83 c3 01             	add    $0x1,%ebx
        if (pos == limit) {
c010ae5d:	3b 5d 10             	cmp    0x10(%ebp),%ebx
c010ae60:	74 6b                	je     c010aecd <tty_flush_buffer+0x1d8>
        char chr = data[pos];
c010ae62:	0f b6 04 1f          	movzbl (%edi,%ebx,1),%eax
        if (state == 0 && chr == '\x033') {
c010ae66:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
c010ae6a:	0f 94 c1             	sete   %cl
c010ae6d:	89 ce                	mov    %ecx,%esi
c010ae6f:	3c 33                	cmp    $0x33,%al
c010ae71:	0f 94 c1             	sete   %cl
c010ae74:	89 f2                	mov    %esi,%edx
c010ae76:	84 ca                	test   %cl,%dl
c010ae78:	75 d9                	jne    c010ae53 <tty_flush_buffer+0x15e>
        } else if (state == 1 && chr == '[') {
c010ae7a:	83 7d d4 01          	cmpl   $0x1,-0x2c(%ebp)
c010ae7e:	0f 94 c2             	sete   %dl
c010ae81:	3c 5b                	cmp    $0x5b,%al
c010ae83:	0f 94 c1             	sete   %cl
c010ae86:	84 ca                	test   %cl,%dl
c010ae88:	75 31                	jne    c010aebb <tty_flush_buffer+0x1c6>
        } else if (state > 1) {
c010ae8a:	8b 75 d4             	mov    -0x2c(%ebp),%esi
c010ae8d:	83 fe 01             	cmp    $0x1,%esi
c010ae90:	0f 8e 10 ff ff ff    	jle    c010ada6 <tty_flush_buffer+0xb1>
            if ('0' <= chr && chr <= '9') {
c010ae96:	8d 48 d0             	lea    -0x30(%eax),%ecx
c010ae99:	80 f9 09             	cmp    $0x9,%cl
c010ae9c:	0f 87 ac fe ff ff    	ja     c010ad4e <tty_flush_buffer+0x59>
                g[state - 2] = (chr - '0') + g[state - 2] * 10;
c010aea2:	0f be c0             	movsbl %al,%eax
c010aea5:	8d 4e fe             	lea    -0x2(%esi),%ecx
c010aea8:	8b 74 8d e0          	mov    -0x20(%ebp,%ecx,4),%esi
c010aeac:	8d 34 b6             	lea    (%esi,%esi,4),%esi
c010aeaf:	01 f6                	add    %esi,%esi
c010aeb1:	8d 44 30 d0          	lea    -0x30(%eax,%esi,1),%eax
c010aeb5:	89 44 8d e0          	mov    %eax,-0x20(%ebp,%ecx,4)
c010aeb9:	eb 9f                	jmp    c010ae5a <tty_flush_buffer+0x165>
            state = 2;
c010aebb:	c7 45 d4 02 00 00 00 	movl   $0x2,-0x2c(%ebp)
c010aec2:	eb 96                	jmp    c010ae5a <tty_flush_buffer+0x165>
                state = 3;
c010aec4:	c7 45 d4 03 00 00 00 	movl   $0x3,-0x2c(%ebp)
c010aecb:	eb 8d                	jmp    c010ae5a <tty_flush_buffer+0x165>
c010aecd:	8b 7d cc             	mov    -0x34(%ebp),%edi
    tty_set_cursor(x, y);
c010aed0:	83 ec 08             	sub    $0x8,%esp
c010aed3:	57                   	push   %edi
c010aed4:	ff 75 d0             	push   -0x30(%ebp)
c010aed7:	e8 b7 fd ff ff       	call   c010ac93 <tty_set_cursor>
}
c010aedc:	89 d8                	mov    %ebx,%eax
c010aede:	8d 65 f4             	lea    -0xc(%ebp),%esp
c010aee1:	5b                   	pop    %ebx
c010aee2:	5e                   	pop    %esi
c010aee3:	5f                   	pop    %edi
c010aee4:	5d                   	pop    %ebp
c010aee5:	c3                   	ret    

c010aee6 <tty_clear_line>:

void
tty_clear_line(int line_num)
{
c010aee6:	55                   	push   %ebp
c010aee7:	89 e5                	mov    %esp,%ebp
c010aee9:	57                   	push   %edi
c010aeea:	8b 45 08             	mov    0x8(%ebp),%eax
    asm volatile("rep stosw" ::"D"(tty_vga_buffer + line_num * TTY_WIDTH),
c010aeed:	8d 04 80             	lea    (%eax,%eax,4),%eax
c010aef0:	c1 e0 05             	shl    $0x5,%eax
c010aef3:	89 c7                	mov    %eax,%edi
c010aef5:	03 3d 00 20 d1 c0    	add    0xc0d12000,%edi
c010aefb:	b9 50 00 00 00       	mov    $0x50,%ecx
c010af00:	0f b7 05 40 00 d1 c0 	movzwl 0xc0d10040,%eax
c010af07:	66 f3 ab             	rep stos %ax,%es:(%edi)
                 "c"(TTY_WIDTH),
                 "a"(tty_theme_color)
                 : "memory");
}
c010af0a:	8b 7d fc             	mov    -0x4(%ebp),%edi
c010af0d:	c9                   	leave  
c010af0e:	c3                   	ret    

c010af0f <tty_put_str_at>:

void
tty_put_str_at(char* str, int x, int y)
{
c010af0f:	55                   	push   %ebp
c010af10:	89 e5                	mov    %esp,%ebp
c010af12:	57                   	push   %edi
c010af13:	56                   	push   %esi
c010af14:	53                   	push   %ebx
c010af15:	8b 75 08             	mov    0x8(%ebp),%esi
c010af18:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c010af1b:	8b 5d 10             	mov    0x10(%ebp),%ebx
    char c;
    while ((c = (*str)) && y < TTY_HEIGHT) {
c010af1e:	eb 03                	jmp    c010af23 <tty_put_str_at+0x14>
        x++;
        if (x >= TTY_WIDTH) {
            y++;
            x = 0;
        }
        str++;
c010af20:	83 c6 01             	add    $0x1,%esi
    while ((c = (*str)) && y < TTY_HEIGHT) {
c010af23:	0f b6 06             	movzbl (%esi),%eax
c010af26:	84 c0                	test   %al,%al
c010af28:	74 34                	je     c010af5e <tty_put_str_at+0x4f>
c010af2a:	83 fb 18             	cmp    $0x18,%ebx
c010af2d:	7f 2f                	jg     c010af5e <tty_put_str_at+0x4f>
        *(tty_vga_buffer + x + y * TTY_WIDTH) = c | tty_theme_color;
c010af2f:	8d 3c 9b             	lea    (%ebx,%ebx,4),%edi
c010af32:	89 fa                	mov    %edi,%edx
c010af34:	c1 e2 04             	shl    $0x4,%edx
c010af37:	01 ca                	add    %ecx,%edx
c010af39:	66 98                	cbtw   
c010af3b:	66 0b 05 40 00 d1 c0 	or     0xc0d10040,%ax
c010af42:	8b 3d 00 20 d1 c0    	mov    0xc0d12000,%edi
c010af48:	66 89 04 57          	mov    %ax,(%edi,%edx,2)
        x++;
c010af4c:	83 c1 01             	add    $0x1,%ecx
        if (x >= TTY_WIDTH) {
c010af4f:	83 f9 4f             	cmp    $0x4f,%ecx
c010af52:	7e cc                	jle    c010af20 <tty_put_str_at+0x11>
            y++;
c010af54:	83 c3 01             	add    $0x1,%ebx
            x = 0;
c010af57:	b9 00 00 00 00       	mov    $0x0,%ecx
c010af5c:	eb c2                	jmp    c010af20 <tty_put_str_at+0x11>
    }
c010af5e:	5b                   	pop    %ebx
c010af5f:	5e                   	pop    %esi
c010af60:	5f                   	pop    %edi
c010af61:	5d                   	pop    %ebp
c010af62:	c3                   	ret    

c010af63 <__assert_fail>:

static char buffer[1024];

void
__assert_fail(const char* expr, const char* file, unsigned int line)
{
c010af63:	55                   	push   %ebp
c010af64:	89 e5                	mov    %esp,%ebp
c010af66:	57                   	push   %edi
c010af67:	83 ec 10             	sub    $0x10,%esp
    sprintf(buffer, "%s (%s:%u)", expr, file, line);
c010af6a:	ff 75 10             	push   0x10(%ebp)
c010af6d:	ff 75 0c             	push   0xc(%ebp)
c010af70:	ff 75 08             	push   0x8(%ebp)
c010af73:	68 41 32 d1 c0       	push   $0xc0d13241
c010af78:	68 60 00 d1 c0       	push   $0xc0d10060
c010af7d:	e8 09 3c 00 00       	call   c010eb8b <sprintf>

    // Here we load the buffer's address into %edi ("D" constraint)
    //  This is a convention we made that the LUNAIX_SYS_PANIC syscall will
    //  print the panic message passed via %edi. (see
    //  kernel/asm/x86/interrupts.c)
    asm("int %0" ::"i"(LUNAIX_SYS_PANIC), "D"(buffer));
c010af82:	bf 60 00 d1 c0       	mov    $0xc0d10060,%edi
c010af87:	cd 20                	int    $0x20
c010af89:	83 c4 20             	add    $0x20,%esp
c010af8c:	eb fe                	jmp    c010af8c <__assert_fail+0x29>

c010af8e <panick>:
    spin(); // never reach
}

void
panick(const char* msg)
{
c010af8e:	55                   	push   %ebp
c010af8f:	89 e5                	mov    %esp,%ebp
c010af91:	57                   	push   %edi
    asm("int %0" ::"i"(LUNAIX_SYS_PANIC), "D"(msg));
c010af92:	8b 7d 08             	mov    0x8(%ebp),%edi
c010af95:	cd 20                	int    $0x20
    spin();
c010af97:	eb fe                	jmp    c010af97 <panick+0x9>

c010af99 <sched_init>:

LOG_MODULE("SCHED")

void
sched_init()
{
c010af99:	55                   	push   %ebp
c010af9a:	89 e5                	mov    %esp,%ebp
c010af9c:	53                   	push   %ebx
c010af9d:	83 ec 04             	sub    $0x4,%esp
    size_t pg_size = ROUNDUP(sizeof(struct proc_info) * MAX_PROCESS, 0x1000);

    for (size_t i = 0; i <= pg_size; i += 4096) {
c010afa0:	bb 00 00 00 00       	mov    $0x0,%ebx
c010afa5:	eb 30                	jmp    c010afd7 <sched_init+0x3e>
        uintptr_t pa = pmm_alloc_page(KERNEL_PID, PP_FGPERSIST);
c010afa7:	83 ec 08             	sub    $0x8,%esp
c010afaa:	6a 01                	push   $0x1
c010afac:	6a ff                	push   $0xffffffff
c010afae:	e8 14 fb ff ff       	call   c010aac7 <pmm_alloc_page>
        vmm_set_mapping(
c010afb3:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c010afba:	6a 03                	push   $0x3
c010afbc:	50                   	push   %eax
c010afbd:	8d 83 00 00 40 d0    	lea    -0x2fc00000(%ebx),%eax
c010afc3:	50                   	push   %eax
c010afc4:	68 00 00 c0 ff       	push   $0xffc00000
c010afc9:	e8 72 f4 ff ff       	call   c010a440 <vmm_set_mapping>
    for (size_t i = 0; i <= pg_size; i += 4096) {
c010afce:	81 c3 00 10 00 00    	add    $0x1000,%ebx
c010afd4:	83 c4 20             	add    $0x20,%esp
c010afd7:	81 fb 00 20 02 00    	cmp    $0x22000,%ebx
c010afdd:	76 c8                	jbe    c010afa7 <sched_init+0xe>
          PD_REFERENCED, PROC_START + i, pa, PG_PREM_RW, VMAP_NULL);
    }

    sched_ctx = (struct scheduler){ ._procs = (struct proc_info*)PROC_START,
c010afdf:	c7 05 60 04 d1 c0 00 	movl   $0xd0400000,0xc0d10460
c010afe6:	00 40 d0 
c010afe9:	c7 05 64 04 d1 c0 00 	movl   $0x0,0xc0d10464
c010aff0:	00 00 00 
c010aff3:	c7 05 68 04 d1 c0 00 	movl   $0x0,0xc0d10468
c010affa:	00 00 00 
                                    .ptable_len = 0,
                                    .procs_index = 0 };
}
c010affd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c010b000:	c9                   	leave  
c010b001:	c3                   	ret    

c010b002 <run>:

void
run(struct proc_info* proc)
{
c010b002:	55                   	push   %ebp
c010b003:	89 e5                	mov    %esp,%ebp
c010b005:	53                   	push   %ebx
c010b006:	83 ec 10             	sub    $0x10,%esp
c010b009:	8b 5d 08             	mov    0x8(%ebp),%ebx
    proc->state = PS_RUNNING;
c010b00c:	c6 83 ac 00 00 00 01 	movb   $0x1,0xac(%ebx)
          信号的处理。当用户自定义的信号处理函数返回时，sigreturn的系统调用才开始进行上下文的恢复（或者说是进行
          另一次调度。
        由于这中间没有进行地址空间的交换，所以第二次跳转使用的是同一个内核栈，而之前默认tss.esp0的值是永远指向最顶部
        这样一来就有可能会覆盖更早的上下文信息（比如嵌套的信号捕获函数）
    */
    tss_update_esp(proc->intr_ctx.registers.esp);
c010b013:	ff 73 34             	push   0x34(%ebx)
c010b016:	e8 55 14 00 00       	call   c010c470 <tss_update_esp>
 *
 */
inline static void
apic_done_servicing()
{
    apic_write_reg(APIC_EOI, 0);
c010b01b:	c7 05 b0 00 c0 d0 00 	movl   $0x0,0xd0c000b0
c010b022:	00 00 00 

    apic_done_servicing();

    asm volatile("pushl %0\n"
c010b025:	53                   	push   %ebx
c010b026:	e9 fa 13 00 00       	jmp    c010c425 <switch_to>
                 "jmp switch_to\n" ::"r"(proc)); // kernel/asm/x86/interrupt.S
}
c010b02b:	83 c4 10             	add    $0x10,%esp
c010b02e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c010b031:	c9                   	leave  
c010b032:	c3                   	ret    

c010b033 <can_schedule>:

int
can_schedule(struct proc_info* proc)
{
c010b033:	55                   	push   %ebp
c010b034:	89 e5                	mov    %esp,%ebp
c010b036:	8b 55 08             	mov    0x8(%ebp),%edx
    if (__SIGTEST(proc->sig_pending, _SIGCONT)) {
c010b039:	8b 82 b8 00 00 00    	mov    0xb8(%edx),%eax
c010b03f:	a8 80                	test   $0x80,%al
c010b041:	74 10                	je     c010b053 <can_schedule+0x20>
        __SIGCLEAR(proc->sig_pending, _SIGSTOP);
c010b043:	83 e0 bf             	and    $0xffffffbf,%eax
c010b046:	89 82 b8 00 00 00    	mov    %eax,0xb8(%edx)
    } else if (__SIGTEST(proc->sig_pending, _SIGSTOP)) {
        // 如果进程受到SIGSTOP，则该进程不给予调度。
        return 0;
    }

    return 1;
c010b04c:	b8 01 00 00 00       	mov    $0x1,%eax
}
c010b051:	5d                   	pop    %ebp
c010b052:	c3                   	ret    
    } else if (__SIGTEST(proc->sig_pending, _SIGSTOP)) {
c010b053:	a8 40                	test   $0x40,%al
c010b055:	75 07                	jne    c010b05e <can_schedule+0x2b>
    return 1;
c010b057:	b8 01 00 00 00       	mov    $0x1,%eax
c010b05c:	eb f3                	jmp    c010b051 <can_schedule+0x1e>
        return 0;
c010b05e:	b8 00 00 00 00       	mov    $0x0,%eax
c010b063:	eb ec                	jmp    c010b051 <can_schedule+0x1e>

c010b065 <check_sleepers>:

void
check_sleepers()
{
c010b065:	55                   	push   %ebp
c010b066:	89 e5                	mov    %esp,%ebp
c010b068:	57                   	push   %edi
c010b069:	56                   	push   %esi
c010b06a:	53                   	push   %ebx
c010b06b:	83 ec 1c             	sub    $0x1c,%esp
    struct proc_info* leader = &sched_ctx._procs[0];
c010b06e:	8b 1d 60 04 d1 c0    	mov    0xc0d10460,%ebx
    struct proc_info *pos, *n;
    time_t now = clock_systime();
c010b074:	e8 79 0b 00 00       	call   c010bbf2 <clock_systime>
c010b079:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    llist_for_each(pos, n, &leader->sleep.sleepers, sleep.sleepers)
c010b07c:	8b 53 78             	mov    0x78(%ebx),%edx
c010b07f:	8d 42 8c             	lea    -0x74(%edx),%eax
c010b082:	8b 52 04             	mov    0x4(%edx),%edx
c010b085:	83 ea 74             	sub    $0x74,%edx
c010b088:	eb 23                	jmp    c010b0ad <check_sleepers+0x48>
        if (atime && now >= atime) {
            pos->sleep.alarm_time = 0;
            __SIGSET(pos->sig_pending, _SIGALRM);
        }

        if (!wtime && !atime) {
c010b08a:	09 f1                	or     %esi,%ecx
c010b08c:	75 17                	jne    c010b0a5 <check_sleepers+0x40>
        del:
            llist_delete(&pos->sleep.sleepers);
c010b08e:	8d 48 74             	lea    0x74(%eax),%ecx
}

static inline void
llist_delete(struct llist_header* elem)
{
    elem->prev->next = elem->next;
c010b091:	8b 78 74             	mov    0x74(%eax),%edi
c010b094:	8b 70 78             	mov    0x78(%eax),%esi
c010b097:	89 77 04             	mov    %esi,0x4(%edi)
    elem->next->prev = elem->prev;
c010b09a:	8b 78 74             	mov    0x74(%eax),%edi
c010b09d:	89 3e                	mov    %edi,(%esi)

    // make elem orphaned
    elem->prev = elem;
c010b09f:	89 48 74             	mov    %ecx,0x74(%eax)
    elem->next = elem;
c010b0a2:	89 48 78             	mov    %ecx,0x78(%eax)
    llist_for_each(pos, n, &leader->sleep.sleepers, sleep.sleepers)
c010b0a5:	8b 4a 78             	mov    0x78(%edx),%ecx
c010b0a8:	89 d0                	mov    %edx,%eax
c010b0aa:	8d 51 8c             	lea    -0x74(%ecx),%edx
c010b0ad:	39 d8                	cmp    %ebx,%eax
c010b0af:	74 4b                	je     c010b0fc <check_sleepers+0x97>
        if (PROC_TERMINATED(pos->state)) {
c010b0b1:	f6 80 ac 00 00 00 06 	testb  $0x6,0xac(%eax)
c010b0b8:	75 d4                	jne    c010b08e <check_sleepers+0x29>
        time_t wtime = pos->sleep.wakeup_time;
c010b0ba:	8b 70 7c             	mov    0x7c(%eax),%esi
        time_t atime = pos->sleep.alarm_time;
c010b0bd:	8b 88 80 00 00 00    	mov    0x80(%eax),%ecx
        if (wtime && now >= wtime) {
c010b0c3:	8d 7e ff             	lea    -0x1(%esi),%edi
c010b0c6:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
c010b0c9:	76 0e                	jbe    c010b0d9 <check_sleepers+0x74>
            pos->sleep.wakeup_time = 0;
c010b0cb:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%eax)
            pos->state = PS_STOPPED;
c010b0d2:	c6 80 ac 00 00 00 00 	movb   $0x0,0xac(%eax)
        if (atime && now >= atime) {
c010b0d9:	8d 79 ff             	lea    -0x1(%ecx),%edi
c010b0dc:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
c010b0df:	76 a9                	jbe    c010b08a <check_sleepers+0x25>
            pos->sleep.alarm_time = 0;
c010b0e1:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
c010b0e8:	00 00 00 
            __SIGSET(pos->sig_pending, _SIGALRM);
c010b0eb:	8b b8 b8 00 00 00    	mov    0xb8(%eax),%edi
c010b0f1:	83 cf 04             	or     $0x4,%edi
c010b0f4:	89 b8 b8 00 00 00    	mov    %edi,0xb8(%eax)
c010b0fa:	eb 8e                	jmp    c010b08a <check_sleepers+0x25>
        }
    }
}
c010b0fc:	83 c4 1c             	add    $0x1c,%esp
c010b0ff:	5b                   	pop    %ebx
c010b100:	5e                   	pop    %esi
c010b101:	5f                   	pop    %edi
c010b102:	5d                   	pop    %ebp
c010b103:	c3                   	ret    

c010b104 <schedule>:

void
schedule()
{
    if (!sched_ctx.ptable_len) {
c010b104:	83 3d 68 04 d1 c0 00 	cmpl   $0x0,0xc0d10468
c010b10b:	0f 84 86 00 00 00    	je     c010b197 <schedule+0x93>
{
c010b111:	55                   	push   %ebp
c010b112:	89 e5                	mov    %esp,%ebp
c010b114:	57                   	push   %edi
c010b115:	56                   	push   %esi
c010b116:	53                   	push   %ebx
c010b117:	83 ec 0c             	sub    $0xc,%esp
}

static inline void
cpu_disable_interrupt()
{
    asm volatile("cli");
c010b11a:	fa                   	cli    
    }

    // 上下文切换相当的敏感！我们不希望任何的中断打乱栈的顺序……
    cpu_disable_interrupt();
    struct proc_info* next;
    int prev_ptr = sched_ctx.procs_index;
c010b11b:	8b 3d 64 04 d1 c0    	mov    0xc0d10464,%edi
    int ptr = prev_ptr;

    if (!(__current->state & ~PS_RUNNING)) {
c010b121:	a1 8c 05 d1 c0       	mov    0xc0d1058c,%eax
c010b126:	0f b6 90 ac 00 00 00 	movzbl 0xac(%eax),%edx
c010b12d:	f6 c2 fe             	test   $0xfe,%dl
c010b130:	75 07                	jne    c010b139 <schedule+0x35>
        __current->state = PS_STOPPED;
c010b132:	c6 80 ac 00 00 00 00 	movb   $0x0,0xac(%eax)
    }

    check_sleepers();
c010b139:	e8 27 ff ff ff       	call   c010b065 <check_sleepers>
    int ptr = prev_ptr;
c010b13e:	89 fb                	mov    %edi,%ebx
c010b140:	eb 16                	jmp    c010b158 <schedule+0x54>
    do {
        ptr = (ptr + 1) % sched_ctx.ptable_len;
        next = &sched_ctx._procs[ptr];
    } while (next->state != PS_STOPPED && ptr != prev_ptr);

    sched_ctx.procs_index = ptr;
c010b142:	89 15 64 04 d1 c0    	mov    %edx,0xc0d10464

    if (!can_schedule(next)) {
c010b148:	83 ec 0c             	sub    $0xc,%esp
c010b14b:	56                   	push   %esi
c010b14c:	e8 e2 fe ff ff       	call   c010b033 <can_schedule>
c010b151:	83 c4 10             	add    $0x10,%esp
c010b154:	85 c0                	test   %eax,%eax
c010b156:	75 2b                	jne    c010b183 <schedule+0x7f>
        ptr = (ptr + 1) % sched_ctx.ptable_len;
c010b158:	8d 43 01             	lea    0x1(%ebx),%eax
c010b15b:	ba 00 00 00 00       	mov    $0x0,%edx
c010b160:	f7 35 68 04 d1 c0    	divl   0xc0d10468
c010b166:	89 d3                	mov    %edx,%ebx
        next = &sched_ctx._procs[ptr];
c010b168:	69 f2 0c 01 00 00    	imul   $0x10c,%edx,%esi
c010b16e:	03 35 60 04 d1 c0    	add    0xc0d10460,%esi
    } while (next->state != PS_STOPPED && ptr != prev_ptr);
c010b174:	80 be ac 00 00 00 00 	cmpb   $0x0,0xac(%esi)
c010b17b:	74 c5                	je     c010b142 <schedule+0x3e>
c010b17d:	39 d7                	cmp    %edx,%edi
c010b17f:	75 d7                	jne    c010b158 <schedule+0x54>
c010b181:	eb bf                	jmp    c010b142 <schedule+0x3e>
        // 如果该进程不给予调度，则尝试重新选择
        goto redo;
    }

    run(next);
c010b183:	83 ec 0c             	sub    $0xc,%esp
c010b186:	56                   	push   %esi
c010b187:	e8 76 fe ff ff       	call   c010b002 <run>
c010b18c:	83 c4 10             	add    $0x10,%esp
}
c010b18f:	8d 65 f4             	lea    -0xc(%ebp),%esp
c010b192:	5b                   	pop    %ebx
c010b193:	5e                   	pop    %esi
c010b194:	5f                   	pop    %edi
c010b195:	5d                   	pop    %ebp
c010b196:	c3                   	ret    
c010b197:	c3                   	ret    

c010b198 <__lxsys_sleep>:

__DEFINE_LXSYSCALL1(unsigned int, sleep, unsigned int, seconds)
{
c010b198:	55                   	push   %ebp
c010b199:	89 e5                	mov    %esp,%ebp
c010b19b:	57                   	push   %edi
c010b19c:	56                   	push   %esi
c010b19d:	53                   	push   %ebx
c010b19e:	83 ec 0c             	sub    $0xc,%esp
c010b1a1:	8b 5d 08             	mov    0x8(%ebp),%ebx
    if (!seconds) {
c010b1a4:	85 db                	test   %ebx,%ebx
c010b1a6:	74 69                	je     c010b211 <__lxsys_sleep+0x79>
        return 0;
    }

    if (__current->sleep.wakeup_time) {
c010b1a8:	a1 8c 05 d1 c0       	mov    0xc0d1058c,%eax
c010b1ad:	8b 50 7c             	mov    0x7c(%eax),%edx
c010b1b0:	85 d2                	test   %edx,%edx
c010b1b2:	75 45                	jne    c010b1f9 <__lxsys_sleep+0x61>
        return (__current->sleep.wakeup_time - clock_systime()) / 1000U;
    }

    __current->sleep.wakeup_time = clock_systime() + seconds * 1000;
c010b1b4:	e8 39 0a 00 00       	call   c010bbf2 <clock_systime>
c010b1b9:	69 cb e8 03 00 00    	imul   $0x3e8,%ebx,%ecx
c010b1bf:	8b 15 8c 05 d1 c0    	mov    0xc0d1058c,%edx
c010b1c5:	01 c8                	add    %ecx,%eax
c010b1c7:	89 42 7c             	mov    %eax,0x7c(%edx)
    llist_append(&sched_ctx._procs[0].sleep.sleepers,
                 &__current->sleep.sleepers);
c010b1ca:	8d 4a 74             	lea    0x74(%edx),%ecx
    llist_append(&sched_ctx._procs[0].sleep.sleepers,
c010b1cd:	a1 60 04 d1 c0       	mov    0xc0d10460,%eax
c010b1d2:	8d 78 74             	lea    0x74(%eax),%edi
    __llist_add(elem, head, head->next);
c010b1d5:	8b 70 78             	mov    0x78(%eax),%esi
    next->prev = elem;
c010b1d8:	89 0e                	mov    %ecx,(%esi)
    elem->next = next;
c010b1da:	89 72 78             	mov    %esi,0x78(%edx)
    elem->prev = prev;
c010b1dd:	89 7a 74             	mov    %edi,0x74(%edx)
    prev->next = elem;
c010b1e0:	89 48 78             	mov    %ecx,0x78(%eax)

    __current->intr_ctx.registers.eax = seconds;
c010b1e3:	a1 8c 05 d1 c0       	mov    0xc0d1058c,%eax
c010b1e8:	89 58 08             	mov    %ebx,0x8(%eax)
    __current->state = PS_BLOCKED;
c010b1eb:	c6 80 ac 00 00 00 08 	movb   $0x8,0xac(%eax)
    schedule();
c010b1f2:	e8 0d ff ff ff       	call   c010b104 <schedule>
}
c010b1f7:	eb 1a                	jmp    c010b213 <__lxsys_sleep+0x7b>
        return (__current->sleep.wakeup_time - clock_systime()) / 1000U;
c010b1f9:	8b 58 7c             	mov    0x7c(%eax),%ebx
c010b1fc:	e8 f1 09 00 00       	call   c010bbf2 <clock_systime>
c010b201:	29 c3                	sub    %eax,%ebx
c010b203:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
c010b208:	89 d8                	mov    %ebx,%eax
c010b20a:	f7 e2                	mul    %edx
c010b20c:	89 d3                	mov    %edx,%ebx
c010b20e:	c1 eb 06             	shr    $0x6,%ebx
}
c010b211:	89 d8                	mov    %ebx,%eax
c010b213:	83 c4 0c             	add    $0xc,%esp
c010b216:	5b                   	pop    %ebx
c010b217:	5e                   	pop    %esi
c010b218:	5f                   	pop    %edi
c010b219:	5d                   	pop    %ebp
c010b21a:	c3                   	ret    

c010b21b <__lxsys_alarm>:

__DEFINE_LXSYSCALL1(unsigned int, alarm, unsigned int, seconds)
{
c010b21b:	55                   	push   %ebp
c010b21c:	89 e5                	mov    %esp,%ebp
c010b21e:	57                   	push   %edi
c010b21f:	56                   	push   %esi
c010b220:	53                   	push   %ebx
c010b221:	83 ec 1c             	sub    $0x1c,%esp
c010b224:	8b 75 08             	mov    0x8(%ebp),%esi
    time_t prev_ddl = __current->sleep.alarm_time;
c010b227:	a1 8c 05 d1 c0       	mov    0xc0d1058c,%eax
c010b22c:	8b 98 80 00 00 00    	mov    0x80(%eax),%ebx
    time_t now = clock_systime();
c010b232:	e8 bb 09 00 00       	call   c010bbf2 <clock_systime>
c010b237:	89 c1                	mov    %eax,%ecx

    __current->sleep.alarm_time = seconds ? now + seconds * 1000 : 0;
c010b239:	85 f6                	test   %esi,%esi
c010b23b:	74 08                	je     c010b245 <__lxsys_alarm+0x2a>
c010b23d:	69 f6 e8 03 00 00    	imul   $0x3e8,%esi,%esi
c010b243:	01 c6                	add    %eax,%esi
c010b245:	a1 8c 05 d1 c0       	mov    0xc0d1058c,%eax
c010b24a:	89 b0 80 00 00 00    	mov    %esi,0x80(%eax)

    if (llist_empty(&__current->sleep.sleepers)) {
c010b250:	8d 50 74             	lea    0x74(%eax),%edx
}

static inline int
llist_empty(struct llist_header* elem)
{
    return elem->next == elem && elem->prev == elem;
c010b253:	3b 50 78             	cmp    0x78(%eax),%edx
c010b256:	74 1e                	je     c010b276 <__lxsys_alarm+0x5b>
        llist_append(&sched_ctx._procs[0].sleep.sleepers,
                     &__current->sleep.sleepers);
    }

    return prev_ddl ? (prev_ddl - now) / 1000 : 0;
c010b258:	85 db                	test   %ebx,%ebx
c010b25a:	74 10                	je     c010b26c <__lxsys_alarm+0x51>
c010b25c:	29 cb                	sub    %ecx,%ebx
c010b25e:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
c010b263:	89 d8                	mov    %ebx,%eax
c010b265:	f7 e2                	mul    %edx
c010b267:	89 d3                	mov    %edx,%ebx
c010b269:	c1 eb 06             	shr    $0x6,%ebx
}
c010b26c:	89 d8                	mov    %ebx,%eax
c010b26e:	83 c4 1c             	add    $0x1c,%esp
c010b271:	5b                   	pop    %ebx
c010b272:	5e                   	pop    %esi
c010b273:	5f                   	pop    %edi
c010b274:	5d                   	pop    %ebp
c010b275:	c3                   	ret    
c010b276:	3b 50 74             	cmp    0x74(%eax),%edx
c010b279:	75 dd                	jne    c010b258 <__lxsys_alarm+0x3d>
        llist_append(&sched_ctx._procs[0].sleep.sleepers,
c010b27b:	8b 35 60 04 d1 c0    	mov    0xc0d10460,%esi
c010b281:	8d 7e 74             	lea    0x74(%esi),%edi
c010b284:	89 7d e4             	mov    %edi,-0x1c(%ebp)
    __llist_add(elem, head, head->next);
c010b287:	8b 7e 78             	mov    0x78(%esi),%edi
    next->prev = elem;
c010b28a:	89 17                	mov    %edx,(%edi)
    elem->next = next;
c010b28c:	89 78 78             	mov    %edi,0x78(%eax)
    elem->prev = prev;
c010b28f:	8b 7d e4             	mov    -0x1c(%ebp),%edi
c010b292:	89 78 74             	mov    %edi,0x74(%eax)
    prev->next = elem;
c010b295:	89 56 78             	mov    %edx,0x78(%esi)
}
c010b298:	eb be                	jmp    c010b258 <__lxsys_alarm+0x3d>

c010b29a <__lxsys_yield>:
    terminate_proc(status);
    schedule();
}

__DEFINE_LXSYSCALL(void, yield)
{
c010b29a:	55                   	push   %ebp
c010b29b:	89 e5                	mov    %esp,%ebp
c010b29d:	83 ec 08             	sub    $0x8,%esp
    schedule();
c010b2a0:	e8 5f fe ff ff       	call   c010b104 <schedule>
}
c010b2a5:	c9                   	leave  
c010b2a6:	c3                   	ret    

c010b2a7 <alloc_process>:
    return destroy_process(proc->pid);
}

struct proc_info*
alloc_process()
{
c010b2a7:	55                   	push   %ebp
c010b2a8:	89 e5                	mov    %esp,%ebp
c010b2aa:	56                   	push   %esi
c010b2ab:	53                   	push   %ebx
    pid_t i = 0;
c010b2ac:	bb 00 00 00 00       	mov    $0x0,%ebx
    for (; i < sched_ctx.ptable_len && sched_ctx._procs[i].state != PS_DESTROY;
c010b2b1:	eb 03                	jmp    c010b2b6 <alloc_process+0xf>
         i++)
c010b2b3:	83 c3 01             	add    $0x1,%ebx
    for (; i < sched_ctx.ptable_len && sched_ctx._procs[i].state != PS_DESTROY;
c010b2b6:	89 de                	mov    %ebx,%esi
c010b2b8:	39 1d 68 04 d1 c0    	cmp    %ebx,0xc0d10468
c010b2be:	76 15                	jbe    c010b2d5 <alloc_process+0x2e>
c010b2c0:	69 c3 0c 01 00 00    	imul   $0x10c,%ebx,%eax
c010b2c6:	03 05 60 04 d1 c0    	add    0xc0d10460,%eax
c010b2cc:	80 b8 ac 00 00 00 04 	cmpb   $0x4,0xac(%eax)
c010b2d3:	75 de                	jne    c010b2b3 <alloc_process+0xc>
        ;

    if (i == MAX_PROCESS) {
c010b2d5:	81 fb 00 02 00 00    	cmp    $0x200,%ebx
c010b2db:	74 7b                	je     c010b358 <alloc_process+0xb1>
        panick("Panic in Ponyville shimmer!");
    }

    if (i == sched_ctx.ptable_len) {
c010b2dd:	a1 68 04 d1 c0       	mov    0xc0d10468,%eax
c010b2e2:	39 c6                	cmp    %eax,%esi
c010b2e4:	0f 84 83 00 00 00    	je     c010b36d <alloc_process+0xc6>
        sched_ctx.ptable_len++;
    }

    struct proc_info* proc = &sched_ctx._procs[i];
c010b2ea:	69 f6 0c 01 00 00    	imul   $0x10c,%esi,%esi
c010b2f0:	03 35 60 04 d1 c0    	add    0xc0d10460,%esi
    memset(proc, 0, sizeof(*proc));
c010b2f6:	83 ec 04             	sub    $0x4,%esp
c010b2f9:	68 0c 01 00 00       	push   $0x10c
c010b2fe:	6a 00                	push   $0x0
c010b300:	56                   	push   %esi
c010b301:	e8 75 39 00 00       	call   c010ec7b <memset>

    proc->state = PS_CREATED;
c010b306:	c6 86 ac 00 00 00 10 	movb   $0x10,0xac(%esi)
    proc->pid = i;
c010b30d:	89 1e                	mov    %ebx,(%esi)
    proc->created = clock_systime();
c010b30f:	e8 de 08 00 00       	call   c010bbf2 <clock_systime>
c010b314:	89 86 a8 00 00 00    	mov    %eax,0xa8(%esi)
    proc->pgid = proc->pid;
c010b31a:	8b 06                	mov    (%esi),%eax
c010b31c:	89 86 08 01 00 00    	mov    %eax,0x108(%esi)

    llist_init_head(&proc->mm.regions);
c010b322:	8d 86 94 00 00 00    	lea    0x94(%esi),%eax
    head->next = head;
c010b328:	89 86 98 00 00 00    	mov    %eax,0x98(%esi)
    head->prev = head;
c010b32e:	89 86 94 00 00 00    	mov    %eax,0x94(%esi)
    llist_init_head(&proc->children);
c010b334:	8d 46 64             	lea    0x64(%esi),%eax
    head->next = head;
c010b337:	89 46 68             	mov    %eax,0x68(%esi)
    head->prev = head;
c010b33a:	89 46 64             	mov    %eax,0x64(%esi)
    llist_init_head(&proc->grp_member);
c010b33d:	8d 46 6c             	lea    0x6c(%esi),%eax
    head->next = head;
c010b340:	89 46 70             	mov    %eax,0x70(%esi)
    head->prev = head;
c010b343:	89 46 6c             	mov    %eax,0x6c(%esi)
    llist_init_head(&proc->sleep.sleepers);
c010b346:	8d 46 74             	lea    0x74(%esi),%eax
    head->next = head;
c010b349:	89 46 78             	mov    %eax,0x78(%esi)
    head->prev = head;
c010b34c:	89 46 74             	mov    %eax,0x74(%esi)

    return proc;
}
c010b34f:	89 f0                	mov    %esi,%eax
c010b351:	8d 65 f8             	lea    -0x8(%ebp),%esp
c010b354:	5b                   	pop    %ebx
c010b355:	5e                   	pop    %esi
c010b356:	5d                   	pop    %ebp
c010b357:	c3                   	ret    
        panick("Panic in Ponyville shimmer!");
c010b358:	83 ec 0c             	sub    $0xc,%esp
c010b35b:	68 4c 32 d1 c0       	push   $0xc0d1324c
c010b360:	e8 29 fc ff ff       	call   c010af8e <panick>
c010b365:	83 c4 10             	add    $0x10,%esp
c010b368:	e9 70 ff ff ff       	jmp    c010b2dd <alloc_process+0x36>
        sched_ctx.ptable_len++;
c010b36d:	83 c0 01             	add    $0x1,%eax
c010b370:	a3 68 04 d1 c0       	mov    %eax,0xc0d10468
c010b375:	e9 70 ff ff ff       	jmp    c010b2ea <alloc_process+0x43>

c010b37a <commit_process>:

void
commit_process(struct proc_info* process)
{
c010b37a:	55                   	push   %ebp
c010b37b:	89 e5                	mov    %esp,%ebp
c010b37d:	56                   	push   %esi
c010b37e:	53                   	push   %ebx
c010b37f:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(process == &sched_ctx._procs[process->pid]);
c010b382:	8b 0d 60 04 d1 c0    	mov    0xc0d10460,%ecx
c010b388:	69 10 0c 01 00 00    	imul   $0x10c,(%eax),%edx
c010b38e:	01 ca                	add    %ecx,%edx
c010b390:	39 c2                	cmp    %eax,%edx
c010b392:	75 1f                	jne    c010b3b3 <commit_process+0x39>

    if (process->state != PS_CREATED) {
c010b394:	80 b8 ac 00 00 00 10 	cmpb   $0x10,0xac(%eax)
c010b39b:	74 2d                	je     c010b3ca <commit_process+0x50>
        __current->k_status = LXINVL;
c010b39d:	a1 8c 05 d1 c0       	mov    0xc0d1058c,%eax
c010b3a2:	c7 80 b4 00 00 00 fa 	movl   $0xfffffffa,0xb4(%eax)
c010b3a9:	ff ff ff 
    }

    llist_append(&process->parent->children, &process->siblings);

    process->state = PS_STOPPED;
}
c010b3ac:	8d 65 f8             	lea    -0x8(%ebp),%esp
c010b3af:	5b                   	pop    %ebx
c010b3b0:	5e                   	pop    %esi
c010b3b1:	5d                   	pop    %ebp
c010b3b2:	c3                   	ret    
    assert(process == &sched_ctx._procs[process->pid]);
c010b3b3:	83 ec 04             	sub    $0x4,%esp
c010b3b6:	68 17 01 00 00       	push   $0x117
c010b3bb:	68 68 32 d1 c0       	push   $0xc0d13268
c010b3c0:	68 f0 35 d1 c0       	push   $0xc0d135f0
c010b3c5:	e8 99 fb ff ff       	call   c010af63 <__assert_fail>
    if (!process->parent) {
c010b3ca:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c010b3ce:	74 20                	je     c010b3f0 <commit_process+0x76>
    llist_append(&process->parent->children, &process->siblings);
c010b3d0:	8d 48 5c             	lea    0x5c(%eax),%ecx
c010b3d3:	8b 50 04             	mov    0x4(%eax),%edx
c010b3d6:	8d 72 64             	lea    0x64(%edx),%esi
    __llist_add(elem, head, head->next);
c010b3d9:	8b 5a 68             	mov    0x68(%edx),%ebx
    next->prev = elem;
c010b3dc:	89 0b                	mov    %ecx,(%ebx)
    elem->next = next;
c010b3de:	89 58 60             	mov    %ebx,0x60(%eax)
    elem->prev = prev;
c010b3e1:	89 70 5c             	mov    %esi,0x5c(%eax)
    prev->next = elem;
c010b3e4:	89 4a 68             	mov    %ecx,0x68(%edx)
    process->state = PS_STOPPED;
c010b3e7:	c6 80 ac 00 00 00 00 	movb   $0x0,0xac(%eax)
c010b3ee:	eb bc                	jmp    c010b3ac <commit_process+0x32>
        process->parent = &sched_ctx._procs[1];
c010b3f0:	81 c1 0c 01 00 00    	add    $0x10c,%ecx
c010b3f6:	89 48 04             	mov    %ecx,0x4(%eax)
c010b3f9:	eb d5                	jmp    c010b3d0 <commit_process+0x56>

c010b3fb <destroy_process>:
extern void
__del_pagetable(pid_t pid, uintptr_t mount_point);

pid_t
destroy_process(pid_t pid)
{
c010b3fb:	55                   	push   %ebp
c010b3fc:	89 e5                	mov    %esp,%ebp
c010b3fe:	57                   	push   %edi
c010b3ff:	56                   	push   %esi
c010b400:	53                   	push   %ebx
c010b401:	83 ec 0c             	sub    $0xc,%esp
c010b404:	8b 7d 08             	mov    0x8(%ebp),%edi
    int index = pid;
    if (index <= 0 || index > sched_ctx.ptable_len) {
c010b407:	85 ff                	test   %edi,%edi
c010b409:	7e 3d                	jle    c010b448 <destroy_process+0x4d>
c010b40b:	39 3d 68 04 d1 c0    	cmp    %edi,0xc0d10468
c010b411:	72 35                	jb     c010b448 <destroy_process+0x4d>
        __current->k_status = LXINVLDPID;
        return;
    }
    struct proc_info* proc = &sched_ctx._procs[index];
c010b413:	69 f7 0c 01 00 00    	imul   $0x10c,%edi,%esi
c010b419:	03 35 60 04 d1 c0    	add    0xc0d10460,%esi
    proc->state = PS_DESTROY;
c010b41f:	c6 86 ac 00 00 00 04 	movb   $0x4,0xac(%esi)
    llist_delete(&proc->siblings);
c010b426:	8d 46 5c             	lea    0x5c(%esi),%eax
    elem->prev->next = elem->next;
c010b429:	8b 4e 5c             	mov    0x5c(%esi),%ecx
c010b42c:	8b 56 60             	mov    0x60(%esi),%edx
c010b42f:	89 51 04             	mov    %edx,0x4(%ecx)
    elem->next->prev = elem->prev;
c010b432:	8b 4e 5c             	mov    0x5c(%esi),%ecx
c010b435:	89 0a                	mov    %ecx,(%edx)
    elem->prev = elem;
c010b437:	89 46 5c             	mov    %eax,0x5c(%esi)
    elem->next = elem;
c010b43a:	89 46 60             	mov    %eax,0x60(%esi)

    struct mm_region *pos, *n;
    llist_for_each(pos, n, &proc->mm.regions.head, head)
c010b43d:	8b 86 98 00 00 00    	mov    0x98(%esi),%eax
c010b443:	8b 58 04             	mov    0x4(%eax),%ebx
c010b446:	eb 28                	jmp    c010b470 <destroy_process+0x75>
        __current->k_status = LXINVLDPID;
c010b448:	a1 8c 05 d1 c0       	mov    0xc0d1058c,%eax
c010b44d:	c7 80 b4 00 00 00 fc 	movl   $0xfffffffc,0xb4(%eax)
c010b454:	ff ff ff 
    __del_pagetable(pid, PD_MOUNT_1);

    vmm_unmount_pd(PD_MOUNT_1);

    return pid;
}
c010b457:	8d 65 f4             	lea    -0xc(%ebp),%esp
c010b45a:	5b                   	pop    %ebx
c010b45b:	5e                   	pop    %esi
c010b45c:	5f                   	pop    %edi
c010b45d:	5d                   	pop    %ebp
c010b45e:	c3                   	ret    
        lxfree(pos);
c010b45f:	83 ec 0c             	sub    $0xc,%esp
c010b462:	50                   	push   %eax
c010b463:	e8 25 ec ff ff       	call   c010a08d <lxfree>
    llist_for_each(pos, n, &proc->mm.regions.head, head)
c010b468:	83 c4 10             	add    $0x10,%esp
c010b46b:	89 d8                	mov    %ebx,%eax
c010b46d:	8b 5b 04             	mov    0x4(%ebx),%ebx
c010b470:	8d 96 94 00 00 00    	lea    0x94(%esi),%edx
c010b476:	39 d0                	cmp    %edx,%eax
c010b478:	75 e5                	jne    c010b45f <destroy_process+0x64>
    vmm_mount_pd(PD_MOUNT_1, proc->page_table);
c010b47a:	83 ec 08             	sub    $0x8,%esp
c010b47d:	ff 76 58             	push   0x58(%esi)
c010b480:	68 00 00 00 d1       	push   $0xd1000000
c010b485:	e8 a1 f1 ff ff       	call   c010a62b <vmm_mount_pd>
    __del_pagetable(pid, PD_MOUNT_1);
c010b48a:	83 c4 08             	add    $0x8,%esp
c010b48d:	68 00 00 00 d1       	push   $0xd1000000
c010b492:	57                   	push   %edi
c010b493:	e8 5b 21 00 00       	call   c010d5f3 <__del_pagetable>
    vmm_unmount_pd(PD_MOUNT_1);
c010b498:	c7 04 24 00 00 00 d1 	movl   $0xd1000000,(%esp)
c010b49f:	e8 ab f1 ff ff       	call   c010a64f <vmm_unmount_pd>
    return pid;
c010b4a4:	89 f8                	mov    %edi,%eax
c010b4a6:	eb af                	jmp    c010b457 <destroy_process+0x5c>

c010b4a8 <_wait>:
{
c010b4a8:	55                   	push   %ebp
c010b4a9:	89 e5                	mov    %esp,%ebp
c010b4ab:	57                   	push   %edi
c010b4ac:	56                   	push   %esi
c010b4ad:	53                   	push   %ebx
c010b4ae:	83 ec 0c             	sub    $0xc,%esp
c010b4b1:	8b 5d 08             	mov    0x8(%ebp),%ebx
    pid_t cur = __current->pid;
c010b4b4:	a1 8c 05 d1 c0       	mov    0xc0d1058c,%eax
c010b4b9:	8b 10                	mov    (%eax),%edx
    if (llist_empty(&__current->children)) {
c010b4bb:	8d 50 64             	lea    0x64(%eax),%edx
    return elem->next == elem && elem->prev == elem;
c010b4be:	3b 50 68             	cmp    0x68(%eax),%edx
c010b4c1:	74 0f                	je     c010b4d2 <_wait+0x2a>
    wpid = wpid ? wpid : -__current->pgid;
c010b4c3:	85 db                	test   %ebx,%ebx
c010b4c5:	75 08                	jne    c010b4cf <_wait+0x27>
c010b4c7:	8b 98 08 01 00 00    	mov    0x108(%eax),%ebx
c010b4cd:	f7 db                	neg    %ebx
    asm volatile("sti");
c010b4cf:	fb                   	sti    
}
c010b4d0:	eb 64                	jmp    c010b536 <_wait+0x8e>
c010b4d2:	3b 50 64             	cmp    0x64(%eax),%edx
c010b4d5:	75 ec                	jne    c010b4c3 <_wait+0x1b>
        return -1;
c010b4d7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c010b4dc:	e9 97 00 00 00       	jmp    c010b578 <_wait+0xd0>
            if (proc->state == PS_TERMNAT && !options) {
c010b4e1:	0f b6 88 ac 00 00 00 	movzbl 0xac(%eax),%ecx
c010b4e8:	80 f9 02             	cmp    $0x2,%cl
c010b4eb:	74 31                	je     c010b51e <_wait+0x76>
            if (proc->state == PS_STOPPED && (options & WUNTRACED)) {
c010b4ed:	84 c9                	test   %cl,%cl
c010b4ef:	75 06                	jne    c010b4f7 <_wait+0x4f>
c010b4f1:	f6 45 10 02          	testb  $0x2,0x10(%ebp)
c010b4f5:	75 53                	jne    c010b54a <_wait+0xa2>
    llist_for_each(proc, n, &__current->children, siblings)
c010b4f7:	8b 4a 60             	mov    0x60(%edx),%ecx
c010b4fa:	89 d0                	mov    %edx,%eax
c010b4fc:	8d 51 a4             	lea    -0x5c(%ecx),%edx
c010b4ff:	8d 70 5c             	lea    0x5c(%eax),%esi
c010b502:	8d 4f 64             	lea    0x64(%edi),%ecx
c010b505:	39 ce                	cmp    %ecx,%esi
c010b507:	74 22                	je     c010b52b <_wait+0x83>
        if (!~wpid || proc->pid == wpid || proc->pgid == -wpid) {
c010b509:	83 fb ff             	cmp    $0xffffffff,%ebx
c010b50c:	74 d3                	je     c010b4e1 <_wait+0x39>
c010b50e:	39 18                	cmp    %ebx,(%eax)
c010b510:	74 cf                	je     c010b4e1 <_wait+0x39>
c010b512:	89 de                	mov    %ebx,%esi
c010b514:	03 b0 08 01 00 00    	add    0x108(%eax),%esi
c010b51a:	75 db                	jne    c010b4f7 <_wait+0x4f>
c010b51c:	eb c3                	jmp    c010b4e1 <_wait+0x39>
            if (proc->state == PS_TERMNAT && !options) {
c010b51e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c010b522:	75 c9                	jne    c010b4ed <_wait+0x45>
                status_flags |= PEXITTERM;
c010b524:	ba 00 01 00 00       	mov    $0x100,%edx
c010b529:	eb 24                	jmp    c010b54f <_wait+0xa7>
    if ((options & WNOHANG)) {
c010b52b:	f6 45 10 01          	testb  $0x1,0x10(%ebp)
c010b52f:	75 56                	jne    c010b587 <_wait+0xdf>
    sched_yield();
c010b531:	e8 30 0a 00 00       	call   c010bf66 <sched_yield>
    llist_for_each(proc, n, &__current->children, siblings)
c010b536:	8b 3d 8c 05 d1 c0    	mov    0xc0d1058c,%edi
c010b53c:	8b 57 68             	mov    0x68(%edi),%edx
c010b53f:	8d 42 a4             	lea    -0x5c(%edx),%eax
c010b542:	8b 52 04             	mov    0x4(%edx),%edx
c010b545:	83 ea 5c             	sub    $0x5c,%edx
c010b548:	eb b5                	jmp    c010b4ff <_wait+0x57>
                status_flags |= PEXITSTOP;
c010b54a:	ba 00 02 00 00       	mov    $0x200,%edx
    asm volatile("cli");
c010b54f:	fa                   	cli    
    status_flags |= PEXITSIG * (proc->sig_inprogress != 0);
c010b550:	83 b8 c0 00 00 00 00 	cmpl   $0x0,0xc0(%eax)
c010b557:	74 27                	je     c010b580 <_wait+0xd8>
c010b559:	b9 00 04 00 00       	mov    $0x400,%ecx
c010b55e:	09 ca                	or     %ecx,%edx
    *status = proc->exit_code | status_flags;
c010b560:	0b 90 b0 00 00 00    	or     0xb0(%eax),%edx
c010b566:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c010b569:	89 11                	mov    %edx,(%ecx)
    return destroy_process(proc->pid);
c010b56b:	83 ec 0c             	sub    $0xc,%esp
c010b56e:	ff 30                	push   (%eax)
c010b570:	e8 86 fe ff ff       	call   c010b3fb <destroy_process>
c010b575:	83 c4 10             	add    $0x10,%esp
}
c010b578:	8d 65 f4             	lea    -0xc(%ebp),%esp
c010b57b:	5b                   	pop    %ebx
c010b57c:	5e                   	pop    %esi
c010b57d:	5f                   	pop    %edi
c010b57e:	5d                   	pop    %ebp
c010b57f:	c3                   	ret    
    status_flags |= PEXITSIG * (proc->sig_inprogress != 0);
c010b580:	b9 00 00 00 00       	mov    $0x0,%ecx
c010b585:	eb d7                	jmp    c010b55e <_wait+0xb6>
        return 0;
c010b587:	b8 00 00 00 00       	mov    $0x0,%eax
c010b58c:	eb ea                	jmp    c010b578 <_wait+0xd0>

c010b58e <__lxsys_wait>:
{
c010b58e:	55                   	push   %ebp
c010b58f:	89 e5                	mov    %esp,%ebp
c010b591:	83 ec 0c             	sub    $0xc,%esp
    return _wait(-1, status, 0);
c010b594:	6a 00                	push   $0x0
c010b596:	ff 75 08             	push   0x8(%ebp)
c010b599:	6a ff                	push   $0xffffffff
c010b59b:	e8 08 ff ff ff       	call   c010b4a8 <_wait>
}
c010b5a0:	c9                   	leave  
c010b5a1:	c3                   	ret    

c010b5a2 <__lxsys_waitpid>:
{
c010b5a2:	55                   	push   %ebp
c010b5a3:	89 e5                	mov    %esp,%ebp
c010b5a5:	83 ec 0c             	sub    $0xc,%esp
    return _wait(pid, status, options);
c010b5a8:	ff 75 10             	push   0x10(%ebp)
c010b5ab:	ff 75 0c             	push   0xc(%ebp)
c010b5ae:	ff 75 08             	push   0x8(%ebp)
c010b5b1:	e8 f2 fe ff ff       	call   c010b4a8 <_wait>
}
c010b5b6:	c9                   	leave  
c010b5b7:	c3                   	ret    

c010b5b8 <terminate_proc>:

void
terminate_proc(int exit_code)
{
c010b5b8:	55                   	push   %ebp
c010b5b9:	89 e5                	mov    %esp,%ebp
    __current->state = PS_TERMNAT;
c010b5bb:	a1 8c 05 d1 c0       	mov    0xc0d1058c,%eax
c010b5c0:	c6 80 ac 00 00 00 02 	movb   $0x2,0xac(%eax)
    __current->exit_code = exit_code;
c010b5c7:	8b 55 08             	mov    0x8(%ebp),%edx
c010b5ca:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)

    __SIGSET(__current->parent->sig_pending, _SIGCHLD);
c010b5d0:	8b 50 04             	mov    0x4(%eax),%edx
c010b5d3:	8b 92 b8 00 00 00    	mov    0xb8(%edx),%edx
c010b5d9:	8b 48 04             	mov    0x4(%eax),%ecx
c010b5dc:	89 d0                	mov    %edx,%eax
c010b5de:	83 c8 08             	or     $0x8,%eax
c010b5e1:	89 81 b8 00 00 00    	mov    %eax,0xb8(%ecx)
}
c010b5e7:	5d                   	pop    %ebp
c010b5e8:	c3                   	ret    

c010b5e9 <__lxsys_exit>:
{
c010b5e9:	55                   	push   %ebp
c010b5ea:	89 e5                	mov    %esp,%ebp
c010b5ec:	83 ec 14             	sub    $0x14,%esp
    terminate_proc(status);
c010b5ef:	ff 75 08             	push   0x8(%ebp)
c010b5f2:	e8 c1 ff ff ff       	call   c010b5b8 <terminate_proc>
    schedule();
c010b5f7:	e8 08 fb ff ff       	call   c010b104 <schedule>
}
c010b5fc:	83 c4 10             	add    $0x10,%esp
c010b5ff:	c9                   	leave  
c010b600:	c3                   	ret    

c010b601 <get_process>:

struct proc_info*
get_process(pid_t pid)
{
c010b601:	55                   	push   %ebp
c010b602:	89 e5                	mov    %esp,%ebp
c010b604:	8b 45 08             	mov    0x8(%ebp),%eax
    int index = pid;
    if (index < 0 || index > sched_ctx.ptable_len) {
c010b607:	85 c0                	test   %eax,%eax
c010b609:	78 16                	js     c010b621 <get_process+0x20>
c010b60b:	39 05 68 04 d1 c0    	cmp    %eax,0xc0d10468
c010b611:	72 15                	jb     c010b628 <get_process+0x27>
        return NULL;
    }
    return &sched_ctx._procs[index];
c010b613:	69 c0 0c 01 00 00    	imul   $0x10c,%eax,%eax
c010b619:	03 05 60 04 d1 c0    	add    0xc0d10460,%eax
}
c010b61f:	5d                   	pop    %ebp
c010b620:	c3                   	ret    
        return NULL;
c010b621:	b8 00 00 00 00       	mov    $0x0,%eax
c010b626:	eb f7                	jmp    c010b61f <get_process+0x1e>
c010b628:	b8 00 00 00 00       	mov    $0x0,%eax
c010b62d:	eb f0                	jmp    c010b61f <get_process+0x1e>

c010b62f <orphaned_proc>:

int
orphaned_proc(pid_t pid)
{
c010b62f:	55                   	push   %ebp
c010b630:	89 e5                	mov    %esp,%ebp
c010b632:	8b 45 08             	mov    0x8(%ebp),%eax
    if (!pid)
c010b635:	85 c0                	test   %eax,%eax
c010b637:	74 3a                	je     c010b673 <orphaned_proc+0x44>
        return 0;
    if (pid >= sched_ctx.ptable_len)
c010b639:	39 05 68 04 d1 c0    	cmp    %eax,0xc0d10468
c010b63f:	76 2d                	jbe    c010b66e <orphaned_proc+0x3f>
        return 0;
    struct proc_info* proc = &sched_ctx._procs[pid];
c010b641:	69 c0 0c 01 00 00    	imul   $0x10c,%eax,%eax
c010b647:	03 05 60 04 d1 c0    	add    0xc0d10460,%eax
    struct proc_info* parent = proc->parent;
c010b64d:	8b 50 04             	mov    0x4(%eax),%edx

    // 如果其父进程的状态是terminated 或 destroy中的一种
    // 或者其父进程是在该进程之后创建的，那么该进程为孤儿进程
    return PROC_TERMINATED(parent->state) || parent->created > proc->created;
c010b650:	f6 82 ac 00 00 00 06 	testb  $0x6,0xac(%edx)
c010b657:	75 1c                	jne    c010b675 <orphaned_proc+0x46>
c010b659:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
c010b65f:	39 82 a8 00 00 00    	cmp    %eax,0xa8(%edx)
c010b665:	76 15                	jbe    c010b67c <orphaned_proc+0x4d>
c010b667:	b8 01 00 00 00       	mov    $0x1,%eax
c010b66c:	eb 05                	jmp    c010b673 <orphaned_proc+0x44>
        return 0;
c010b66e:	b8 00 00 00 00       	mov    $0x0,%eax
c010b673:	5d                   	pop    %ebp
c010b674:	c3                   	ret    
    return PROC_TERMINATED(parent->state) || parent->created > proc->created;
c010b675:	b8 01 00 00 00       	mov    $0x1,%eax
c010b67a:	eb f7                	jmp    c010b673 <orphaned_proc+0x44>
c010b67c:	b8 00 00 00 00       	mov    $0x0,%eax
c010b681:	eb f0                	jmp    c010b673 <orphaned_proc+0x44>

c010b683 <sem_init>:
#include <lunaix/ds/semaphore.h>
#include <lunaix/sched.h>

void
sem_init(struct sem_t* sem, unsigned int initial)
{
c010b683:	55                   	push   %ebp
c010b684:	89 e5                	mov    %esp,%ebp
c010b686:	8b 55 08             	mov    0x8(%ebp),%edx
    sem->counter = ATOMIC_VAR_INIT(initial);
c010b689:	8b 45 0c             	mov    0xc(%ebp),%eax
c010b68c:	87 02                	xchg   %eax,(%edx)
}
c010b68e:	5d                   	pop    %ebp
c010b68f:	c3                   	ret    

c010b690 <sem_wait>:

void
sem_wait(struct sem_t* sem)
{
c010b690:	55                   	push   %ebp
c010b691:	89 e5                	mov    %esp,%ebp
c010b693:	8b 55 08             	mov    0x8(%ebp),%edx
    while (!atomic_load(&sem->counter)) {
c010b696:	8b 02                	mov    (%edx),%eax
c010b698:	85 c0                	test   %eax,%eax
c010b69a:	74 fa                	je     c010b696 <sem_wait+0x6>
        // FIXME: better thing like wait queue
    }
    atomic_fetch_sub(&sem->counter, 1);
c010b69c:	f0 83 2a 01          	lock subl $0x1,(%edx)
}
c010b6a0:	5d                   	pop    %ebp
c010b6a1:	c3                   	ret    

c010b6a2 <sem_post>:

void
sem_post(struct sem_t* sem)
{
c010b6a2:	55                   	push   %ebp
c010b6a3:	89 e5                	mov    %esp,%ebp
c010b6a5:	8b 45 08             	mov    0x8(%ebp),%eax
    atomic_fetch_add(&sem->counter, 1);
c010b6a8:	f0 83 00 01          	lock addl $0x1,(%eax)
    // TODO: wake up a thread
c010b6ac:	5d                   	pop    %ebp
c010b6ad:	c3                   	ret    

c010b6ae <_exit>:

__LXSYSCALL(pid_t, getpid)

__LXSYSCALL(pid_t, getppid)

__LXSYSCALL1(void, _exit, int, status)
c010b6ae:	55                   	push   %ebp
c010b6af:	89 e5                	mov    %esp,%ebp
c010b6b1:	53                   	push   %ebx
c010b6b2:	89 c3                	mov    %eax,%ebx
c010b6b4:	b8 08 00 00 00       	mov    $0x8,%eax
c010b6b9:	cd 21                	int    $0x21
c010b6bb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c010b6be:	c9                   	leave  
c010b6bf:	c3                   	ret    

c010b6c0 <signal_dispatch>:
};

// Referenced in kernel/asm/x86/interrupt.S
void*
signal_dispatch()
{
c010b6c0:	55                   	push   %ebp
c010b6c1:	89 e5                	mov    %esp,%ebp
c010b6c3:	57                   	push   %edi
c010b6c4:	56                   	push   %esi
c010b6c5:	53                   	push   %ebx
c010b6c6:	83 ec 0c             	sub    $0xc,%esp
    if (!__current->sig_pending) {
c010b6c9:	a1 8c 05 d1 c0       	mov    0xc0d1058c,%eax
c010b6ce:	8b 90 b8 00 00 00    	mov    0xb8(%eax),%edx
c010b6d4:	85 d2                	test   %edx,%edx
c010b6d6:	0f 84 cf 00 00 00    	je     c010b7ab <signal_dispatch+0xeb>
        // 没有待处理信号
        return 0;
    }

    int sig_selected =
      31 - __builtin_clz(__current->sig_pending &
c010b6dc:	8b 88 b8 00 00 00    	mov    0xb8(%eax),%ecx
                         ~(__current->sig_mask | __current->sig_inprogress));
c010b6e2:	8b 90 bc 00 00 00    	mov    0xbc(%eax),%edx
c010b6e8:	8b 98 c0 00 00 00    	mov    0xc0(%eax),%ebx
c010b6ee:	09 da                	or     %ebx,%edx
c010b6f0:	f7 d2                	not    %edx
      31 - __builtin_clz(__current->sig_pending &
c010b6f2:	21 d1                	and    %edx,%ecx
c010b6f4:	0f bd c9             	bsr    %ecx,%ecx
c010b6f7:	83 f1 1f             	xor    $0x1f,%ecx
    int sig_selected =
c010b6fa:	ba 1f 00 00 00       	mov    $0x1f,%edx
c010b6ff:	29 ca                	sub    %ecx,%edx

    __SIGCLEAR(__current->sig_pending, sig_selected);
c010b701:	8b 98 b8 00 00 00    	mov    0xb8(%eax),%ebx
c010b707:	be 01 00 00 00       	mov    $0x1,%esi
c010b70c:	89 d1                	mov    %edx,%ecx
c010b70e:	d3 e6                	shl    %cl,%esi
c010b710:	89 75 ec             	mov    %esi,-0x14(%ebp)
c010b713:	89 f1                	mov    %esi,%ecx
c010b715:	f7 d1                	not    %ecx
c010b717:	21 cb                	and    %ecx,%ebx
c010b719:	89 98 b8 00 00 00    	mov    %ebx,0xb8(%eax)

    if (sig_selected == 0) {
c010b71f:	85 d2                	test   %edx,%edx
c010b721:	0f 84 8d 00 00 00    	je     c010b7b4 <signal_dispatch+0xf4>
        // SIG0 is reserved
        return 0;
    }

    if (!__current->sig_handler[sig_selected] &&
c010b727:	8d 4a 30             	lea    0x30(%edx),%ecx
c010b72a:	8b 4c 88 08          	mov    0x8(%eax,%ecx,4),%ecx
c010b72e:	85 c9                	test   %ecx,%ecx
c010b730:	74 5d                	je     c010b78f <signal_dispatch+0xcf>
        !default_handlers[sig_selected]) {
        // 如果该信号没有handler，则忽略
        return 0;
    }

    uintptr_t ustack = __current->ustack_top & ~0xf;
c010b732:	8b 48 54             	mov    0x54(%eax),%ecx
c010b735:	89 cb                	mov    %ecx,%ebx
c010b737:	83 e3 f0             	and    $0xfffffff0,%ebx

    if ((int)(ustack - USTACK_END) < (int)sizeof(struct proc_sig)) {
c010b73a:	8d 8b 00 00 10 60    	lea    0x60100000(%ebx),%ecx
c010b740:	83 f9 53             	cmp    $0x53,%ecx
c010b743:	7e 78                	jle    c010b7bd <signal_dispatch+0xfd>
        // 用户栈没有空间存放信号上下文
        return 0;
    }

    struct proc_sig* sig_ctx =
      (struct proc_sig*)(ustack - sizeof(struct proc_sig));
c010b745:	8d 7b ac             	lea    -0x54(%ebx),%edi
    struct proc_sig* sig_ctx =
c010b748:	89 7d e8             	mov    %edi,-0x18(%ebp)
c010b74b:	89 7d f0             	mov    %edi,-0x10(%ebp)

    sig_ctx->prev_context = __current->intr_ctx;
c010b74e:	8d 7b b4             	lea    -0x4c(%ebx),%edi
c010b751:	8d 70 08             	lea    0x8(%eax),%esi
c010b754:	b9 13 00 00 00       	mov    $0x13,%ecx
c010b759:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    sig_ctx->sig_num = sig_selected;
c010b75b:	8b 7d e8             	mov    -0x18(%ebp),%edi
c010b75e:	89 57 04             	mov    %edx,0x4(%edi)
    sig_ctx->signal_handler = __current->sig_handler[sig_selected];
c010b761:	8d 4a 30             	lea    0x30(%edx),%ecx
c010b764:	8b 44 88 08          	mov    0x8(%eax,%ecx,4),%eax
c010b768:	89 43 ac             	mov    %eax,-0x54(%ebx)

    if (!sig_ctx->signal_handler) {
c010b76b:	85 c0                	test   %eax,%eax
c010b76d:	74 30                	je     c010b79f <signal_dispatch+0xdf>
        // 如果没有用户自定义的Handler，则使用系统默认Handler。
        sig_ctx->signal_handler = default_handlers[sig_selected];
    }

    __SIGSET(__current->sig_inprogress, sig_selected);
c010b76f:	8b 15 8c 05 d1 c0    	mov    0xc0d1058c,%edx
c010b775:	8b 82 c0 00 00 00    	mov    0xc0(%edx),%eax
c010b77b:	0b 45 ec             	or     -0x14(%ebp),%eax
c010b77e:	89 82 c0 00 00 00    	mov    %eax,0xc0(%edx)

    return sig_ctx;
}
c010b784:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010b787:	83 c4 0c             	add    $0xc,%esp
c010b78a:	5b                   	pop    %ebx
c010b78b:	5e                   	pop    %esi
c010b78c:	5f                   	pop    %edi
c010b78d:	5d                   	pop    %ebp
c010b78e:	c3                   	ret    
        !default_handlers[sig_selected]) {
c010b78f:	8b 3c 95 20 20 d1 c0 	mov    -0x3f2edfe0(,%edx,4),%edi
c010b796:	89 7d f0             	mov    %edi,-0x10(%ebp)
    if (!__current->sig_handler[sig_selected] &&
c010b799:	85 ff                	test   %edi,%edi
c010b79b:	75 95                	jne    c010b732 <signal_dispatch+0x72>
c010b79d:	eb e5                	jmp    c010b784 <signal_dispatch+0xc4>
        sig_ctx->signal_handler = default_handlers[sig_selected];
c010b79f:	8b 04 95 20 20 d1 c0 	mov    -0x3f2edfe0(,%edx,4),%eax
c010b7a6:	89 43 ac             	mov    %eax,-0x54(%ebx)
c010b7a9:	eb c4                	jmp    c010b76f <signal_dispatch+0xaf>
        return 0;
c010b7ab:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c010b7b2:	eb d0                	jmp    c010b784 <signal_dispatch+0xc4>
        return 0;
c010b7b4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c010b7bb:	eb c7                	jmp    c010b784 <signal_dispatch+0xc4>
        return 0;
c010b7bd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c010b7c4:	eb be                	jmp    c010b784 <signal_dispatch+0xc4>

c010b7c6 <signal_send>:

int
signal_send(pid_t pid, int signum)
{
c010b7c6:	55                   	push   %ebp
c010b7c7:	89 e5                	mov    %esp,%ebp
c010b7c9:	57                   	push   %edi
c010b7ca:	56                   	push   %esi
c010b7cb:	53                   	push   %ebx
c010b7cc:	83 ec 0c             	sub    $0xc,%esp
c010b7cf:	8b 45 08             	mov    0x8(%ebp),%eax
c010b7d2:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    if (signum < 0 || signum >= _SIG_NUM) {
c010b7d5:	83 fb 0f             	cmp    $0xf,%ebx
c010b7d8:	77 29                	ja     c010b803 <signal_send+0x3d>
        __current->k_status = LXINVL;
        return -1;
    }

    struct proc_info* proc;
    if (pid > 0) {
c010b7da:	85 c0                	test   %eax,%eax
c010b7dc:	7f 3b                	jg     c010b819 <signal_send+0x53>
        proc = get_process(pid);
        goto send_single;
    } else if (!pid) {
c010b7de:	74 64                	je     c010b844 <signal_send+0x7e>
        proc = __current;
        goto send_grp;
    } else if (pid < -1) {
c010b7e0:	83 f8 ff             	cmp    $0xffffffff,%eax
c010b7e3:	7d 67                	jge    c010b84c <signal_send+0x86>
        proc = get_process(-pid);
c010b7e5:	83 ec 0c             	sub    $0xc,%esp
c010b7e8:	f7 d8                	neg    %eax
c010b7ea:	50                   	push   %eax
c010b7eb:	e8 11 fe ff ff       	call   c010b601 <get_process>
c010b7f0:	89 c7                	mov    %eax,%edi
        goto send_grp;
c010b7f2:	83 c4 10             	add    $0x10,%esp
        return -1;
    }

send_grp:
    struct proc_info *pos, *n;
    llist_for_each(pos, n, &proc->grp_member, grp_member)
c010b7f5:	8b 57 70             	mov    0x70(%edi),%edx
c010b7f8:	8d 42 94             	lea    -0x6c(%edx),%eax
c010b7fb:	8b 72 04             	mov    0x4(%edx),%esi
c010b7fe:	83 ee 6c             	sub    $0x6c,%esi
c010b801:	eb 76                	jmp    c010b879 <signal_send+0xb3>
        __current->k_status = LXINVL;
c010b803:	a1 8c 05 d1 c0       	mov    0xc0d1058c,%eax
c010b808:	c7 80 b4 00 00 00 fa 	movl   $0xfffffffa,0xb4(%eax)
c010b80f:	ff ff ff 
        return -1;
c010b812:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c010b817:	eb 69                	jmp    c010b882 <signal_send+0xbc>
        proc = get_process(pid);
c010b819:	83 ec 0c             	sub    $0xc,%esp
c010b81c:	50                   	push   %eax
c010b81d:	e8 df fd ff ff       	call   c010b601 <get_process>
        __SIGSET(pos->sig_pending, signum);
    }
    return 0;

send_single:
    if (PROC_TERMINATED(proc->state)) {
c010b822:	83 c4 10             	add    $0x10,%esp
c010b825:	f6 80 ac 00 00 00 06 	testb  $0x6,0xac(%eax)
c010b82c:	75 5c                	jne    c010b88a <signal_send+0xc4>
        __current->k_status = LXINVL;
        return -1;
    }
    __SIGSET(proc->sig_pending, signum);
c010b82e:	ba 01 00 00 00       	mov    $0x1,%edx
c010b833:	89 d9                	mov    %ebx,%ecx
c010b835:	d3 e2                	shl    %cl,%edx
c010b837:	09 90 b8 00 00 00    	or     %edx,0xb8(%eax)
    return 0;
c010b83d:	b8 00 00 00 00       	mov    $0x0,%eax
c010b842:	eb 3e                	jmp    c010b882 <signal_send+0xbc>
        proc = __current;
c010b844:	8b 3d 8c 05 d1 c0    	mov    0xc0d1058c,%edi
        goto send_grp;
c010b84a:	eb a9                	jmp    c010b7f5 <signal_send+0x2f>
        __current->k_status = LXINVL;
c010b84c:	a1 8c 05 d1 c0       	mov    0xc0d1058c,%eax
c010b851:	c7 80 b4 00 00 00 fa 	movl   $0xfffffffa,0xb4(%eax)
c010b858:	ff ff ff 
        return -1;
c010b85b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c010b860:	eb 20                	jmp    c010b882 <signal_send+0xbc>
        __SIGSET(pos->sig_pending, signum);
c010b862:	ba 01 00 00 00       	mov    $0x1,%edx
c010b867:	89 d9                	mov    %ebx,%ecx
c010b869:	d3 e2                	shl    %cl,%edx
c010b86b:	09 90 b8 00 00 00    	or     %edx,0xb8(%eax)
    llist_for_each(pos, n, &proc->grp_member, grp_member)
c010b871:	8b 56 70             	mov    0x70(%esi),%edx
c010b874:	89 f0                	mov    %esi,%eax
c010b876:	8d 72 94             	lea    -0x6c(%edx),%esi
c010b879:	39 c7                	cmp    %eax,%edi
c010b87b:	75 e5                	jne    c010b862 <signal_send+0x9c>
    return 0;
c010b87d:	b8 00 00 00 00       	mov    $0x0,%eax
}
c010b882:	8d 65 f4             	lea    -0xc(%ebp),%esp
c010b885:	5b                   	pop    %ebx
c010b886:	5e                   	pop    %esi
c010b887:	5f                   	pop    %edi
c010b888:	5d                   	pop    %ebp
c010b889:	c3                   	ret    
        __current->k_status = LXINVL;
c010b88a:	a1 8c 05 d1 c0       	mov    0xc0d1058c,%eax
c010b88f:	c7 80 b4 00 00 00 fa 	movl   $0xfffffffa,0xb4(%eax)
c010b896:	ff ff ff 
        return -1;
c010b899:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c010b89e:	eb e2                	jmp    c010b882 <signal_send+0xbc>

c010b8a0 <__lxsys_sigreturn>:

__DEFINE_LXSYSCALL1(int, sigreturn, struct proc_sig, *sig_ctx)
{
c010b8a0:	55                   	push   %ebp
c010b8a1:	89 e5                	mov    %esp,%ebp
c010b8a3:	57                   	push   %edi
c010b8a4:	56                   	push   %esi
c010b8a5:	53                   	push   %ebx
c010b8a6:	83 ec 0c             	sub    $0xc,%esp
c010b8a9:	8b 55 08             	mov    0x8(%ebp),%edx
    __current->intr_ctx = sig_ctx->prev_context;
c010b8ac:	a1 8c 05 d1 c0       	mov    0xc0d1058c,%eax
c010b8b1:	8d 78 08             	lea    0x8(%eax),%edi
c010b8b4:	8d 72 08             	lea    0x8(%edx),%esi
c010b8b7:	b9 13 00 00 00       	mov    $0x13,%ecx
c010b8bc:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    __current->flags &= ~PROC_FINPAUSE;
c010b8be:	8b 88 c4 00 00 00    	mov    0xc4(%eax),%ecx
c010b8c4:	83 e1 fe             	and    $0xfffffffe,%ecx
c010b8c7:	89 88 c4 00 00 00    	mov    %ecx,0xc4(%eax)
    __SIGCLEAR(__current->sig_inprogress, sig_ctx->sig_num);
c010b8cd:	8b 98 c0 00 00 00    	mov    0xc0(%eax),%ebx
c010b8d3:	8b 4a 04             	mov    0x4(%edx),%ecx
c010b8d6:	ba 01 00 00 00       	mov    $0x1,%edx
c010b8db:	d3 e2                	shl    %cl,%edx
c010b8dd:	f7 d2                	not    %edx
c010b8df:	21 d3                	and    %edx,%ebx
c010b8e1:	89 98 c0 00 00 00    	mov    %ebx,0xc0(%eax)
    schedule();
c010b8e7:	e8 18 f8 ff ff       	call   c010b104 <schedule>
}
c010b8ec:	83 c4 0c             	add    $0xc,%esp
c010b8ef:	5b                   	pop    %ebx
c010b8f0:	5e                   	pop    %esi
c010b8f1:	5f                   	pop    %edi
c010b8f2:	5d                   	pop    %ebp
c010b8f3:	c3                   	ret    

c010b8f4 <__lxsys_sigprocmask>:
                    how,
                    const sigset_t,
                    *set,
                    sigset_t,
                    *oldset)
{
c010b8f4:	55                   	push   %ebp
c010b8f5:	89 e5                	mov    %esp,%ebp
c010b8f7:	8b 45 08             	mov    0x8(%ebp),%eax
    *oldset = __current->sig_mask;
c010b8fa:	8b 15 8c 05 d1 c0    	mov    0xc0d1058c,%edx
c010b900:	8b 8a bc 00 00 00    	mov    0xbc(%edx),%ecx
c010b906:	8b 55 10             	mov    0x10(%ebp),%edx
c010b909:	89 0a                	mov    %ecx,(%edx)
    if (how == _SIG_BLOCK) {
c010b90b:	83 f8 01             	cmp    $0x1,%eax
c010b90e:	74 1c                	je     c010b92c <__lxsys_sigprocmask+0x38>
        __current->sig_mask |= *set;
    } else if (how == _SIG_UNBLOCK) {
c010b910:	83 f8 02             	cmp    $0x2,%eax
c010b913:	74 4a                	je     c010b95f <__lxsys_sigprocmask+0x6b>
        __current->sig_mask &= ~(*set);
    } else if (how == _SIG_SETMASK) {
c010b915:	83 f8 03             	cmp    $0x3,%eax
c010b918:	75 62                	jne    c010b97c <__lxsys_sigprocmask+0x88>
        __current->sig_mask = *set;
c010b91a:	8b 45 0c             	mov    0xc(%ebp),%eax
c010b91d:	8b 10                	mov    (%eax),%edx
c010b91f:	a1 8c 05 d1 c0       	mov    0xc0d1058c,%eax
c010b924:	89 90 bc 00 00 00    	mov    %edx,0xbc(%eax)
c010b92a:	eb 17                	jmp    c010b943 <__lxsys_sigprocmask+0x4f>
        __current->sig_mask |= *set;
c010b92c:	8b 15 8c 05 d1 c0    	mov    0xc0d1058c,%edx
c010b932:	8b 82 bc 00 00 00    	mov    0xbc(%edx),%eax
c010b938:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c010b93b:	0b 01                	or     (%ecx),%eax
c010b93d:	89 82 bc 00 00 00    	mov    %eax,0xbc(%edx)
    } else {
        return 0;
    }
    __current->sig_mask &= ~_SIGNAL_UNMASKABLE;
c010b943:	8b 15 8c 05 d1 c0    	mov    0xc0d1058c,%edx
c010b949:	8b 82 bc 00 00 00    	mov    0xbc(%edx),%eax
c010b94f:	83 e0 9f             	and    $0xffffff9f,%eax
c010b952:	89 82 bc 00 00 00    	mov    %eax,0xbc(%edx)
    return 1;
c010b958:	b8 01 00 00 00       	mov    $0x1,%eax
}
c010b95d:	5d                   	pop    %ebp
c010b95e:	c3                   	ret    
        __current->sig_mask &= ~(*set);
c010b95f:	8b 0d 8c 05 d1 c0    	mov    0xc0d1058c,%ecx
c010b965:	8b 81 bc 00 00 00    	mov    0xbc(%ecx),%eax
c010b96b:	8b 55 0c             	mov    0xc(%ebp),%edx
c010b96e:	8b 12                	mov    (%edx),%edx
c010b970:	f7 d2                	not    %edx
c010b972:	21 d0                	and    %edx,%eax
c010b974:	89 81 bc 00 00 00    	mov    %eax,0xbc(%ecx)
c010b97a:	eb c7                	jmp    c010b943 <__lxsys_sigprocmask+0x4f>
        return 0;
c010b97c:	b8 00 00 00 00       	mov    $0x0,%eax
c010b981:	eb da                	jmp    c010b95d <__lxsys_sigprocmask+0x69>

c010b983 <__lxsys_signal>:

__DEFINE_LXSYSCALL2(int, signal, int, signum, sighandler_t, handler)
{
c010b983:	55                   	push   %ebp
c010b984:	89 e5                	mov    %esp,%ebp
c010b986:	53                   	push   %ebx
c010b987:	8b 4d 08             	mov    0x8(%ebp),%ecx
    if (signum <= 0 || signum >= _SIG_NUM) {
c010b98a:	8d 41 ff             	lea    -0x1(%ecx),%eax
c010b98d:	83 f8 0e             	cmp    $0xe,%eax
c010b990:	77 21                	ja     c010b9b3 <__lxsys_signal+0x30>
        return -1;
    }

    if ((__SIGNAL(signum) & _SIGNAL_UNMASKABLE)) {
c010b992:	b8 60 00 00 00       	mov    $0x60,%eax
c010b997:	d3 f8                	sar    %cl,%eax
c010b999:	83 e0 01             	and    $0x1,%eax
c010b99c:	75 1c                	jne    c010b9ba <__lxsys_signal+0x37>
        return -1;
    }

    __current->sig_handler[signum] = (void*)handler;
c010b99e:	83 c1 30             	add    $0x30,%ecx
c010b9a1:	8b 15 8c 05 d1 c0    	mov    0xc0d1058c,%edx
c010b9a7:	8b 5d 0c             	mov    0xc(%ebp),%ebx
c010b9aa:	89 5c 8a 08          	mov    %ebx,0x8(%edx,%ecx,4)

    return 0;
}
c010b9ae:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c010b9b1:	c9                   	leave  
c010b9b2:	c3                   	ret    
        return -1;
c010b9b3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c010b9b8:	eb f4                	jmp    c010b9ae <__lxsys_signal+0x2b>
        return -1;
c010b9ba:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c010b9bf:	eb ed                	jmp    c010b9ae <__lxsys_signal+0x2b>

c010b9c1 <__lxsys_pause>:

__DEFINE_LXSYSCALL(int, pause)
{
c010b9c1:	55                   	push   %ebp
c010b9c2:	89 e5                	mov    %esp,%ebp
c010b9c4:	83 ec 08             	sub    $0x8,%esp
    __current->flags |= PROC_FINPAUSE;
c010b9c7:	8b 15 8c 05 d1 c0    	mov    0xc0d1058c,%edx
c010b9cd:	8b 82 c4 00 00 00    	mov    0xc4(%edx),%eax
c010b9d3:	83 c8 01             	or     $0x1,%eax
c010b9d6:	89 82 c4 00 00 00    	mov    %eax,0xc4(%edx)

    __SYSCALL_INTERRUPTIBLE({
c010b9dc:	fb                   	sti    
c010b9dd:	eb 05                	jmp    c010b9e4 <__lxsys_pause+0x23>
c010b9df:	e8 82 05 00 00       	call   c010bf66 <sched_yield>
c010b9e4:	a1 8c 05 d1 c0       	mov    0xc0d1058c,%eax
c010b9e9:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
c010b9ef:	a8 01                	test   $0x1,%al
c010b9f1:	75 ec                	jne    c010b9df <__lxsys_pause+0x1e>
c010b9f3:	fa                   	cli    
        while ((__current->flags & PROC_FINPAUSE)) {
            sched_yield();
        }
    })
    __current->k_status = EINTR;
c010b9f4:	a1 8c 05 d1 c0       	mov    0xc0d1058c,%eax
c010b9f9:	c7 80 b4 00 00 00 f9 	movl   $0xfffffff9,0xb4(%eax)
c010ba00:	ff ff ff 
    return -1;
}
c010ba03:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c010ba08:	c9                   	leave  
c010ba09:	c3                   	ret    

c010ba0a <__lxsys_kill>:

__DEFINE_LXSYSCALL2(int, kill, pid_t, pid, int, signum)
{
c010ba0a:	55                   	push   %ebp
c010ba0b:	89 e5                	mov    %esp,%ebp
c010ba0d:	83 ec 10             	sub    $0x10,%esp
    return signal_send(pid, signum);
c010ba10:	ff 75 0c             	push   0xc(%ebp)
c010ba13:	ff 75 08             	push   0x8(%ebp)
c010ba16:	e8 ab fd ff ff       	call   c010b7c6 <signal_send>
c010ba1b:	c9                   	leave  
c010ba1c:	c3                   	ret    

c010ba1d <clock_systime_counter>:
    // 系统计时器每毫秒累加。
    timer_run_ms(1, clock_systime_counter, NULL, TIMER_MODE_PERIODIC);
}

void clock_systime_counter(void* arg) {
    sys_time++;
c010ba1d:	a1 90 05 d1 c0       	mov    0xc0d10590,%eax
c010ba22:	83 c0 01             	add    $0x1,%eax
c010ba25:	a3 90 05 d1 c0       	mov    %eax,0xc0d10590
}
c010ba2a:	c3                   	ret    

c010ba2b <clock_init>:
clock_init() {
c010ba2b:	55                   	push   %ebp
c010ba2c:	89 e5                	mov    %esp,%ebp
c010ba2e:	83 ec 08             	sub    $0x8,%esp
    if (!timer_context()) {
c010ba31:	e8 3b 05 00 00       	call   c010bf71 <timer_context>
c010ba36:	85 c0                	test   %eax,%eax
c010ba38:	74 15                	je     c010ba4f <clock_init+0x24>
    timer_run_ms(1, clock_systime_counter, NULL, TIMER_MODE_PERIODIC);
c010ba3a:	6a 01                	push   $0x1
c010ba3c:	6a 00                	push   $0x0
c010ba3e:	68 1d ba 10 c0       	push   $0xc010ba1d
c010ba43:	6a 01                	push   $0x1
c010ba45:	e8 eb 04 00 00       	call   c010bf35 <timer_run_ms>
}
c010ba4a:	83 c4 10             	add    $0x10,%esp
c010ba4d:	c9                   	leave  
c010ba4e:	c3                   	ret    
        panick("Systimer not initialized");
c010ba4f:	83 ec 0c             	sub    $0xc,%esp
c010ba52:	68 77 32 d1 c0       	push   $0xc0d13277
c010ba57:	e8 32 f5 ff ff       	call   c010af8e <panick>
c010ba5c:	83 c4 10             	add    $0x10,%esp
c010ba5f:	eb d9                	jmp    c010ba3a <clock_init+0xf>

c010ba61 <clock_datatime_eq>:

int
clock_datatime_eq(datetime_t* a, datetime_t* b) {
c010ba61:	55                   	push   %ebp
c010ba62:	89 e5                	mov    %esp,%ebp
c010ba64:	8b 55 08             	mov    0x8(%ebp),%edx
c010ba67:	8b 45 0c             	mov    0xc(%ebp),%eax
    return a->year == b->year &&
           a->month == b->month &&
           a->day == b->day &&
           a->weekday == b->weekday &&
           a->minute == b->minute &&
c010ba6a:	8b 08                	mov    (%eax),%ecx
c010ba6c:	39 0a                	cmp    %ecx,(%edx)
c010ba6e:	74 07                	je     c010ba77 <clock_datatime_eq+0x16>
c010ba70:	b8 00 00 00 00       	mov    $0x0,%eax
           a->second == b->second;
}
c010ba75:	5d                   	pop    %ebp
c010ba76:	c3                   	ret    
           a->month == b->month &&
c010ba77:	0f b7 48 04          	movzwl 0x4(%eax),%ecx
c010ba7b:	66 39 4a 04          	cmp    %cx,0x4(%edx)
c010ba7f:	74 07                	je     c010ba88 <clock_datatime_eq+0x27>
           a->minute == b->minute &&
c010ba81:	b8 00 00 00 00       	mov    $0x0,%eax
c010ba86:	eb ed                	jmp    c010ba75 <clock_datatime_eq+0x14>
           a->day == b->day &&
c010ba88:	0f b6 48 06          	movzbl 0x6(%eax),%ecx
c010ba8c:	38 4a 06             	cmp    %cl,0x6(%edx)
c010ba8f:	74 07                	je     c010ba98 <clock_datatime_eq+0x37>
           a->minute == b->minute &&
c010ba91:	b8 00 00 00 00       	mov    $0x0,%eax
c010ba96:	eb dd                	jmp    c010ba75 <clock_datatime_eq+0x14>
c010ba98:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c010ba9c:	66 39 42 08          	cmp    %ax,0x8(%edx)
c010baa0:	74 07                	je     c010baa9 <clock_datatime_eq+0x48>
c010baa2:	b8 00 00 00 00       	mov    $0x0,%eax
c010baa7:	eb cc                	jmp    c010ba75 <clock_datatime_eq+0x14>
c010baa9:	b8 01 00 00 00       	mov    $0x1,%eax
c010baae:	eb c5                	jmp    c010ba75 <clock_datatime_eq+0x14>

c010bab0 <clock_walltime>:

void
clock_walltime(datetime_t* datetime)
{
c010bab0:	55                   	push   %ebp
c010bab1:	89 e5                	mov    %esp,%ebp
c010bab3:	56                   	push   %esi
c010bab4:	53                   	push   %ebx
c010bab5:	83 ec 10             	sub    $0x10,%esp
c010bab8:	8b 5d 08             	mov    0x8(%ebp),%ebx
    datetime_t current;
    
    do
    {
        while (rtc_read_reg(RTC_REG_A) & 0x80);
c010babb:	83 ec 0c             	sub    $0xc,%esp
c010babe:	6a 0a                	push   $0xa
c010bac0:	e8 0b 28 00 00       	call   c010e2d0 <rtc_read_reg>
c010bac5:	83 c4 10             	add    $0x10,%esp
c010bac8:	84 c0                	test   %al,%al
c010baca:	78 ef                	js     c010babb <clock_walltime+0xb>
        memcpy(&current, datetime, sizeof(datetime_t));
c010bacc:	83 ec 04             	sub    $0x4,%esp
c010bacf:	6a 0c                	push   $0xc
c010bad1:	53                   	push   %ebx
c010bad2:	8d 75 ec             	lea    -0x14(%ebp),%esi
c010bad5:	56                   	push   %esi
c010bad6:	e8 4d 31 00 00       	call   c010ec28 <memcpy>

        datetime->year = rtc_read_reg(RTC_REG_YRS);
c010badb:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
c010bae2:	e8 e9 27 00 00       	call   c010e2d0 <rtc_read_reg>
c010bae7:	0f b6 c0             	movzbl %al,%eax
c010baea:	89 03                	mov    %eax,(%ebx)
        datetime->month = rtc_read_reg(RTC_REG_MTH);
c010baec:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
c010baf3:	e8 d8 27 00 00       	call   c010e2d0 <rtc_read_reg>
c010baf8:	88 43 04             	mov    %al,0x4(%ebx)
        datetime->day = rtc_read_reg(RTC_REG_DAY);
c010bafb:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
c010bb02:	e8 c9 27 00 00       	call   c010e2d0 <rtc_read_reg>
c010bb07:	88 43 05             	mov    %al,0x5(%ebx)
        datetime->weekday = rtc_read_reg(RTC_REG_WDY);
c010bb0a:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
c010bb11:	e8 ba 27 00 00       	call   c010e2d0 <rtc_read_reg>
c010bb16:	88 43 06             	mov    %al,0x6(%ebx)
        datetime->hour = rtc_read_reg(RTC_REG_HRS);
c010bb19:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
c010bb20:	e8 ab 27 00 00       	call   c010e2d0 <rtc_read_reg>
c010bb25:	88 43 07             	mov    %al,0x7(%ebx)
        datetime->minute = rtc_read_reg(RTC_REG_MIN);
c010bb28:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
c010bb2f:	e8 9c 27 00 00       	call   c010e2d0 <rtc_read_reg>
c010bb34:	88 43 08             	mov    %al,0x8(%ebx)
        datetime->second = rtc_read_reg(RTC_REG_SEC);
c010bb37:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c010bb3e:	e8 8d 27 00 00       	call   c010e2d0 <rtc_read_reg>
c010bb43:	88 43 09             	mov    %al,0x9(%ebx)
    } while (!clock_datatime_eq(datetime, &current));
c010bb46:	83 c4 08             	add    $0x8,%esp
c010bb49:	56                   	push   %esi
c010bb4a:	53                   	push   %ebx
c010bb4b:	e8 11 ff ff ff       	call   c010ba61 <clock_datatime_eq>
c010bb50:	83 c4 10             	add    $0x10,%esp
c010bb53:	85 c0                	test   %eax,%eax
c010bb55:	0f 84 60 ff ff ff    	je     c010babb <clock_walltime+0xb>

    uint8_t regbv = rtc_read_reg(RTC_REG_B);
c010bb5b:	83 ec 0c             	sub    $0xc,%esp
c010bb5e:	6a 0b                	push   $0xb
c010bb60:	e8 6b 27 00 00       	call   c010e2d0 <rtc_read_reg>
c010bb65:	89 c6                	mov    %eax,%esi

    // Convert from bcd to binary when needed
    if (!RTC_BIN_ENCODED(regbv)) {
c010bb67:	83 c4 10             	add    $0x10,%esp
c010bb6a:	a8 04                	test   $0x4,%al
c010bb6c:	74 1d                	je     c010bb8b <clock_walltime+0xdb>
        datetime->second = bcd2dec(datetime->second);
    }


    // To 24 hour format
    if (!RTC_24HRS_ENCODED(regbv) && (datetime->hour >> 7)) {
c010bb6e:	f7 c6 02 00 00 00    	test   $0x2,%esi
c010bb74:	75 08                	jne    c010bb7e <clock_walltime+0xce>
c010bb76:	0f b6 43 07          	movzbl 0x7(%ebx),%eax
c010bb7a:	84 c0                	test   %al,%al
c010bb7c:	78 69                	js     c010bbe7 <clock_walltime+0x137>
        datetime->hour = (12 + datetime->hour & 0x80);
    }

    datetime->year += RTC_CURRENT_CENTRY * 100;
c010bb7e:	81 03 d0 07 00 00    	addl   $0x7d0,(%ebx)
}
c010bb84:	8d 65 f8             	lea    -0x8(%ebp),%esp
c010bb87:	5b                   	pop    %ebx
c010bb88:	5e                   	pop    %esi
c010bb89:	5d                   	pop    %ebp
c010bb8a:	c3                   	ret    
        datetime->year = bcd2dec(datetime->year);
c010bb8b:	83 ec 0c             	sub    $0xc,%esp
c010bb8e:	ff 33                	push   (%ebx)
c010bb90:	e8 69 27 00 00       	call   c010e2fe <bcd2dec>
c010bb95:	89 03                	mov    %eax,(%ebx)
        datetime->month = bcd2dec(datetime->month);
c010bb97:	0f b6 43 04          	movzbl 0x4(%ebx),%eax
c010bb9b:	89 04 24             	mov    %eax,(%esp)
c010bb9e:	e8 5b 27 00 00       	call   c010e2fe <bcd2dec>
c010bba3:	88 43 04             	mov    %al,0x4(%ebx)
        datetime->day = bcd2dec(datetime->day);
c010bba6:	0f b6 43 05          	movzbl 0x5(%ebx),%eax
c010bbaa:	89 04 24             	mov    %eax,(%esp)
c010bbad:	e8 4c 27 00 00       	call   c010e2fe <bcd2dec>
c010bbb2:	88 43 05             	mov    %al,0x5(%ebx)
        datetime->hour = bcd2dec(datetime->hour);
c010bbb5:	0f b6 43 07          	movzbl 0x7(%ebx),%eax
c010bbb9:	89 04 24             	mov    %eax,(%esp)
c010bbbc:	e8 3d 27 00 00       	call   c010e2fe <bcd2dec>
c010bbc1:	88 43 07             	mov    %al,0x7(%ebx)
        datetime->minute = bcd2dec(datetime->minute);
c010bbc4:	0f b6 43 08          	movzbl 0x8(%ebx),%eax
c010bbc8:	89 04 24             	mov    %eax,(%esp)
c010bbcb:	e8 2e 27 00 00       	call   c010e2fe <bcd2dec>
c010bbd0:	88 43 08             	mov    %al,0x8(%ebx)
        datetime->second = bcd2dec(datetime->second);
c010bbd3:	0f b6 43 09          	movzbl 0x9(%ebx),%eax
c010bbd7:	89 04 24             	mov    %eax,(%esp)
c010bbda:	e8 1f 27 00 00       	call   c010e2fe <bcd2dec>
c010bbdf:	88 43 09             	mov    %al,0x9(%ebx)
c010bbe2:	83 c4 10             	add    $0x10,%esp
c010bbe5:	eb 87                	jmp    c010bb6e <clock_walltime+0xbe>
        datetime->hour = (12 + datetime->hour & 0x80);
c010bbe7:	83 c0 0c             	add    $0xc,%eax
c010bbea:	83 e0 80             	and    $0xffffff80,%eax
c010bbed:	88 43 07             	mov    %al,0x7(%ebx)
c010bbf0:	eb 8c                	jmp    c010bb7e <clock_walltime+0xce>

c010bbf2 <clock_systime>:


time_t 
clock_systime() {
    return sys_time;
c010bbf2:	a1 90 05 d1 c0       	mov    0xc0d10590,%eax
c010bbf7:	c3                   	ret    

c010bbf8 <timer_update>:
    return timer;
}

static void
timer_update(const isr_param* param)
{
c010bbf8:	55                   	push   %ebp
c010bbf9:	89 e5                	mov    %esp,%ebp
c010bbfb:	57                   	push   %edi
c010bbfc:	56                   	push   %esi
c010bbfd:	53                   	push   %ebx
c010bbfe:	83 ec 0c             	sub    $0xc,%esp
    struct lx_timer *pos, *n;
    struct lx_timer* timer_list_head = timer_ctx->active_timers;
c010bc01:	a1 a4 05 d1 c0       	mov    0xc0d105a4,%eax
c010bc06:	8b 38                	mov    (%eax),%edi

    llist_for_each(pos, n, &timer_list_head->link, link)
c010bc08:	8b 5f 04             	mov    0x4(%edi),%ebx
c010bc0b:	8b 73 04             	mov    0x4(%ebx),%esi
c010bc0e:	eb 22                	jmp    c010bc32 <timer_update+0x3a>
    elem->prev->next = elem->next;
c010bc10:	8b 13                	mov    (%ebx),%edx
c010bc12:	8b 43 04             	mov    0x4(%ebx),%eax
c010bc15:	89 42 04             	mov    %eax,0x4(%edx)
    elem->next->prev = elem->prev;
c010bc18:	8b 13                	mov    (%ebx),%edx
c010bc1a:	89 10                	mov    %edx,(%eax)
    elem->prev = elem;
c010bc1c:	89 1b                	mov    %ebx,(%ebx)
    elem->next = elem;
c010bc1e:	89 5b 04             	mov    %ebx,0x4(%ebx)

        if ((pos->flags & TIMER_MODE_PERIODIC)) {
            pos->counter = pos->deadline;
        } else {
            llist_delete(&pos->link);
            lxfree(pos);
c010bc21:	83 ec 0c             	sub    $0xc,%esp
c010bc24:	53                   	push   %ebx
c010bc25:	e8 63 e4 ff ff       	call   c010a08d <lxfree>
c010bc2a:	83 c4 10             	add    $0x10,%esp
    llist_for_each(pos, n, &timer_list_head->link, link)
c010bc2d:	89 f3                	mov    %esi,%ebx
c010bc2f:	8b 76 04             	mov    0x4(%esi),%esi
c010bc32:	39 fb                	cmp    %edi,%ebx
c010bc34:	74 2b                	je     c010bc61 <timer_update+0x69>
        if (--(pos->counter)) {
c010bc36:	8b 43 0c             	mov    0xc(%ebx),%eax
c010bc39:	83 e8 01             	sub    $0x1,%eax
c010bc3c:	89 43 0c             	mov    %eax,0xc(%ebx)
c010bc3f:	75 ec                	jne    c010bc2d <timer_update+0x35>
        pos->callback ? pos->callback(pos->payload) : 1;
c010bc41:	8b 43 14             	mov    0x14(%ebx),%eax
c010bc44:	85 c0                	test   %eax,%eax
c010bc46:	74 0b                	je     c010bc53 <timer_update+0x5b>
c010bc48:	83 ec 0c             	sub    $0xc,%esp
c010bc4b:	ff 73 10             	push   0x10(%ebx)
c010bc4e:	ff d0                	call   *%eax
c010bc50:	83 c4 10             	add    $0x10,%esp
        if ((pos->flags & TIMER_MODE_PERIODIC)) {
c010bc53:	f6 43 18 01          	testb  $0x1,0x18(%ebx)
c010bc57:	74 b7                	je     c010bc10 <timer_update+0x18>
            pos->counter = pos->deadline;
c010bc59:	8b 43 08             	mov    0x8(%ebx),%eax
c010bc5c:	89 43 0c             	mov    %eax,0xc(%ebx)
c010bc5f:	eb cc                	jmp    c010bc2d <timer_update+0x35>
        }
    }

    sched_ticks_counter++;
c010bc61:	a1 94 05 d1 c0       	mov    0xc0d10594,%eax
c010bc66:	83 c0 01             	add    $0x1,%eax
c010bc69:	a3 94 05 d1 c0       	mov    %eax,0xc0d10594

    if (sched_ticks_counter >= sched_ticks) {
c010bc6e:	8b 15 94 05 d1 c0    	mov    0xc0d10594,%edx
c010bc74:	a1 98 05 d1 c0       	mov    0xc0d10598,%eax
c010bc79:	39 c2                	cmp    %eax,%edx
c010bc7b:	73 08                	jae    c010bc85 <timer_update+0x8d>
        sched_ticks_counter = 0;
        schedule();
    }
}
c010bc7d:	8d 65 f4             	lea    -0xc(%ebp),%esp
c010bc80:	5b                   	pop    %ebx
c010bc81:	5e                   	pop    %esi
c010bc82:	5f                   	pop    %edi
c010bc83:	5d                   	pop    %ebp
c010bc84:	c3                   	ret    
        sched_ticks_counter = 0;
c010bc85:	c7 05 94 05 d1 c0 00 	movl   $0x0,0xc0d10594
c010bc8c:	00 00 00 
        schedule();
c010bc8f:	e8 70 f4 ff ff       	call   c010b104 <schedule>
}
c010bc94:	eb e7                	jmp    c010bc7d <timer_update+0x85>

c010bc96 <temp_intr_routine_rtc_tick>:
    sched_ticks_counter = sched_ticks;
}

static void
temp_intr_routine_rtc_tick(const isr_param* param)
{
c010bc96:	55                   	push   %ebp
c010bc97:	89 e5                	mov    %esp,%ebp
c010bc99:	83 ec 14             	sub    $0x14,%esp
    rtc_counter++;
c010bc9c:	a1 a0 05 d1 c0       	mov    0xc0d105a0,%eax
c010bca1:	83 c0 01             	add    $0x1,%eax
c010bca4:	a3 a0 05 d1 c0       	mov    %eax,0xc0d105a0

    // dummy read on register C so RTC can send anther interrupt
    //  This strange behaviour observed in virtual box & bochs
    (void)rtc_read_reg(RTC_REG_C);
c010bca9:	6a 0c                	push   $0xc
c010bcab:	e8 20 26 00 00       	call   c010e2d0 <rtc_read_reg>
}
c010bcb0:	83 c4 10             	add    $0x10,%esp
c010bcb3:	c9                   	leave  
c010bcb4:	c3                   	ret    

c010bcb5 <temp_intr_routine_apic_timer>:

static void
temp_intr_routine_apic_timer(const isr_param* param)
{
c010bcb5:	55                   	push   %ebp
c010bcb6:	89 e5                	mov    %esp,%ebp
c010bcb8:	83 ec 08             	sub    $0x8,%esp
    timer_ctx->base_frequency =
      APIC_CALIBRATION_CONST / rtc_counter * RTC_TIMER_BASE_FREQUENCY;
c010bcbb:	8b 0d a0 05 d1 c0    	mov    0xc0d105a0,%ecx
c010bcc1:	b8 00 00 10 00       	mov    $0x100000,%eax
c010bcc6:	ba 00 00 00 00       	mov    $0x0,%edx
c010bccb:	f7 f1                	div    %ecx
c010bccd:	c1 e0 0a             	shl    $0xa,%eax
    timer_ctx->base_frequency =
c010bcd0:	8b 15 a4 05 d1 c0    	mov    0xc0d105a4,%edx
c010bcd6:	89 42 04             	mov    %eax,0x4(%edx)
    apic_timer_done = 1;
c010bcd9:	c6 05 9c 05 d1 c0 01 	movb   $0x1,0xc0d1059c

    rtc_disable_timer();
c010bce0:	e8 61 26 00 00       	call   c010e346 <rtc_disable_timer>
}
c010bce5:	c9                   	leave  
c010bce6:	c3                   	ret    

c010bce7 <kprintf>:
LOG_MODULE("TIMER");
c010bce7:	55                   	push   %ebp
c010bce8:	89 e5                	mov    %esp,%ebp
c010bcea:	83 ec 0c             	sub    $0xc,%esp
c010bced:	8d 45 0c             	lea    0xc(%ebp),%eax
c010bcf0:	50                   	push   %eax
c010bcf1:	ff 75 08             	push   0x8(%ebp)
c010bcf4:	68 90 32 d1 c0       	push   $0xc0d13290
c010bcf9:	e8 79 02 00 00       	call   c010bf77 <__kprintf>
c010bcfe:	83 c4 10             	add    $0x10,%esp
c010bd01:	c9                   	leave  
c010bd02:	c3                   	ret    

c010bd03 <timer_init_context>:
{
c010bd03:	55                   	push   %ebp
c010bd04:	89 e5                	mov    %esp,%ebp
c010bd06:	53                   	push   %ebx
c010bd07:	83 ec 10             	sub    $0x10,%esp
      (struct lx_timer_context*)lxmalloc(sizeof(struct lx_timer_context));
c010bd0a:	6a 10                	push   $0x10
c010bd0c:	e8 ea e5 ff ff       	call   c010a2fb <lxmalloc>
    timer_ctx =
c010bd11:	a3 a4 05 d1 c0       	mov    %eax,0xc0d105a4
    assert_msg(timer_ctx, "Fail to initialize timer contex");
c010bd16:	83 c4 10             	add    $0x10,%esp
c010bd19:	85 c0                	test   %eax,%eax
c010bd1b:	74 22                	je     c010bd3f <timer_init_context+0x3c>
c010bd1d:	89 c3                	mov    %eax,%ebx
      (struct lx_timer*)lxmalloc(sizeof(struct lx_timer));
c010bd1f:	83 ec 0c             	sub    $0xc,%esp
c010bd22:	6a 1c                	push   $0x1c
c010bd24:	e8 d2 e5 ff ff       	call   c010a2fb <lxmalloc>
    timer_ctx->active_timers =
c010bd29:	89 03                	mov    %eax,(%ebx)
    llist_init_head(timer_ctx->active_timers);
c010bd2b:	a1 a4 05 d1 c0       	mov    0xc0d105a4,%eax
c010bd30:	8b 00                	mov    (%eax),%eax
    head->next = head;
c010bd32:	89 40 04             	mov    %eax,0x4(%eax)
    head->prev = head;
c010bd35:	89 00                	mov    %eax,(%eax)
}
c010bd37:	83 c4 10             	add    $0x10,%esp
c010bd3a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c010bd3d:	c9                   	leave  
c010bd3e:	c3                   	ret    
    assert_msg(timer_ctx, "Fail to initialize timer contex");
c010bd3f:	83 ec 04             	sub    $0x4,%esp
c010bd42:	6a 35                	push   $0x35
c010bd44:	68 96 32 d1 c0       	push   $0xc0d13296
c010bd49:	68 1c 36 d1 c0       	push   $0xc0d1361c
c010bd4e:	e8 10 f2 ff ff       	call   c010af63 <__assert_fail>

c010bd53 <timer_init>:
{
c010bd53:	55                   	push   %ebp
c010bd54:	89 e5                	mov    %esp,%ebp
c010bd56:	53                   	push   %ebx
c010bd57:	83 ec 04             	sub    $0x4,%esp
c010bd5a:	8b 5d 08             	mov    0x8(%ebp),%ebx
    timer_init_context();
c010bd5d:	e8 a1 ff ff ff       	call   c010bd03 <timer_init_context>
c010bd62:	fa                   	cli    
    apic_write_reg(APIC_TIMER_LVT,
c010bd63:	c7 05 20 03 c0 d0 fd 	movl   $0xfd,0xd0c00320
c010bd6a:	00 00 00 
    apic_write_reg(APIC_TIMER_DCR, APIC_TIMER_DIV64);
c010bd6d:	c7 05 e0 03 c0 d0 09 	movl   $0x9,0xd0c003e0
c010bd74:	00 00 00 
    if (frequency < 1000) {
c010bd77:	81 fb e7 03 00 00    	cmp    $0x3e7,%ebx
c010bd7d:	0f 86 15 01 00 00    	jbe    c010be98 <timer_init+0x145>
    timer_ctx->base_frequency = 0;
c010bd83:	a1 a4 05 d1 c0       	mov    0xc0d105a4,%eax
c010bd88:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    rtc_counter = 0;
c010bd8f:	c7 05 a0 05 d1 c0 00 	movl   $0x0,0xc0d105a0
c010bd96:	00 00 00 
    apic_timer_done = 0;
c010bd99:	c6 05 9c 05 d1 c0 00 	movb   $0x0,0xc0d1059c
    intr_subscribe(APIC_TIMER_IV, temp_intr_routine_apic_timer);
c010bda0:	83 ec 08             	sub    $0x8,%esp
c010bda3:	68 b5 bc 10 c0       	push   $0xc010bcb5
c010bda8:	68 fd 00 00 00       	push   $0xfd
c010bdad:	e8 c4 03 00 00       	call   c010c176 <intr_subscribe>
    intr_subscribe(RTC_TIMER_IV, temp_intr_routine_rtc_tick);
c010bdb2:	83 c4 08             	add    $0x8,%esp
c010bdb5:	68 96 bc 10 c0       	push   $0xc010bc96
c010bdba:	68 d2 00 00 00       	push   $0xd2
c010bdbf:	e8 b2 03 00 00       	call   c010c176 <intr_subscribe>
    rtc_enable_timer();                                     // start RTC timer
c010bdc4:	e8 54 25 00 00       	call   c010e31d <rtc_enable_timer>
    apic_write_reg(APIC_TIMER_ICR, APIC_CALIBRATION_CONST); // start APIC timer
c010bdc9:	c7 05 80 03 c0 d0 00 	movl   $0x100000,0xd0c00380
c010bdd0:	00 10 00 
    asm volatile("sti");
c010bdd3:	fb                   	sti    
}
c010bdd4:	83 c4 10             	add    $0x10,%esp
    wait_until(apic_timer_done);
c010bdd7:	0f b6 05 9c 05 d1 c0 	movzbl 0xc0d1059c,%eax
c010bdde:	84 c0                	test   %al,%al
c010bde0:	74 f5                	je     c010bdd7 <timer_init+0x84>
    assert_msg(timer_ctx->base_frequency, "Fail to initialize timer (NOFREQ)");
c010bde2:	a1 a4 05 d1 c0       	mov    0xc0d105a4,%eax
c010bde7:	8b 50 04             	mov    0x4(%eax),%edx
c010bdea:	85 d2                	test   %edx,%edx
c010bdec:	0f 84 bb 00 00 00    	je     c010bead <timer_init+0x15a>
    kprintf(KINFO "Base frequency: %u Hz\n", timer_ctx->base_frequency);
c010bdf2:	8b 40 04             	mov    0x4(%eax),%eax
c010bdf5:	83 ec 08             	sub    $0x8,%esp
c010bdf8:	50                   	push   %eax
c010bdf9:	68 aa 32 d1 c0       	push   $0xc0d132aa
c010bdfe:	e8 e4 fe ff ff       	call   c010bce7 <kprintf>
    timer_ctx->running_frequency = frequency;
c010be03:	8b 0d a4 05 d1 c0    	mov    0xc0d105a4,%ecx
c010be09:	89 59 08             	mov    %ebx,0x8(%ecx)
    timer_ctx->tphz = timer_ctx->base_frequency / frequency;
c010be0c:	8b 41 04             	mov    0x4(%ecx),%eax
c010be0f:	ba 00 00 00 00       	mov    $0x0,%edx
c010be14:	f7 f3                	div    %ebx
c010be16:	89 41 0c             	mov    %eax,0xc(%ecx)
    intr_unsubscribe(APIC_TIMER_IV, temp_intr_routine_apic_timer);
c010be19:	83 c4 08             	add    $0x8,%esp
c010be1c:	68 b5 bc 10 c0       	push   $0xc010bcb5
c010be21:	68 fd 00 00 00       	push   $0xfd
c010be26:	e8 5e 03 00 00       	call   c010c189 <intr_unsubscribe>
    intr_unsubscribe(RTC_TIMER_IV, temp_intr_routine_rtc_tick);
c010be2b:	83 c4 08             	add    $0x8,%esp
c010be2e:	68 96 bc 10 c0       	push   $0xc010bc96
c010be33:	68 d2 00 00 00       	push   $0xd2
c010be38:	e8 4c 03 00 00       	call   c010c189 <intr_unsubscribe>
    apic_write_reg(APIC_TIMER_LVT,
c010be3d:	c7 05 20 03 c0 d0 fd 	movl   $0x200fd,0xd0c00320
c010be44:	00 02 00 
    intr_subscribe(APIC_TIMER_IV, timer_update);
c010be47:	83 c4 08             	add    $0x8,%esp
c010be4a:	68 f8 bb 10 c0       	push   $0xc010bbf8
c010be4f:	68 fd 00 00 00       	push   $0xfd
c010be54:	e8 1d 03 00 00       	call   c010c176 <intr_subscribe>
    apic_write_reg(APIC_TIMER_ICR, timer_ctx->tphz);
c010be59:	a1 a4 05 d1 c0       	mov    0xc0d105a4,%eax
c010be5e:	8b 40 0c             	mov    0xc(%eax),%eax
c010be61:	a3 80 03 c0 d0       	mov    %eax,0xd0c00380
    sched_ticks = timer_ctx->running_frequency / 1000 * SCHED_TIME_SLICE;
c010be66:	a1 a4 05 d1 c0       	mov    0xc0d105a4,%eax
c010be6b:	8b 50 08             	mov    0x8(%eax),%edx
c010be6e:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
c010be73:	89 d0                	mov    %edx,%eax
c010be75:	f7 e1                	mul    %ecx
c010be77:	c1 ea 06             	shr    $0x6,%edx
c010be7a:	69 d2 2c 01 00 00    	imul   $0x12c,%edx,%edx
c010be80:	89 15 98 05 d1 c0    	mov    %edx,0xc0d10598
    sched_ticks_counter = 0;
c010be86:	c7 05 94 05 d1 c0 00 	movl   $0x0,0xc0d10594
c010be8d:	00 00 00 
}
c010be90:	83 c4 10             	add    $0x10,%esp
c010be93:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c010be96:	c9                   	leave  
c010be97:	c3                   	ret    
        kprintf(KWARN "Frequency too low. Millisecond timer might be dodgy.");
c010be98:	83 ec 0c             	sub    $0xc,%esp
c010be9b:	68 3c 36 d1 c0       	push   $0xc0d1363c
c010bea0:	e8 42 fe ff ff       	call   c010bce7 <kprintf>
c010bea5:	83 c4 10             	add    $0x10,%esp
c010bea8:	e9 d6 fe ff ff       	jmp    c010bd83 <timer_init+0x30>
    assert_msg(timer_ctx->base_frequency, "Fail to initialize timer (NOFREQ)");
c010bead:	83 ec 04             	sub    $0x4,%esp
c010beb0:	6a 79                	push   $0x79
c010beb2:	68 96 32 d1 c0       	push   $0xc0d13296
c010beb7:	68 74 36 d1 c0       	push   $0xc0d13674
c010bebc:	e8 a2 f0 ff ff       	call   c010af63 <__assert_fail>

c010bec1 <timer_run>:
{
c010bec1:	55                   	push   %ebp
c010bec2:	89 e5                	mov    %esp,%ebp
c010bec4:	56                   	push   %esi
c010bec5:	53                   	push   %ebx
c010bec6:	8b 5d 08             	mov    0x8(%ebp),%ebx
c010bec9:	8b 75 14             	mov    0x14(%ebp),%esi
      (struct lx_timer*)lxmalloc(sizeof(struct lx_timer));
c010becc:	83 ec 0c             	sub    $0xc,%esp
c010becf:	6a 1c                	push   $0x1c
c010bed1:	e8 25 e4 ff ff       	call   c010a2fb <lxmalloc>
    if (!timer)
c010bed6:	83 c4 10             	add    $0x10,%esp
c010bed9:	85 c0                	test   %eax,%eax
c010bedb:	74 2c                	je     c010bf09 <timer_run+0x48>
    timer->callback = callback;
c010bedd:	8b 55 0c             	mov    0xc(%ebp),%edx
c010bee0:	89 50 14             	mov    %edx,0x14(%eax)
    timer->counter = ticks;
c010bee3:	89 58 0c             	mov    %ebx,0xc(%eax)
    timer->deadline = ticks;
c010bee6:	89 58 08             	mov    %ebx,0x8(%eax)
    timer->payload = payload;
c010bee9:	8b 55 10             	mov    0x10(%ebp),%edx
c010beec:	89 50 10             	mov    %edx,0x10(%eax)
    timer->flags = flags;
c010beef:	89 f1                	mov    %esi,%ecx
c010bef1:	88 48 18             	mov    %cl,0x18(%eax)
    llist_append(timer_ctx->active_timers, &timer->link);
c010bef4:	8b 15 a4 05 d1 c0    	mov    0xc0d105a4,%edx
c010befa:	8b 12                	mov    (%edx),%edx
    __llist_add(elem, head, head->next);
c010befc:	8b 4a 04             	mov    0x4(%edx),%ecx
    next->prev = elem;
c010beff:	89 01                	mov    %eax,(%ecx)
    elem->next = next;
c010bf01:	89 48 04             	mov    %ecx,0x4(%eax)
    elem->prev = prev;
c010bf04:	89 10                	mov    %edx,(%eax)
    prev->next = elem;
c010bf06:	89 42 04             	mov    %eax,0x4(%edx)
}
c010bf09:	8d 65 f8             	lea    -0x8(%ebp),%esp
c010bf0c:	5b                   	pop    %ebx
c010bf0d:	5e                   	pop    %esi
c010bf0e:	5d                   	pop    %ebp
c010bf0f:	c3                   	ret    

c010bf10 <timer_run_second>:
{
c010bf10:	55                   	push   %ebp
c010bf11:	89 e5                	mov    %esp,%ebp
c010bf13:	83 ec 08             	sub    $0x8,%esp
      second * timer_ctx->running_frequency, callback, payload, flags);
c010bf16:	a1 a4 05 d1 c0       	mov    0xc0d105a4,%eax
c010bf1b:	8b 40 08             	mov    0x8(%eax),%eax
    return timer_run(
c010bf1e:	0f b6 55 14          	movzbl 0x14(%ebp),%edx
c010bf22:	52                   	push   %edx
c010bf23:	ff 75 10             	push   0x10(%ebp)
c010bf26:	ff 75 0c             	push   0xc(%ebp)
c010bf29:	0f af 45 08          	imul   0x8(%ebp),%eax
c010bf2d:	50                   	push   %eax
c010bf2e:	e8 8e ff ff ff       	call   c010bec1 <timer_run>
}
c010bf33:	c9                   	leave  
c010bf34:	c3                   	ret    

c010bf35 <timer_run_ms>:
{
c010bf35:	55                   	push   %ebp
c010bf36:	89 e5                	mov    %esp,%ebp
c010bf38:	83 ec 08             	sub    $0x8,%esp
    return timer_run(timer_ctx->running_frequency / 1000 * millisecond,
c010bf3b:	a1 a4 05 d1 c0       	mov    0xc0d105a4,%eax
c010bf40:	8b 50 08             	mov    0x8(%eax),%edx
c010bf43:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
c010bf48:	89 d0                	mov    %edx,%eax
c010bf4a:	f7 e1                	mul    %ecx
c010bf4c:	c1 ea 06             	shr    $0x6,%edx
c010bf4f:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
c010bf53:	50                   	push   %eax
c010bf54:	ff 75 10             	push   0x10(%ebp)
c010bf57:	ff 75 0c             	push   0xc(%ebp)
c010bf5a:	0f af 55 08          	imul   0x8(%ebp),%edx
c010bf5e:	52                   	push   %edx
c010bf5f:	e8 5d ff ff ff       	call   c010bec1 <timer_run>
}
c010bf64:	c9                   	leave  
c010bf65:	c3                   	ret    

c010bf66 <sched_yield>:
    sched_ticks_counter = sched_ticks;
c010bf66:	a1 98 05 d1 c0       	mov    0xc0d10598,%eax
c010bf6b:	a3 94 05 d1 c0       	mov    %eax,0xc0d10594
}
c010bf70:	c3                   	ret    

c010bf71 <timer_context>:

struct lx_timer_context*
timer_context()
{
    return timer_ctx;
c010bf71:	a1 a4 05 d1 c0       	mov    0xc0d105a4,%eax
c010bf76:	c3                   	ret    

c010bf77 <__kprintf>:

static char buf[MAX_KPRINTF_BUF_SIZE];

void
__kprintf(const char* component, const char* fmt, va_list args)
{
c010bf77:	55                   	push   %ebp
c010bf78:	89 e5                	mov    %esp,%ebp
c010bf7a:	81 ec 08 04 00 00    	sub    $0x408,%esp
c010bf80:	8b 45 0c             	mov    0xc(%ebp),%eax
    if (!fmt)
c010bf83:	85 c0                	test   %eax,%eax
c010bf85:	0f 84 c9 00 00 00    	je     c010c054 <__kprintf+0xdd>
        return;
    char log_level = '0';
    char expanded_fmt[MAX_XFMT_SIZE];

    if (*fmt == '\x1b') {
c010bf8b:	80 38 1b             	cmpb   $0x1b,(%eax)
c010bf8e:	75 77                	jne    c010c007 <__kprintf+0x90>
        log_level = *(++fmt);
c010bf90:	0f b6 50 01          	movzbl 0x1(%eax),%edx
        fmt++;
c010bf94:	83 c0 02             	add    $0x2,%eax
    }

    switch (log_level) {
c010bf97:	80 fa 32             	cmp    $0x32,%dl
c010bf9a:	0f 84 b6 00 00 00    	je     c010c056 <__kprintf+0xdf>
c010bfa0:	7f 35                	jg     c010bfd7 <__kprintf+0x60>
c010bfa2:	80 fa 30             	cmp    $0x30,%dl
c010bfa5:	74 60                	je     c010c007 <__kprintf+0x90>
c010bfa7:	80 fa 31             	cmp    $0x31,%dl
c010bfaa:	0f 85 cd 00 00 00    	jne    c010c07d <__kprintf+0x106>
                     component,
                     fmt);
            break;
        case '1':
            // tty_set_theme(VGA_COLOR_BROWN, current_theme >> 12);
            snprintf(expanded_fmt,
c010bfb0:	83 ec 08             	sub    $0x8,%esp
c010bfb3:	50                   	push   %eax
c010bfb4:	ff 75 08             	push   0x8(%ebp)
c010bfb7:	68 d5 32 d1 c0       	push   $0xc0d132d5
c010bfbc:	68 da 32 d1 c0       	push   $0xc0d132da
c010bfc1:	68 00 04 00 00       	push   $0x400
c010bfc6:	8d 85 f8 fb ff ff    	lea    -0x408(%ebp),%eax
c010bfcc:	50                   	push   %eax
c010bfcd:	e8 d5 2b 00 00       	call   c010eba7 <snprintf>
                     MAX_XFMT_SIZE,
                     "\x033[6;0m[%s] (%s) %s\x033[39;49m",
                     "WARN",
                     component,
                     fmt);
            break;
c010bfd2:	83 c4 20             	add    $0x20,%esp
c010bfd5:	eb 55                	jmp    c010c02c <__kprintf+0xb5>
    switch (log_level) {
c010bfd7:	80 fa 33             	cmp    $0x33,%dl
c010bfda:	0f 85 9d 00 00 00    	jne    c010c07d <__kprintf+0x106>
                     component,
                     fmt);
            break;
        case '3':
            // tty_set_theme(VGA_COLOR_LIGHT_BLUE, current_theme >> 12);
            snprintf(expanded_fmt,
c010bfe0:	83 ec 08             	sub    $0x8,%esp
c010bfe3:	50                   	push   %eax
c010bfe4:	ff 75 08             	push   0x8(%ebp)
c010bfe7:	68 16 33 d1 c0       	push   $0xc0d13316
c010bfec:	68 1b 33 d1 c0       	push   $0xc0d1331b
c010bff1:	68 00 04 00 00       	push   $0x400
c010bff6:	8d 85 f8 fb ff ff    	lea    -0x408(%ebp),%eax
c010bffc:	50                   	push   %eax
c010bffd:	e8 a5 2b 00 00       	call   c010eba7 <snprintf>
                     MAX_XFMT_SIZE,
                     "\x033[9;0m[%s] (%s) %s\x033[39;49m",
                     "DEBG",
                     component,
                     fmt);
            break;
c010c002:	83 c4 20             	add    $0x20,%esp
c010c005:	eb 25                	jmp    c010c02c <__kprintf+0xb5>
            snprintf(expanded_fmt,
c010c007:	83 ec 08             	sub    $0x8,%esp
c010c00a:	50                   	push   %eax
c010c00b:	ff 75 08             	push   0x8(%ebp)
c010c00e:	68 c3 32 d1 c0       	push   $0xc0d132c3
c010c013:	68 c8 32 d1 c0       	push   $0xc0d132c8
c010c018:	68 00 04 00 00       	push   $0x400
c010c01d:	8d 85 f8 fb ff ff    	lea    -0x408(%ebp),%eax
c010c023:	50                   	push   %eax
c010c024:	e8 7e 2b 00 00       	call   c010eba7 <snprintf>
            break;
c010c029:	83 c4 20             	add    $0x20,%esp
                     component,
                     fmt);
            break;
    }

    __sprintf_internal(buf, expanded_fmt, MAX_KPRINTF_BUF_SIZE, args);
c010c02c:	ff 75 10             	push   0x10(%ebp)
c010c02f:	68 00 04 00 00       	push   $0x400
c010c034:	8d 85 f8 fb ff ff    	lea    -0x408(%ebp),%eax
c010c03a:	50                   	push   %eax
c010c03b:	68 c0 05 d1 c0       	push   $0xc0d105c0
c010c040:	e8 f4 25 00 00       	call   c010e639 <__sprintf_internal>
    console_write_str(buf);
c010c045:	c7 04 24 c0 05 d1 c0 	movl   $0xc0d105c0,(%esp)
c010c04c:	e8 fa 0c 00 00       	call   c010cd4b <console_write_str>
c010c051:	83 c4 10             	add    $0x10,%esp
}
c010c054:	c9                   	leave  
c010c055:	c3                   	ret    
            snprintf(expanded_fmt,
c010c056:	83 ec 08             	sub    $0x8,%esp
c010c059:	50                   	push   %eax
c010c05a:	ff 75 08             	push   0x8(%ebp)
c010c05d:	68 f5 32 d1 c0       	push   $0xc0d132f5
c010c062:	68 fa 32 d1 c0       	push   $0xc0d132fa
c010c067:	68 00 04 00 00       	push   $0x400
c010c06c:	8d 85 f8 fb ff ff    	lea    -0x408(%ebp),%eax
c010c072:	50                   	push   %eax
c010c073:	e8 2f 2b 00 00       	call   c010eba7 <snprintf>
            break;
c010c078:	83 c4 20             	add    $0x20,%esp
c010c07b:	eb af                	jmp    c010c02c <__kprintf+0xb5>
            snprintf(expanded_fmt,
c010c07d:	83 ec 08             	sub    $0x8,%esp
c010c080:	50                   	push   %eax
c010c081:	ff 75 08             	push   0x8(%ebp)
c010c084:	68 36 33 d1 c0       	push   $0xc0d13336
c010c089:	68 c8 32 d1 c0       	push   $0xc0d132c8
c010c08e:	68 00 04 00 00       	push   $0x400
c010c093:	8d 85 f8 fb ff ff    	lea    -0x408(%ebp),%eax
c010c099:	50                   	push   %eax
c010c09a:	e8 08 2b 00 00       	call   c010eba7 <snprintf>
            break;
c010c09f:	83 c4 20             	add    $0x20,%esp
c010c0a2:	eb 88                	jmp    c010c02c <__kprintf+0xb5>

c010c0a4 <kprint_panic>:

void
kprint_panic(const char* fmt, ...)
{
c010c0a4:	55                   	push   %ebp
c010c0a5:	89 e5                	mov    %esp,%ebp
c010c0a7:	53                   	push   %ebx
c010c0a8:	83 ec 0c             	sub    $0xc,%esp
    va_list args;
    va_start(args, fmt);
c010c0ab:	8d 5d 0c             	lea    0xc(%ebp),%ebx

    tty_set_theme(VGA_COLOR_WHITE, VGA_COLOR_RED);
c010c0ae:	6a 04                	push   $0x4
c010c0b0:	6a 0f                	push   $0xf
c010c0b2:	e8 c3 eb ff ff       	call   c010ac7a <tty_set_theme>
    tty_clear_line(10);
c010c0b7:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
c010c0be:	e8 23 ee ff ff       	call   c010aee6 <tty_clear_line>
    tty_clear_line(11);
c010c0c3:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
c010c0ca:	e8 17 ee ff ff       	call   c010aee6 <tty_clear_line>
    tty_clear_line(12);
c010c0cf:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
c010c0d6:	e8 0b ee ff ff       	call   c010aee6 <tty_clear_line>

    __sprintf_internal(buf, fmt, MAX_KPRINTF_BUF_SIZE, args);
c010c0db:	53                   	push   %ebx
c010c0dc:	68 00 04 00 00       	push   $0x400
c010c0e1:	ff 75 08             	push   0x8(%ebp)
c010c0e4:	68 c0 05 d1 c0       	push   $0xc0d105c0
c010c0e9:	e8 4b 25 00 00       	call   c010e639 <__sprintf_internal>
    tty_put_str_at(buf, 0, 11);
c010c0ee:	83 c4 1c             	add    $0x1c,%esp
c010c0f1:	6a 0b                	push   $0xb
c010c0f3:	6a 00                	push   $0x0
c010c0f5:	68 c0 05 d1 c0       	push   $0xc0d105c0
c010c0fa:	e8 10 ee ff ff       	call   c010af0f <tty_put_str_at>

    va_end(args);
c010c0ff:	83 c4 10             	add    $0x10,%esp
c010c102:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c010c105:	c9                   	leave  
c010c106:	c3                   	ret    

c010c107 <hhk_entry_>:
c010c107:	83 ec 10             	sub    $0x10,%esp
c010c10a:	e8 b4 01 00 00       	call   c010c2c3 <_init_gdt>
c010c10f:	c7 44 24 02 e0 0d d1 	movl   $0xc0d10de0,0x2(%esp)
c010c116:	c0 
c010c117:	66 a1 60 20 d1 c0    	mov    0xc0d12060,%ax
c010c11d:	66 89 04 24          	mov    %ax,(%esp)
c010c121:	0f 01 14 24          	lgdtl  (%esp)
c010c125:	66 b9 10 00          	mov    $0x10,%cx
c010c129:	8e c1                	mov    %ecx,%es
c010c12b:	8e d9                	mov    %ecx,%ds
c010c12d:	8e e1                	mov    %ecx,%fs
c010c12f:	8e e9                	mov    %ecx,%gs
c010c131:	8e d1                	mov    %ecx,%ss
c010c133:	66 6a 08             	pushw  $0x8
c010c136:	68 3c c1 10 c0       	push   $0xc010c13c
c010c13b:	cb                   	lret   

c010c13c <_after_gdt>:
c010c13c:	c7 05 d0 18 d1 c0 00 	movl   $0x101000,0xc0d118d0
c010c143:	10 10 00 
c010c146:	e8 05 1b 00 00       	call   c010dc50 <_kernel_pre_init>
c010c14b:	83 ec 06             	sub    $0x6,%esp
c010c14e:	c7 44 24 02 a0 0e d1 	movl   $0xc0d10ea0,0x2(%esp)
c010c155:	c0 
c010c156:	66 a1 1c 24 d1 c0    	mov    0xc0d1241c,%ax
c010c15c:	66 89 04 24          	mov    %ax,(%esp)
c010c160:	0f 01 1c 24          	lidtl  (%esp)
c010c164:	66 b8 28 00          	mov    $0x28,%ax
c010c168:	0f 00 d8             	ltr    %ax
c010c16b:	83 c4 06             	add    $0x6,%esp
c010c16e:	e8 ac 19 00 00       	call   c010db1f <_kernel_init>
c010c173:	f4                   	hlt    
c010c174:	eb fd                	jmp    c010c173 <_after_gdt+0x37>

c010c176 <intr_subscribe>:

static int_subscriber fallback = (int_subscriber)0;

void
intr_subscribe(const uint8_t vector, int_subscriber subscriber)
{
c010c176:	55                   	push   %ebp
c010c177:	89 e5                	mov    %esp,%ebp
    subscribers[vector] = subscriber;
c010c179:	0f b6 45 08          	movzbl 0x8(%ebp),%eax
c010c17d:	8b 55 0c             	mov    0xc(%ebp),%edx
c010c180:	89 14 85 e0 09 d1 c0 	mov    %edx,-0x3f2ef620(,%eax,4)
}
c010c187:	5d                   	pop    %ebp
c010c188:	c3                   	ret    

c010c189 <intr_unsubscribe>:

void
intr_unsubscribe(const uint8_t vector, int_subscriber subscriber)
{
c010c189:	55                   	push   %ebp
c010c18a:	89 e5                	mov    %esp,%ebp
    if (subscribers[vector] == subscriber) {
c010c18c:	0f b6 45 08          	movzbl 0x8(%ebp),%eax
c010c190:	8b 55 0c             	mov    0xc(%ebp),%edx
c010c193:	39 14 85 e0 09 d1 c0 	cmp    %edx,-0x3f2ef620(,%eax,4)
c010c19a:	74 02                	je     c010c19e <intr_unsubscribe+0x15>
        subscribers[vector] = (int_subscriber)0;
    }
}
c010c19c:	5d                   	pop    %ebp
c010c19d:	c3                   	ret    
        subscribers[vector] = (int_subscriber)0;
c010c19e:	c7 04 85 e0 09 d1 c0 	movl   $0x0,-0x3f2ef620(,%eax,4)
c010c1a5:	00 00 00 00 
}
c010c1a9:	eb f1                	jmp    c010c19c <intr_unsubscribe+0x13>

c010c1ab <intr_set_fallback_handler>:

void
intr_set_fallback_handler(int_subscriber subscribers)
{
c010c1ab:	55                   	push   %ebp
c010c1ac:	89 e5                	mov    %esp,%ebp
    fallback = subscribers;
c010c1ae:	8b 45 08             	mov    0x8(%ebp),%eax
c010c1b1:	a3 c0 09 d1 c0       	mov    %eax,0xc0d109c0
}
c010c1b6:	5d                   	pop    %ebp
c010c1b7:	c3                   	ret    

c010c1b8 <intr_handler>:

extern x86_page_table* __kernel_ptd;

void
intr_handler(isr_param* param)
{
c010c1b8:	55                   	push   %ebp
c010c1b9:	89 e5                	mov    %esp,%ebp
c010c1bb:	57                   	push   %edi
c010c1bc:	56                   	push   %esi
c010c1bd:	53                   	push   %ebx
c010c1be:	83 ec 0c             	sub    $0xc,%esp
    __current->intr_ctx = *param;
c010c1c1:	8b 1d 8c 05 d1 c0    	mov    0xc0d1058c,%ebx
c010c1c7:	8d 7b 08             	lea    0x8(%ebx),%edi
c010c1ca:	b9 13 00 00 00       	mov    $0x13,%ecx
c010c1cf:	8b 75 08             	mov    0x8(%ebp),%esi
c010c1d2:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)

    isr_param* lparam = &__current->intr_ctx;
c010c1d4:	8d 4b 08             	lea    0x8(%ebx),%ecx

    if (lparam->vector <= 255) {
c010c1d7:	8b 43 38             	mov    0x38(%ebx),%eax
c010c1da:	3d ff 00 00 00       	cmp    $0xff,%eax
c010c1df:	77 18                	ja     c010c1f9 <intr_handler+0x41>
        int_subscriber subscriber = subscribers[lparam->vector];
c010c1e1:	8b 14 85 e0 09 d1 c0 	mov    -0x3f2ef620(,%eax,4),%edx
        if (subscriber) {
c010c1e8:	85 d2                	test   %edx,%edx
c010c1ea:	74 0d                	je     c010c1f9 <intr_handler+0x41>
            subscriber(param);
c010c1ec:	83 ec 0c             	sub    $0xc,%esp
c010c1ef:	ff 75 08             	push   0x8(%ebp)
c010c1f2:	ff d2                	call   *%edx
            goto done;
c010c1f4:	83 c4 10             	add    $0x10,%esp
c010c1f7:	eb 13                	jmp    c010c20c <intr_handler+0x54>
        }
    }

    if (fallback) {
c010c1f9:	8b 15 c0 09 d1 c0    	mov    0xc0d109c0,%edx
c010c1ff:	85 d2                	test   %edx,%edx
c010c201:	74 32                	je     c010c235 <intr_handler+0x7d>
        fallback(lparam);
c010c203:	83 ec 0c             	sub    $0xc,%esp
c010c206:	51                   	push   %ecx
c010c207:	ff d2                	call   *%edx
        goto done;
c010c209:	83 c4 10             	add    $0x10,%esp
                 lparam->eip);

done:
    // for all external interrupts except the spurious interrupt
    //  this is required by Intel Manual Vol.3A, section 10.8.1 & 10.8.5
    if (lparam->vector >= EX_INTERRUPT_BEGIN &&
c010c20c:	8b 43 38             	mov    0x38(%ebx),%eax
c010c20f:	3d c7 00 00 00       	cmp    $0xc7,%eax
c010c214:	0f 97 c2             	seta   %dl
c010c217:	3d fc 00 00 00       	cmp    $0xfc,%eax
c010c21c:	0f 95 c0             	setne  %al
c010c21f:	84 c2                	test   %al,%dl
c010c221:	74 0a                	je     c010c22d <intr_handler+0x75>
c010c223:	c7 05 b0 00 c0 d0 00 	movl   $0x0,0xd0c000b0
c010c22a:	00 00 00 
        lparam->vector != APIC_SPIV_IV) {
        apic_done_servicing();
    }

    return;
c010c22d:	8d 65 f4             	lea    -0xc(%ebp),%esp
c010c230:	5b                   	pop    %ebx
c010c231:	5e                   	pop    %esi
c010c232:	5f                   	pop    %edi
c010c233:	5d                   	pop    %ebp
c010c234:	c3                   	ret    
    kprint_panic("INT %u: (%x) [%p: %p] Unknown",
c010c235:	83 ec 0c             	sub    $0xc,%esp
c010c238:	ff 73 40             	push   0x40(%ebx)
c010c23b:	ff 73 44             	push   0x44(%ebx)
c010c23e:	ff 73 3c             	push   0x3c(%ebx)
c010c241:	50                   	push   %eax
c010c242:	68 3a 33 d1 c0       	push   $0xc0d1333a
c010c247:	e8 58 fe ff ff       	call   c010c0a4 <kprint_panic>
c010c24c:	83 c4 20             	add    $0x20,%esp
c010c24f:	eb bb                	jmp    c010c20c <intr_handler+0x54>

c010c251 <_set_gdt_entry>:
#define GDT_ENTRY 6

uint64_t _gdt[GDT_ENTRY];
uint16_t _gdt_limit = sizeof(_gdt) - 1;

void _set_gdt_entry(uint32_t index, uint32_t base, uint32_t limit, uint32_t flags) {
c010c251:	55                   	push   %ebp
c010c252:	89 e5                	mov    %esp,%ebp
c010c254:	57                   	push   %edi
c010c255:	56                   	push   %esi
c010c256:	53                   	push   %ebx
c010c257:	8b 4d 08             	mov    0x8(%ebp),%ecx
c010c25a:	8b 55 0c             	mov    0xc(%ebp),%edx
c010c25d:	8b 5d 10             	mov    0x10(%ebp),%ebx
    _gdt[index] = SEG_BASE_H(base) | flags | SEG_LIM_H(limit) | SEG_BASE_M(base);
c010c260:	89 d0                	mov    %edx,%eax
c010c262:	25 00 00 00 ff       	and    $0xff000000,%eax
c010c267:	0b 45 14             	or     0x14(%ebp),%eax
c010c26a:	89 de                	mov    %ebx,%esi
c010c26c:	81 e6 00 00 0f 00    	and    $0xf0000,%esi
c010c272:	09 f0                	or     %esi,%eax
c010c274:	89 c7                	mov    %eax,%edi
c010c276:	89 d6                	mov    %edx,%esi
c010c278:	c1 ee 10             	shr    $0x10,%esi
c010c27b:	89 f0                	mov    %esi,%eax
c010c27d:	0f b6 f0             	movzbl %al,%esi
c010c280:	89 f8                	mov    %edi,%eax
c010c282:	09 f0                	or     %esi,%eax
c010c284:	89 04 cd e0 0d d1 c0 	mov    %eax,-0x3f2ef220(,%ecx,8)
c010c28b:	c7 04 cd e4 0d d1 c0 	movl   $0x0,-0x3f2ef21c(,%ecx,8)
c010c292:	00 00 00 00 
    _gdt[index] <<= 32;
c010c296:	c7 04 cd e0 0d d1 c0 	movl   $0x0,-0x3f2ef220(,%ecx,8)
c010c29d:	00 00 00 00 
c010c2a1:	89 04 cd e4 0d d1 c0 	mov    %eax,-0x3f2ef21c(,%ecx,8)
    _gdt[index] |= SEG_BASE_L(base) | SEG_LIM_L(limit);
c010c2a8:	c1 e2 10             	shl    $0x10,%edx
c010c2ab:	0f b7 db             	movzwl %bx,%ebx
c010c2ae:	09 da                	or     %ebx,%edx
c010c2b0:	89 14 cd e0 0d d1 c0 	mov    %edx,-0x3f2ef220(,%ecx,8)
c010c2b7:	89 04 cd e4 0d d1 c0 	mov    %eax,-0x3f2ef21c(,%ecx,8)
}
c010c2be:	5b                   	pop    %ebx
c010c2bf:	5e                   	pop    %esi
c010c2c0:	5f                   	pop    %edi
c010c2c1:	5d                   	pop    %ebp
c010c2c2:	c3                   	ret    

c010c2c3 <_init_gdt>:

extern struct x86_tss _tss;

void
_init_gdt() {
c010c2c3:	55                   	push   %ebp
c010c2c4:	89 e5                	mov    %esp,%ebp
c010c2c6:	83 ec 08             	sub    $0x8,%esp
    _set_gdt_entry(0, 0, 0, 0);
c010c2c9:	6a 00                	push   $0x0
c010c2cb:	6a 00                	push   $0x0
c010c2cd:	6a 00                	push   $0x0
c010c2cf:	6a 00                	push   $0x0
c010c2d1:	e8 7b ff ff ff       	call   c010c251 <_set_gdt_entry>
    _set_gdt_entry(1, 0, 0xfffff, SEG_R0_CODE);
c010c2d6:	68 00 9a c0 00       	push   $0xc09a00
c010c2db:	68 ff ff 0f 00       	push   $0xfffff
c010c2e0:	6a 00                	push   $0x0
c010c2e2:	6a 01                	push   $0x1
c010c2e4:	e8 68 ff ff ff       	call   c010c251 <_set_gdt_entry>
    _set_gdt_entry(2, 0, 0xfffff, SEG_R0_DATA);
c010c2e9:	83 c4 20             	add    $0x20,%esp
c010c2ec:	68 00 92 c0 00       	push   $0xc09200
c010c2f1:	68 ff ff 0f 00       	push   $0xfffff
c010c2f6:	6a 00                	push   $0x0
c010c2f8:	6a 02                	push   $0x2
c010c2fa:	e8 52 ff ff ff       	call   c010c251 <_set_gdt_entry>
    _set_gdt_entry(3, 0, 0xfffff, SEG_R3_CODE);
c010c2ff:	68 00 fa c0 00       	push   $0xc0fa00
c010c304:	68 ff ff 0f 00       	push   $0xfffff
c010c309:	6a 00                	push   $0x0
c010c30b:	6a 03                	push   $0x3
c010c30d:	e8 3f ff ff ff       	call   c010c251 <_set_gdt_entry>
    _set_gdt_entry(4, 0, 0xfffff, SEG_R3_DATA);
c010c312:	83 c4 20             	add    $0x20,%esp
c010c315:	68 00 f2 c0 00       	push   $0xc0f200
c010c31a:	68 ff ff 0f 00       	push   $0xfffff
c010c31f:	6a 00                	push   $0x0
c010c321:	6a 04                	push   $0x4
c010c323:	e8 29 ff ff ff       	call   c010c251 <_set_gdt_entry>
    _set_gdt_entry(5, &_tss, sizeof(struct x86_tss) - 1, SEG_TSS);
c010c328:	68 00 89 00 00       	push   $0x8900
c010c32d:	6a 67                	push   $0x67
c010c32f:	68 80 20 d1 c0       	push   $0xc0d12080
c010c334:	6a 05                	push   $0x5
c010c336:	e8 16 ff ff ff       	call   c010c251 <_set_gdt_entry>
c010c33b:	83 c4 20             	add    $0x20,%esp
c010c33e:	c9                   	leave  
c010c33f:	c3                   	ret    

c010c340 <_asm_isr0>:
c010c340:	6a 00                	push   $0x0
c010c342:	6a 00                	push   $0x0
c010c344:	eb 4e                	jmp    c010c394 <interrupt_wrapper>

c010c346 <_asm_isr13>:
c010c346:	6a 0d                	push   $0xd
c010c348:	eb 4a                	jmp    c010c394 <interrupt_wrapper>

c010c34a <_asm_isr14>:
c010c34a:	6a 0e                	push   $0xe
c010c34c:	eb 46                	jmp    c010c394 <interrupt_wrapper>

c010c34e <_asm_isr12>:
c010c34e:	6a 0c                	push   $0xc
c010c350:	eb 42                	jmp    c010c394 <interrupt_wrapper>

c010c352 <_asm_isr32>:
c010c352:	6a 00                	push   $0x0
c010c354:	6a 20                	push   $0x20
c010c356:	eb 3c                	jmp    c010c394 <interrupt_wrapper>

c010c358 <_asm_isr33>:
c010c358:	6a 00                	push   $0x0
c010c35a:	6a 21                	push   $0x21
c010c35c:	eb 36                	jmp    c010c394 <interrupt_wrapper>

c010c35e <_asm_isr250>:
c010c35e:	6a 00                	push   $0x0
c010c360:	68 fa 00 00 00       	push   $0xfa
c010c365:	eb 2d                	jmp    c010c394 <interrupt_wrapper>

c010c367 <_asm_isr251>:
c010c367:	6a 00                	push   $0x0
c010c369:	68 fb 00 00 00       	push   $0xfb
c010c36e:	eb 24                	jmp    c010c394 <interrupt_wrapper>

c010c370 <_asm_isr253>:
c010c370:	6a 00                	push   $0x0
c010c372:	68 fd 00 00 00       	push   $0xfd
c010c377:	eb 1b                	jmp    c010c394 <interrupt_wrapper>

c010c379 <_asm_isr252>:
c010c379:	6a 00                	push   $0x0
c010c37b:	68 fc 00 00 00       	push   $0xfc
c010c380:	eb 12                	jmp    c010c394 <interrupt_wrapper>

c010c382 <_asm_isr210>:
c010c382:	6a 00                	push   $0x0
c010c384:	68 d2 00 00 00       	push   $0xd2
c010c389:	eb 09                	jmp    c010c394 <interrupt_wrapper>

c010c38b <_asm_isr201>:
c010c38b:	6a 00                	push   $0x0
c010c38d:	68 c9 00 00 00       	push   $0xc9
c010c392:	eb 00                	jmp    c010c394 <interrupt_wrapper>

c010c394 <interrupt_wrapper>:
c010c394:	fc                   	cld    
c010c395:	54                   	push   %esp
c010c396:	83 ec 10             	sub    $0x10,%esp
c010c399:	8c 6c 24 0c          	mov    %gs,0xc(%esp)
c010c39d:	8c 64 24 08          	mov    %fs,0x8(%esp)
c010c3a1:	8c 44 24 04          	mov    %es,0x4(%esp)
c010c3a5:	8c 1c 24             	mov    %ds,(%esp)
c010c3a8:	56                   	push   %esi
c010c3a9:	55                   	push   %ebp
c010c3aa:	57                   	push   %edi
c010c3ab:	52                   	push   %edx
c010c3ac:	51                   	push   %ecx
c010c3ad:	53                   	push   %ebx
c010c3ae:	50                   	push   %eax
c010c3af:	8b 44 24 3c          	mov    0x3c(%esp),%eax
c010c3b3:	83 e0 03             	and    $0x3,%eax
c010c3b6:	74 18                	je     c010c3d0 <interrupt_wrapper+0x3c>
c010c3b8:	66 b8 10 00          	mov    $0x10,%ax
c010c3bc:	8e e8                	mov    %eax,%gs
c010c3be:	8e e0                	mov    %eax,%fs
c010c3c0:	8e d8                	mov    %eax,%ds
c010c3c2:	8e c0                	mov    %eax,%es
c010c3c4:	a1 8c 05 d1 c0       	mov    0xc0d1058c,%eax
c010c3c9:	8b 5c 24 44          	mov    0x44(%esp),%ebx
c010c3cd:	89 58 54             	mov    %ebx,0x54(%eax)
c010c3d0:	89 e0                	mov    %esp,%eax
c010c3d2:	83 e4 f0             	and    $0xfffffff0,%esp
c010c3d5:	83 ec 10             	sub    $0x10,%esp
c010c3d8:	89 04 24             	mov    %eax,(%esp)
c010c3db:	e8 d8 fd ff ff       	call   c010c1b8 <intr_handler>
c010c3e0:	8b 04 24             	mov    (%esp),%eax

c010c3e3 <soft_iret>:
c010c3e3:	89 c4                	mov    %eax,%esp
c010c3e5:	58                   	pop    %eax
c010c3e6:	5b                   	pop    %ebx
c010c3e7:	59                   	pop    %ecx
c010c3e8:	5a                   	pop    %edx
c010c3e9:	5f                   	pop    %edi
c010c3ea:	5d                   	pop    %ebp
c010c3eb:	5e                   	pop    %esi
c010c3ec:	8e 1c 24             	mov    (%esp),%ds
c010c3ef:	8e 44 24 04          	mov    0x4(%esp),%es
c010c3f3:	8e 64 24 08          	mov    0x8(%esp),%fs
c010c3f7:	8e 6c 24 0c          	mov    0xc(%esp),%gs
c010c3fb:	8b 64 24 10          	mov    0x10(%esp),%esp
c010c3ff:	83 c4 08             	add    $0x8,%esp
c010c402:	50                   	push   %eax
c010c403:	8b 44 24 04          	mov    0x4(%esp),%eax
c010c407:	a3 10 0e d1 c0       	mov    %eax,0xc0d10e10
c010c40c:	8b 44 24 08          	mov    0x8(%esp),%eax
c010c410:	83 e0 03             	and    $0x3,%eax
c010c413:	0f 95 c0             	setne  %al
c010c416:	c1 e0 03             	shl    $0x3,%eax
c010c419:	83 c0 10             	add    $0x10,%eax
c010c41c:	01 e0                	add    %esp,%eax
c010c41e:	a3 84 20 d1 c0       	mov    %eax,0xc0d12084
c010c423:	58                   	pop    %eax
c010c424:	cf                   	iret   

c010c425 <switch_to>:
c010c425:	5b                   	pop    %ebx
c010c426:	a1 8c 05 d1 c0       	mov    0xc0d1058c,%eax
c010c42b:	8b 48 58             	mov    0x58(%eax),%ecx
c010c42e:	8b 43 58             	mov    0x58(%ebx),%eax
c010c431:	39 c8                	cmp    %ecx,%eax
c010c433:	74 03                	je     c010c438 <switch_to+0x13>
c010c435:	0f 22 d8             	mov    %eax,%cr3
c010c438:	89 1d 8c 05 d1 c0    	mov    %ebx,0xc0d1058c
c010c43e:	bc a0 0e d1 c0       	mov    $0xc0d10ea0,%esp
c010c443:	e8 78 f2 ff ff       	call   c010b6c0 <signal_dispatch>
c010c448:	85 c0                	test   %eax,%eax
c010c44a:	74 02                	je     c010c44e <switch_to+0x29>
c010c44c:	eb 05                	jmp    c010c453 <handle_signal>
c010c44e:	8d 43 08             	lea    0x8(%ebx),%eax
c010c451:	eb 90                	jmp    c010c3e3 <soft_iret>

c010c453 <handle_signal>:
c010c453:	8d 58 08             	lea    0x8(%eax),%ebx
c010c456:	6a 23                	push   $0x23
c010c458:	50                   	push   %eax
c010c459:	ff 73 40             	push   0x40(%ebx)
c010c45c:	6a 1b                	push   $0x1b
c010c45e:	68 10 f0 10 c0       	push   $0xc010f010
c010c463:	66 b9 23 00          	mov    $0x23,%cx
c010c467:	8e c1                	mov    %ecx,%es
c010c469:	8e d9                	mov    %ecx,%ds
c010c46b:	8e e1                	mov    %ecx,%fs
c010c46d:	8e e9                	mov    %ecx,%gs
c010c46f:	cf                   	iret   

c010c470 <tss_update_esp>:
                                 .esp0 = KSTACK_TOP,
                                 .ss0 = KDATA_SEG };

void
tss_update_esp(uint32_t esp0)
{
c010c470:	55                   	push   %ebp
c010c471:	89 e5                	mov    %esp,%ebp
    _tss.esp0 = esp0;
c010c473:	8b 45 08             	mov    0x8(%ebp),%eax
c010c476:	a3 84 20 d1 c0       	mov    %eax,0xc0d12084
c010c47b:	5d                   	pop    %ebp
c010c47c:	c3                   	ret    

c010c47d <kprintf>:
#include <lunaix/status.h>
#include <lunaix/syslog.h>

static void
kprintf(const char* fmt, ...)
{
c010c47d:	55                   	push   %ebp
c010c47e:	89 e5                	mov    %esp,%ebp
c010c480:	83 ec 0c             	sub    $0xc,%esp
    va_list args;
    va_start(args, fmt);
c010c483:	8d 45 0c             	lea    0xc(%ebp),%eax
    __kprintf("PFAULT", fmt, args);
c010c486:	50                   	push   %eax
c010c487:	ff 75 08             	push   0x8(%ebp)
c010c48a:	68 58 33 d1 c0       	push   $0xc0d13358
c010c48f:	e8 e3 fa ff ff       	call   c010bf77 <__kprintf>
    va_end(args);
}
c010c494:	83 c4 10             	add    $0x10,%esp
c010c497:	c9                   	leave  
c010c498:	c3                   	ret    

c010c499 <do_kernel>:
    return;
}

int
do_kernel(v_mapping* mapping)
{
c010c499:	55                   	push   %ebp
c010c49a:	89 e5                	mov    %esp,%ebp
c010c49c:	56                   	push   %esi
c010c49d:	53                   	push   %ebx
c010c49e:	8b 5d 08             	mov    0x8(%ebp),%ebx
    uintptr_t addr = mapping->va;
c010c4a1:	8b 33                	mov    (%ebx),%esi
    if (addr >= KHEAP_START && addr < PROC_START) {
c010c4a3:	8d 86 00 00 c0 3f    	lea    0x3fc00000(%esi),%eax
c010c4a9:	3d ff ff ff 0f       	cmp    $0xfffffff,%eax
c010c4ae:	76 0c                	jbe    c010c4bc <do_kernel+0x23>
        cpu_invplg(mapping->pte);
        cpu_invplg(addr);
        goto done;
    }

    return 0;
c010c4b0:	b8 00 00 00 00       	mov    $0x0,%eax
done:
    return 1;
c010c4b5:	8d 65 f8             	lea    -0x8(%ebp),%esp
c010c4b8:	5b                   	pop    %ebx
c010c4b9:	5e                   	pop    %esi
c010c4ba:	5d                   	pop    %ebp
c010c4bb:	c3                   	ret    
        uintptr_t pa = pmm_alloc_page(KERNEL_PID, 0);
c010c4bc:	83 ec 08             	sub    $0x8,%esp
c010c4bf:	6a 00                	push   $0x0
c010c4c1:	6a ff                	push   $0xffffffff
c010c4c3:	e8 ff e5 ff ff       	call   c010aac7 <pmm_alloc_page>
c010c4c8:	89 c1                	mov    %eax,%ecx
        *mapping->pte = (*mapping->pte & 0xfff) | pa | PG_PRESENT;
c010c4ca:	8b 53 10             	mov    0x10(%ebx),%edx
c010c4cd:	8b 02                	mov    (%edx),%eax
c010c4cf:	25 ff 0f 00 00       	and    $0xfff,%eax
c010c4d4:	09 c8                	or     %ecx,%eax
c010c4d6:	83 c8 01             	or     $0x1,%eax
c010c4d9:	89 02                	mov    %eax,(%edx)
        cpu_invplg(mapping->pte);
c010c4db:	8b 43 10             	mov    0x10(%ebx),%eax
    asm volatile("invlpg (%0)" ::"r"((uintptr_t)va) : "memory");
c010c4de:	0f 01 38             	invlpg (%eax)
c010c4e1:	0f 01 3e             	invlpg (%esi)
    return 1;
c010c4e4:	83 c4 10             	add    $0x10,%esp
c010c4e7:	b8 01 00 00 00       	mov    $0x1,%eax
c010c4ec:	eb c7                	jmp    c010c4b5 <do_kernel+0x1c>

c010c4ee <intr_routine_page_fault>:
{
c010c4ee:	55                   	push   %ebp
c010c4ef:	89 e5                	mov    %esp,%ebp
c010c4f1:	57                   	push   %edi
c010c4f2:	56                   	push   %esi
c010c4f3:	53                   	push   %ebx
c010c4f4:	83 ec 3c             	sub    $0x3c,%esp
    asm volatile("movl %%cr2,%0" : "=r"(val));
c010c4f7:	0f 20 d3             	mov    %cr2,%ebx
c010c4fa:	89 5d c4             	mov    %ebx,-0x3c(%ebp)
    if (!ptr) {
c010c4fd:	85 db                	test   %ebx,%ebx
c010c4ff:	75 3e                	jne    c010c53f <intr_routine_page_fault+0x51>
            __current->pid,
c010c501:	a1 8c 05 d1 c0       	mov    0xc0d1058c,%eax
c010c506:	8b 00                	mov    (%eax),%eax
    kprintf(KERROR "(pid: %d) Segmentation fault on %p (%p:%p)\n",
c010c508:	83 ec 0c             	sub    $0xc,%esp
c010c50b:	8b 4d 08             	mov    0x8(%ebp),%ecx
c010c50e:	ff 71 38             	push   0x38(%ecx)
c010c511:	ff 71 3c             	push   0x3c(%ecx)
c010c514:	53                   	push   %ebx
c010c515:	50                   	push   %eax
c010c516:	68 98 36 d1 c0       	push   $0xc0d13698
c010c51b:	e8 5d ff ff ff       	call   c010c47d <kprintf>
    __SIGSET(__current->sig_pending, _SIGSEGV);
c010c520:	8b 15 8c 05 d1 c0    	mov    0xc0d1058c,%edx
c010c526:	8b 82 b8 00 00 00    	mov    0xb8(%edx),%eax
c010c52c:	83 c8 02             	or     $0x2,%eax
c010c52f:	89 82 b8 00 00 00    	mov    %eax,0xb8(%edx)
    schedule();
c010c535:	83 c4 20             	add    $0x20,%esp
c010c538:	e8 c7 eb ff ff       	call   c010b104 <schedule>
    while (1)
c010c53d:	eb fe                	jmp    c010c53d <intr_routine_page_fault+0x4f>
    if (!vmm_lookup(ptr, &mapping)) {
c010c53f:	83 ec 08             	sub    $0x8,%esp
c010c542:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c010c545:	50                   	push   %eax
c010c546:	53                   	push   %ebx
c010c547:	e8 6f e0 ff ff       	call   c010a5bb <vmm_lookup>
c010c54c:	83 c4 10             	add    $0x10,%esp
c010c54f:	85 c0                	test   %eax,%eax
c010c551:	74 ae                	je     c010c501 <intr_routine_page_fault+0x13>
    if (!SEL_RPL(param->cs)) {
c010c553:	8b 45 08             	mov    0x8(%ebp),%eax
c010c556:	f6 40 3c 03          	testb  $0x3,0x3c(%eax)
c010c55a:	75 17                	jne    c010c573 <intr_routine_page_fault+0x85>
        if (do_kernel(&mapping)) {
c010c55c:	83 ec 0c             	sub    $0xc,%esp
c010c55f:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c010c562:	50                   	push   %eax
c010c563:	e8 31 ff ff ff       	call   c010c499 <do_kernel>
c010c568:	83 c4 10             	add    $0x10,%esp
c010c56b:	85 c0                	test   %eax,%eax
c010c56d:	0f 85 a9 00 00 00    	jne    c010c61c <intr_routine_page_fault+0x12e>
    struct mm_region* hit_region = region_get(&__current->mm.regions, ptr);
c010c573:	a1 8c 05 d1 c0       	mov    0xc0d1058c,%eax
c010c578:	05 94 00 00 00       	add    $0x94,%eax
c010c57d:	83 ec 08             	sub    $0x8,%esp
c010c580:	53                   	push   %ebx
c010c581:	50                   	push   %eax
c010c582:	e8 73 e3 ff ff       	call   c010a8fa <region_get>
    if (!hit_region) {
c010c587:	83 c4 10             	add    $0x10,%esp
c010c58a:	85 c0                	test   %eax,%eax
c010c58c:	0f 84 6f ff ff ff    	je     c010c501 <intr_routine_page_fault+0x13>
    volatile x86_pte_t* pte = &PTE_MOUNTED(PD_REFERENCED, ptr >> 12);
c010c592:	89 df                	mov    %ebx,%edi
c010c594:	c1 ef 0c             	shr    $0xc,%edi
c010c597:	8d 34 bd 00 00 00 00 	lea    0x0(,%edi,4),%esi
c010c59e:	81 e6 00 f0 3f 00    	and    $0x3ff000,%esi
c010c5a4:	81 ce 00 00 c0 ff    	or     $0xffc00000,%esi
c010c5aa:	81 e7 ff 03 00 00    	and    $0x3ff,%edi
c010c5b0:	8d 14 be             	lea    (%esi,%edi,4),%edx
    if ((*pte & PG_PRESENT)) {
c010c5b3:	8b 0c be             	mov    (%esi,%edi,4),%ecx
c010c5b6:	f6 c1 01             	test   $0x1,%cl
c010c5b9:	74 69                	je     c010c624 <intr_routine_page_fault+0x136>
        if ((hit_region->attr & COW_MASK) == COW_MASK) {
c010c5bb:	8b 40 10             	mov    0x10(%eax),%eax
c010c5be:	83 e0 0d             	and    $0xd,%eax
c010c5c1:	83 f8 0d             	cmp    $0xd,%eax
c010c5c4:	0f 85 37 ff ff ff    	jne    c010c501 <intr_routine_page_fault+0x13>
    asm volatile("invlpg (%0)" ::"r"((uintptr_t)va) : "memory");
c010c5ca:	0f 01 3a             	invlpg (%edx)
              (uintptr_t)vmm_dup_page(__current->pid, PG_ENTRY_ADDR(*pte));
c010c5cd:	8b 04 be             	mov    (%esi,%edi,4),%eax
c010c5d0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c010c5d5:	8b 15 8c 05 d1 c0    	mov    0xc0d1058c,%edx
c010c5db:	8b 12                	mov    (%edx),%edx
c010c5dd:	83 ec 08             	sub    $0x8,%esp
c010c5e0:	50                   	push   %eax
c010c5e1:	52                   	push   %edx
c010c5e2:	e8 90 dd ff ff       	call   c010a377 <vmm_dup_page>
c010c5e7:	89 c3                	mov    %eax,%ebx
            pmm_free_page(__current->pid, *pte & ~0xFFF);
c010c5e9:	8b 04 be             	mov    (%esi,%edi,4),%eax
c010c5ec:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c010c5f1:	8b 15 8c 05 d1 c0    	mov    0xc0d1058c,%edx
c010c5f7:	8b 12                	mov    (%edx),%edx
c010c5f9:	83 c4 08             	add    $0x8,%esp
c010c5fc:	50                   	push   %eax
c010c5fd:	52                   	push   %edx
c010c5fe:	e8 5d e5 ff ff       	call   c010ab60 <pmm_free_page>
            *pte = (*pte & 0xFFF) | pa | PG_WRITE;
c010c603:	8b 04 be             	mov    (%esi,%edi,4),%eax
c010c606:	25 ff 0f 00 00       	and    $0xfff,%eax
c010c60b:	09 d8                	or     %ebx,%eax
c010c60d:	83 c8 02             	or     $0x2,%eax
c010c610:	89 04 be             	mov    %eax,(%esi,%edi,4)
            goto resolved;
c010c613:	83 c4 10             	add    $0x10,%esp
c010c616:	8b 45 c4             	mov    -0x3c(%ebp),%eax
c010c619:	0f 01 38             	invlpg (%eax)
}
c010c61c:	8d 65 f4             	lea    -0xc(%ebp),%esp
c010c61f:	5b                   	pop    %ebx
c010c620:	5e                   	pop    %esi
c010c621:	5f                   	pop    %edi
c010c622:	5d                   	pop    %ebp
c010c623:	c3                   	ret    
    if (!(*pte)) {
c010c624:	8b 0c be             	mov    (%esi,%edi,4),%ecx
c010c627:	85 c9                	test   %ecx,%ecx
c010c629:	0f 84 d2 fe ff ff    	je     c010c501 <intr_routine_page_fault+0x13>
    uintptr_t loc = *pte & ~0xfff;
c010c62f:	8b 0c be             	mov    (%esi,%edi,4),%ecx
c010c632:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
    if ((hit_region->attr & REGION_WRITE) && (*pte & 0xfff) && !loc) {
c010c638:	f6 40 10 08          	testb  $0x8,0x10(%eax)
c010c63c:	74 0e                	je     c010c64c <intr_routine_page_fault+0x15e>
c010c63e:	8b 04 be             	mov    (%esi,%edi,4),%eax
c010c641:	a9 ff 0f 00 00       	test   $0xfff,%eax
c010c646:	74 04                	je     c010c64c <intr_routine_page_fault+0x15e>
c010c648:	85 c9                	test   %ecx,%ecx
c010c64a:	74 15                	je     c010c661 <intr_routine_page_fault+0x173>
    __print_panic_msg("WIP page fault route", param);
c010c64c:	83 ec 08             	sub    $0x8,%esp
c010c64f:	ff 75 08             	push   0x8(%ebp)
c010c652:	68 5f 33 d1 c0       	push   $0xc0d1335f
c010c657:	e8 49 00 00 00       	call   c010c6a5 <__print_panic_msg>
c010c65c:	83 c4 10             	add    $0x10,%esp
    while (1)
c010c65f:	eb fe                	jmp    c010c65f <intr_routine_page_fault+0x171>
c010c661:	0f 01 3a             	invlpg (%edx)
        uintptr_t pa = pmm_alloc_page(__current->pid, 0);
c010c664:	a1 8c 05 d1 c0       	mov    0xc0d1058c,%eax
c010c669:	8b 00                	mov    (%eax),%eax
c010c66b:	83 ec 08             	sub    $0x8,%esp
c010c66e:	6a 00                	push   $0x0
c010c670:	50                   	push   %eax
c010c671:	e8 51 e4 ff ff       	call   c010aac7 <pmm_alloc_page>
c010c676:	89 c2                	mov    %eax,%edx
        *pte = *pte | pa | PG_PRESENT;
c010c678:	8b 04 be             	mov    (%esi,%edi,4),%eax
c010c67b:	09 d0                	or     %edx,%eax
c010c67d:	83 c8 01             	or     $0x1,%eax
c010c680:	89 04 be             	mov    %eax,(%esi,%edi,4)
        goto resolved;
c010c683:	83 c4 10             	add    $0x10,%esp
c010c686:	eb 8e                	jmp    c010c616 <intr_routine_page_fault+0x128>

c010c688 <intr_routine_apic_spi>:
 */
void
intr_routine_apic_spi(const isr_param* param)
{
    // FUTURE: do nothing for now
}
c010c688:	c3                   	ret    

c010c689 <kprintf>:
LOG_MODULE("INTR")
c010c689:	55                   	push   %ebp
c010c68a:	89 e5                	mov    %esp,%ebp
c010c68c:	83 ec 0c             	sub    $0xc,%esp
c010c68f:	8d 45 0c             	lea    0xc(%ebp),%eax
c010c692:	50                   	push   %eax
c010c693:	ff 75 08             	push   0x8(%ebp)
c010c696:	68 74 33 d1 c0       	push   $0xc0d13374
c010c69b:	e8 d7 f8 ff ff       	call   c010bf77 <__kprintf>
c010c6a0:	83 c4 10             	add    $0x10,%esp
c010c6a3:	c9                   	leave  
c010c6a4:	c3                   	ret    

c010c6a5 <__print_panic_msg>:
{
c010c6a5:	55                   	push   %ebp
c010c6a6:	89 e5                	mov    %esp,%ebp
c010c6a8:	83 ec 10             	sub    $0x10,%esp
c010c6ab:	8b 45 0c             	mov    0xc(%ebp),%eax
    kprint_panic("  INT %u: (%x) [%p: %p] %s",
c010c6ae:	ff 75 08             	push   0x8(%ebp)
c010c6b1:	ff 70 38             	push   0x38(%eax)
c010c6b4:	ff 70 3c             	push   0x3c(%eax)
c010c6b7:	ff 70 34             	push   0x34(%eax)
c010c6ba:	ff 70 30             	push   0x30(%eax)
c010c6bd:	68 79 33 d1 c0       	push   $0xc0d13379
c010c6c2:	e8 dd f9 ff ff       	call   c010c0a4 <kprint_panic>
}
c010c6c7:	83 c4 20             	add    $0x20,%esp
c010c6ca:	c9                   	leave  
c010c6cb:	c3                   	ret    

c010c6cc <intr_routine_divide_zero>:
{
c010c6cc:	55                   	push   %ebp
c010c6cd:	89 e5                	mov    %esp,%ebp
c010c6cf:	83 ec 10             	sub    $0x10,%esp
    __print_panic_msg("Divide by zero!", param);
c010c6d2:	ff 75 08             	push   0x8(%ebp)
c010c6d5:	68 94 33 d1 c0       	push   $0xc0d13394
c010c6da:	e8 c6 ff ff ff       	call   c010c6a5 <__print_panic_msg>
c010c6df:	83 c4 10             	add    $0x10,%esp
c010c6e2:	eb fe                	jmp    c010c6e2 <intr_routine_divide_zero+0x16>

c010c6e4 <intr_routine_general_protection>:
{
c010c6e4:	55                   	push   %ebp
c010c6e5:	89 e5                	mov    %esp,%ebp
c010c6e7:	83 ec 10             	sub    $0x10,%esp
    kprintf(KERROR "Addr: %p\n", (&debug_resv)[0]);
c010c6ea:	ff 35 10 0e d1 c0    	push   0xc0d10e10
c010c6f0:	68 a4 33 d1 c0       	push   $0xc0d133a4
c010c6f5:	e8 8f ff ff ff       	call   c010c689 <kprintf>
    kprintf(KERROR "Expected: %p\n", __current->intr_ctx.eip);
c010c6fa:	a1 8c 05 d1 c0       	mov    0xc0d1058c,%eax
c010c6ff:	8b 40 40             	mov    0x40(%eax),%eax
c010c702:	83 c4 08             	add    $0x8,%esp
c010c705:	50                   	push   %eax
c010c706:	68 b0 33 d1 c0       	push   $0xc0d133b0
c010c70b:	e8 79 ff ff ff       	call   c010c689 <kprintf>
    __print_panic_msg("General Protection", param);
c010c710:	83 c4 08             	add    $0x8,%esp
c010c713:	ff 75 08             	push   0x8(%ebp)
c010c716:	68 c0 33 d1 c0       	push   $0xc0d133c0
c010c71b:	e8 85 ff ff ff       	call   c010c6a5 <__print_panic_msg>
c010c720:	83 c4 10             	add    $0x10,%esp
c010c723:	eb fe                	jmp    c010c723 <intr_routine_general_protection+0x3f>

c010c725 <intr_routine_sys_panic>:
{
c010c725:	55                   	push   %ebp
c010c726:	89 e5                	mov    %esp,%ebp
c010c728:	83 ec 10             	sub    $0x10,%esp
c010c72b:	8b 45 08             	mov    0x8(%ebp),%eax
    __print_panic_msg((char*)(param->registers.edi), param);
c010c72e:	50                   	push   %eax
c010c72f:	ff 70 10             	push   0x10(%eax)
c010c732:	e8 6e ff ff ff       	call   c010c6a5 <__print_panic_msg>
c010c737:	83 c4 10             	add    $0x10,%esp
c010c73a:	eb fe                	jmp    c010c73a <intr_routine_sys_panic+0x15>

c010c73c <intr_routine_fallback>:
{
c010c73c:	55                   	push   %ebp
c010c73d:	89 e5                	mov    %esp,%ebp
c010c73f:	83 ec 10             	sub    $0x10,%esp
    __print_panic_msg("Unknown Interrupt", param);
c010c742:	ff 75 08             	push   0x8(%ebp)
c010c745:	68 d3 33 d1 c0       	push   $0xc0d133d3
c010c74a:	e8 56 ff ff ff       	call   c010c6a5 <__print_panic_msg>
c010c74f:	83 c4 10             	add    $0x10,%esp
c010c752:	eb fe                	jmp    c010c752 <intr_routine_fallback+0x16>

c010c754 <intr_routine_apic_error>:

void
intr_routine_apic_error(const isr_param* param)
{
c010c754:	55                   	push   %ebp
c010c755:	89 e5                	mov    %esp,%ebp
c010c757:	53                   	push   %ebx
c010c758:	83 ec 28             	sub    $0x28,%esp
    uint32_t error_reg = apic_read_reg(APIC_ESR);
    char buf[32];
    sprintf(buf, "APIC error, ESR=0x%x", error_reg);
c010c75b:	ff 35 80 02 c0 d0    	push   0xd0c00280
c010c761:	68 e5 33 d1 c0       	push   $0xc0d133e5
c010c766:	8d 5d d8             	lea    -0x28(%ebp),%ebx
c010c769:	53                   	push   %ebx
c010c76a:	e8 1c 24 00 00       	call   c010eb8b <sprintf>
    __print_panic_msg(buf, param);
c010c76f:	83 c4 08             	add    $0x8,%esp
c010c772:	ff 75 08             	push   0x8(%ebp)
c010c775:	53                   	push   %ebx
c010c776:	e8 2a ff ff ff       	call   c010c6a5 <__print_panic_msg>
c010c77b:	83 c4 10             	add    $0x10,%esp
c010c77e:	eb fe                	jmp    c010c77e <intr_routine_apic_error+0x2a>

c010c780 <intr_routine_init>:
    spin();
}

void
intr_routine_init()
{
c010c780:	55                   	push   %ebp
c010c781:	89 e5                	mov    %esp,%ebp
c010c783:	83 ec 10             	sub    $0x10,%esp
    intr_subscribe(FAULT_DIVISION_ERROR, intr_routine_divide_zero);
c010c786:	68 cc c6 10 c0       	push   $0xc010c6cc
c010c78b:	6a 00                	push   $0x0
c010c78d:	e8 e4 f9 ff ff       	call   c010c176 <intr_subscribe>
    intr_subscribe(FAULT_GENERAL_PROTECTION, intr_routine_general_protection);
c010c792:	83 c4 08             	add    $0x8,%esp
c010c795:	68 e4 c6 10 c0       	push   $0xc010c6e4
c010c79a:	6a 0d                	push   $0xd
c010c79c:	e8 d5 f9 ff ff       	call   c010c176 <intr_subscribe>
    intr_subscribe(FAULT_PAGE_FAULT, intr_routine_page_fault);
c010c7a1:	83 c4 08             	add    $0x8,%esp
c010c7a4:	68 ee c4 10 c0       	push   $0xc010c4ee
c010c7a9:	6a 0e                	push   $0xe
c010c7ab:	e8 c6 f9 ff ff       	call   c010c176 <intr_subscribe>
    intr_subscribe(FAULT_STACK_SEG_FAULT, intr_routine_page_fault);
c010c7b0:	83 c4 08             	add    $0x8,%esp
c010c7b3:	68 ee c4 10 c0       	push   $0xc010c4ee
c010c7b8:	6a 0c                	push   $0xc
c010c7ba:	e8 b7 f9 ff ff       	call   c010c176 <intr_subscribe>
    intr_subscribe(LUNAIX_SYS_PANIC, intr_routine_sys_panic);
c010c7bf:	83 c4 08             	add    $0x8,%esp
c010c7c2:	68 25 c7 10 c0       	push   $0xc010c725
c010c7c7:	6a 20                	push   $0x20
c010c7c9:	e8 a8 f9 ff ff       	call   c010c176 <intr_subscribe>
    intr_subscribe(APIC_SPIV_IV, intr_routine_apic_spi);
c010c7ce:	83 c4 08             	add    $0x8,%esp
c010c7d1:	68 88 c6 10 c0       	push   $0xc010c688
c010c7d6:	68 fc 00 00 00       	push   $0xfc
c010c7db:	e8 96 f9 ff ff       	call   c010c176 <intr_subscribe>
    intr_subscribe(APIC_ERROR_IV, intr_routine_apic_error);
c010c7e0:	83 c4 08             	add    $0x8,%esp
c010c7e3:	68 54 c7 10 c0       	push   $0xc010c754
c010c7e8:	68 fa 00 00 00       	push   $0xfa
c010c7ed:	e8 84 f9 ff ff       	call   c010c176 <intr_subscribe>

    intr_set_fallback_handler(intr_routine_fallback);
c010c7f2:	c7 04 24 3c c7 10 c0 	movl   $0xc010c73c,(%esp)
c010c7f9:	e8 ad f9 ff ff       	call   c010c1ab <intr_set_fallback_handler>
c010c7fe:	83 c4 10             	add    $0x10,%esp
c010c801:	c9                   	leave  
c010c802:	c3                   	ret    

c010c803 <syscall_hndlr>:
c010c803:	55                   	push   %ebp
c010c804:	8b 6c 24 08          	mov    0x8(%esp),%ebp
c010c808:	8b 45 00             	mov    0x0(%ebp),%eax
c010c80b:	3d 00 01 00 00       	cmp    $0x100,%eax
c010c810:	73 0d                	jae    c010c81f <syscall_hndlr+0x1c>
c010c812:	c1 e0 02             	shl    $0x2,%eax
c010c815:	05 e8 20 d1 c0       	add    $0xc0d120e8,%eax
c010c81a:	83 38 00             	cmpl   $0x0,(%eax)
c010c81d:	75 04                	jne    c010c823 <syscall_hndlr+0x20>
c010c81f:	f7 d8                	neg    %eax
c010c821:	5d                   	pop    %ebp
c010c822:	c3                   	ret    
c010c823:	ff 75 18             	push   0x18(%ebp)
c010c826:	ff 75 14             	push   0x14(%ebp)
c010c829:	ff 75 10             	push   0x10(%ebp)
c010c82c:	ff 75 0c             	push   0xc(%ebp)
c010c82f:	ff 75 08             	push   0x8(%ebp)
c010c832:	ff 75 04             	push   0x4(%ebp)
c010c835:	ff 10                	call   *(%eax)
c010c837:	89 45 00             	mov    %eax,0x0(%ebp)
c010c83a:	83 c4 18             	add    $0x18,%esp
c010c83d:	5d                   	pop    %ebp
c010c83e:	c3                   	ret    

c010c83f <_set_idt_intr_entry>:
void
_set_idt_intr_entry(uint32_t vector,
                    uint16_t seg_selector,
                    void (*isr)(),
                    uint8_t dpl)
{
c010c83f:	55                   	push   %ebp
c010c840:	89 e5                	mov    %esp,%ebp
c010c842:	53                   	push   %ebx
c010c843:	8b 55 08             	mov    0x8(%ebp),%edx
c010c846:	8b 4d 10             	mov    0x10(%ebp),%ecx
    _idt[vector] = (offset & 0xffff0000) | IDT_ATTR(dpl, type);
c010c849:	89 cb                	mov    %ecx,%ebx
c010c84b:	66 bb 00 00          	mov    $0x0,%bx
c010c84f:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
c010c853:	c1 e0 0d             	shl    $0xd,%eax
c010c856:	25 00 60 00 00       	and    $0x6000,%eax
c010c85b:	80 cc 0e             	or     $0xe,%ah
c010c85e:	09 d8                	or     %ebx,%eax
c010c860:	80 cc 80             	or     $0x80,%ah
c010c863:	89 04 d5 a0 0e d1 c0 	mov    %eax,-0x3f2ef160(,%edx,8)
c010c86a:	c7 04 d5 a4 0e d1 c0 	movl   $0x0,-0x3f2ef15c(,%edx,8)
c010c871:	00 00 00 00 
    _idt[vector] <<= 32;
c010c875:	c7 04 d5 a0 0e d1 c0 	movl   $0x0,-0x3f2ef160(,%edx,8)
c010c87c:	00 00 00 00 
c010c880:	89 04 d5 a4 0e d1 c0 	mov    %eax,-0x3f2ef15c(,%edx,8)
    _idt[vector] |= (seg_selector << 16) | (offset & 0x0000ffff);
c010c887:	0f b7 5d 0c          	movzwl 0xc(%ebp),%ebx
c010c88b:	c1 e3 10             	shl    $0x10,%ebx
c010c88e:	0f b7 c9             	movzwl %cx,%ecx
c010c891:	09 d9                	or     %ebx,%ecx
c010c893:	89 0c d5 a0 0e d1 c0 	mov    %ecx,-0x3f2ef160(,%edx,8)
c010c89a:	89 04 d5 a4 0e d1 c0 	mov    %eax,-0x3f2ef15c(,%edx,8)
    _set_idt_entry(vector, seg_selector, isr, dpl, IDT_INTERRUPT);
}
c010c8a1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c010c8a4:	c9                   	leave  
c010c8a5:	c3                   	ret    

c010c8a6 <_set_idt_trap_entry>:
void
_set_idt_trap_entry(uint32_t vector,
                    uint16_t seg_selector,
                    void (*isr)(),
                    uint8_t dpl)
{
c010c8a6:	55                   	push   %ebp
c010c8a7:	89 e5                	mov    %esp,%ebp
c010c8a9:	53                   	push   %ebx
c010c8aa:	8b 55 08             	mov    0x8(%ebp),%edx
c010c8ad:	8b 4d 10             	mov    0x10(%ebp),%ecx
    _idt[vector] = (offset & 0xffff0000) | IDT_ATTR(dpl, type);
c010c8b0:	89 cb                	mov    %ecx,%ebx
c010c8b2:	66 bb 00 00          	mov    $0x0,%bx
c010c8b6:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
c010c8ba:	c1 e0 0d             	shl    $0xd,%eax
c010c8bd:	25 00 60 00 00       	and    $0x6000,%eax
c010c8c2:	80 cc 0f             	or     $0xf,%ah
c010c8c5:	09 d8                	or     %ebx,%eax
c010c8c7:	80 cc 80             	or     $0x80,%ah
c010c8ca:	89 04 d5 a0 0e d1 c0 	mov    %eax,-0x3f2ef160(,%edx,8)
c010c8d1:	c7 04 d5 a4 0e d1 c0 	movl   $0x0,-0x3f2ef15c(,%edx,8)
c010c8d8:	00 00 00 00 
    _idt[vector] <<= 32;
c010c8dc:	c7 04 d5 a0 0e d1 c0 	movl   $0x0,-0x3f2ef160(,%edx,8)
c010c8e3:	00 00 00 00 
c010c8e7:	89 04 d5 a4 0e d1 c0 	mov    %eax,-0x3f2ef15c(,%edx,8)
    _idt[vector] |= (seg_selector << 16) | (offset & 0x0000ffff);
c010c8ee:	0f b7 5d 0c          	movzwl 0xc(%ebp),%ebx
c010c8f2:	c1 e3 10             	shl    $0x10,%ebx
c010c8f5:	0f b7 c9             	movzwl %cx,%ecx
c010c8f8:	09 d9                	or     %ebx,%ecx
c010c8fa:	89 0c d5 a0 0e d1 c0 	mov    %ecx,-0x3f2ef160(,%edx,8)
c010c901:	89 04 d5 a4 0e d1 c0 	mov    %eax,-0x3f2ef15c(,%edx,8)
    _set_idt_entry(vector, seg_selector, isr, dpl, IDT_TRAP);
}
c010c908:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c010c90b:	c9                   	leave  
c010c90c:	c3                   	ret    

c010c90d <_init_idt>:

void
_init_idt()
{
c010c90d:	55                   	push   %ebp
c010c90e:	89 e5                	mov    %esp,%ebp
c010c910:	83 ec 08             	sub    $0x8,%esp
    // CPU defined interrupts
    _set_idt_intr_entry(FAULT_DIVISION_ERROR, 0x08, _asm_isr0, 0);
c010c913:	6a 00                	push   $0x0
c010c915:	68 40 c3 10 c0       	push   $0xc010c340
c010c91a:	6a 08                	push   $0x8
c010c91c:	6a 00                	push   $0x0
c010c91e:	e8 1c ff ff ff       	call   c010c83f <_set_idt_intr_entry>
    _set_idt_intr_entry(FAULT_GENERAL_PROTECTION, 0x08, _asm_isr13, 0);
c010c923:	6a 00                	push   $0x0
c010c925:	68 46 c3 10 c0       	push   $0xc010c346
c010c92a:	6a 08                	push   $0x8
c010c92c:	6a 0d                	push   $0xd
c010c92e:	e8 0c ff ff ff       	call   c010c83f <_set_idt_intr_entry>
    _set_idt_intr_entry(FAULT_PAGE_FAULT, 0x08, _asm_isr14, 0);
c010c933:	83 c4 20             	add    $0x20,%esp
c010c936:	6a 00                	push   $0x0
c010c938:	68 4a c3 10 c0       	push   $0xc010c34a
c010c93d:	6a 08                	push   $0x8
c010c93f:	6a 0e                	push   $0xe
c010c941:	e8 f9 fe ff ff       	call   c010c83f <_set_idt_intr_entry>
    _set_idt_intr_entry(FAULT_STACK_SEG_FAULT, 0x08, _asm_isr12, 0);
c010c946:	6a 00                	push   $0x0
c010c948:	68 4e c3 10 c0       	push   $0xc010c34e
c010c94d:	6a 08                	push   $0x8
c010c94f:	6a 0c                	push   $0xc
c010c951:	e8 e9 fe ff ff       	call   c010c83f <_set_idt_intr_entry>

    _set_idt_intr_entry(APIC_ERROR_IV, 0x08, _asm_isr250, 0);
c010c956:	83 c4 20             	add    $0x20,%esp
c010c959:	6a 00                	push   $0x0
c010c95b:	68 5e c3 10 c0       	push   $0xc010c35e
c010c960:	6a 08                	push   $0x8
c010c962:	68 fa 00 00 00       	push   $0xfa
c010c967:	e8 d3 fe ff ff       	call   c010c83f <_set_idt_intr_entry>
    _set_idt_intr_entry(APIC_LINT0_IV, 0x08, _asm_isr251, 0);
c010c96c:	6a 00                	push   $0x0
c010c96e:	68 67 c3 10 c0       	push   $0xc010c367
c010c973:	6a 08                	push   $0x8
c010c975:	68 fb 00 00 00       	push   $0xfb
c010c97a:	e8 c0 fe ff ff       	call   c010c83f <_set_idt_intr_entry>
    _set_idt_intr_entry(APIC_SPIV_IV, 0x08, _asm_isr252, 0);
c010c97f:	83 c4 20             	add    $0x20,%esp
c010c982:	6a 00                	push   $0x0
c010c984:	68 79 c3 10 c0       	push   $0xc010c379
c010c989:	6a 08                	push   $0x8
c010c98b:	68 fc 00 00 00       	push   $0xfc
c010c990:	e8 aa fe ff ff       	call   c010c83f <_set_idt_intr_entry>
    _set_idt_intr_entry(APIC_TIMER_IV, 0x08, _asm_isr253, 0);
c010c995:	6a 00                	push   $0x0
c010c997:	68 70 c3 10 c0       	push   $0xc010c370
c010c99c:	6a 08                	push   $0x8
c010c99e:	68 fd 00 00 00       	push   $0xfd
c010c9a3:	e8 97 fe ff ff       	call   c010c83f <_set_idt_intr_entry>
    _set_idt_intr_entry(PC_KBD_IV, 0x08, _asm_isr201, 0);
c010c9a8:	83 c4 20             	add    $0x20,%esp
c010c9ab:	6a 00                	push   $0x0
c010c9ad:	68 8b c3 10 c0       	push   $0xc010c38b
c010c9b2:	6a 08                	push   $0x8
c010c9b4:	68 c9 00 00 00       	push   $0xc9
c010c9b9:	e8 81 fe ff ff       	call   c010c83f <_set_idt_intr_entry>

    _set_idt_intr_entry(RTC_TIMER_IV, 0x08, _asm_isr210, 0);
c010c9be:	6a 00                	push   $0x0
c010c9c0:	68 82 c3 10 c0       	push   $0xc010c382
c010c9c5:	6a 08                	push   $0x8
c010c9c7:	68 d2 00 00 00       	push   $0xd2
c010c9cc:	e8 6e fe ff ff       	call   c010c83f <_set_idt_intr_entry>

    // system defined interrupts
    _set_idt_intr_entry(LUNAIX_SYS_PANIC, 0x08, _asm_isr32, 0);
c010c9d1:	83 c4 20             	add    $0x20,%esp
c010c9d4:	6a 00                	push   $0x0
c010c9d6:	68 52 c3 10 c0       	push   $0xc010c352
c010c9db:	6a 08                	push   $0x8
c010c9dd:	6a 20                	push   $0x20
c010c9df:	e8 5b fe ff ff       	call   c010c83f <_set_idt_intr_entry>

    // We make this a non-trap entry, and enable interrupt
    // only when needed!
    _set_idt_intr_entry(LUNAIX_SYS_CALL, 0x08, _asm_isr33, 3);
c010c9e4:	6a 03                	push   $0x3
c010c9e6:	68 58 c3 10 c0       	push   $0xc010c358
c010c9eb:	6a 08                	push   $0x8
c010c9ed:	6a 21                	push   $0x21
c010c9ef:	e8 4b fe ff ff       	call   c010c83f <_set_idt_intr_entry>
c010c9f4:	83 c4 20             	add    $0x20,%esp
c010c9f7:	c9                   	leave  
c010c9f8:	c3                   	ret    

c010c9f9 <fork>:
__LXSYSCALL(pid_t, fork)
c010c9f9:	b8 01 00 00 00       	mov    $0x1,%eax
c010c9fe:	cd 21                	int    $0x21
c010ca00:	c3                   	ret    

c010ca01 <getpid>:
__LXSYSCALL(pid_t, getpid)
c010ca01:	b8 05 00 00 00       	mov    $0x5,%eax
c010ca06:	cd 21                	int    $0x21
c010ca08:	c3                   	ret    

c010ca09 <_exit>:
__LXSYSCALL1(void, _exit, int, status)
c010ca09:	55                   	push   %ebp
c010ca0a:	89 e5                	mov    %esp,%ebp
c010ca0c:	53                   	push   %ebx
c010ca0d:	89 c3                	mov    %eax,%ebx
c010ca0f:	b8 08 00 00 00       	mov    $0x8,%eax
c010ca14:	cd 21                	int    $0x21
c010ca16:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c010ca19:	c9                   	leave  
c010ca1a:	c3                   	ret    

c010ca1b <sleep>:

__LXSYSCALL1(unsigned int, sleep, unsigned int, seconds)
c010ca1b:	55                   	push   %ebp
c010ca1c:	89 e5                	mov    %esp,%ebp
c010ca1e:	53                   	push   %ebx
c010ca1f:	89 c3                	mov    %eax,%ebx
c010ca21:	b8 07 00 00 00       	mov    $0x7,%eax
c010ca26:	cd 21                	int    $0x21
c010ca28:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c010ca2b:	c9                   	leave  
c010ca2c:	c3                   	ret    

c010ca2d <pause>:

__LXSYSCALL(int, pause)
c010ca2d:	b8 0e 00 00 00       	mov    $0xe,%eax
c010ca32:	cd 21                	int    $0x21
c010ca34:	c3                   	ret    

c010ca35 <alarm>:

__LXSYSCALL2(int, kill, pid_t, pid, int, signum)

__LXSYSCALL1(unsigned int, alarm, unsigned int, seconds)
c010ca35:	55                   	push   %ebp
c010ca36:	89 e5                	mov    %esp,%ebp
c010ca38:	53                   	push   %ebx
c010ca39:	89 c3                	mov    %eax,%ebx
c010ca3b:	b8 10 00 00 00       	mov    $0x10,%eax
c010ca40:	cd 21                	int    $0x21
c010ca42:	5b                   	pop    %ebx
c010ca43:	5d                   	pop    %ebp
c010ca44:	c3                   	ret    

c010ca45 <wait>:
#include <lunaix/syscall.h>
#include <lunaix/types.h>

__LXSYSCALL(void, yield);

__LXSYSCALL1(pid_t, wait, int*, status);
c010ca45:	55                   	push   %ebp
c010ca46:	89 e5                	mov    %esp,%ebp
c010ca48:	53                   	push   %ebx
c010ca49:	89 c3                	mov    %eax,%ebx
c010ca4b:	b8 09 00 00 00       	mov    $0x9,%eax
c010ca50:	cd 21                	int    $0x21
c010ca52:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c010ca55:	c9                   	leave  
c010ca56:	c3                   	ret    

c010ca57 <signal>:
#define _SIG_SETMASK 3

typedef unsigned int sigset_t;
typedef void (*sighandler_t)(int);

__LXSYSCALL2(int, signal, int, signum, sighandler_t, handler);
c010ca57:	55                   	push   %ebp
c010ca58:	89 e5                	mov    %esp,%ebp
c010ca5a:	53                   	push   %ebx
c010ca5b:	89 c3                	mov    %eax,%ebx
c010ca5d:	89 d1                	mov    %edx,%ecx
c010ca5f:	b8 0d 00 00 00       	mov    $0xd,%eax
c010ca64:	cd 21                	int    $0x21
c010ca66:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c010ca69:	c9                   	leave  
c010ca6a:	c3                   	ret    

c010ca6b <kprintf>:
#include <lunaix/signal.h>
#include <lunaix/spike.h>
#include <lunaix/syslog.h>
#include <lunaix/types.h>

LOG_MODULE("SIGDEMO")
c010ca6b:	55                   	push   %ebp
c010ca6c:	89 e5                	mov    %esp,%ebp
c010ca6e:	83 ec 0c             	sub    $0xc,%esp
c010ca71:	8d 45 0c             	lea    0xc(%ebp),%eax
c010ca74:	50                   	push   %eax
c010ca75:	ff 75 08             	push   0x8(%ebp)
c010ca78:	68 fa 33 d1 c0       	push   $0xc0d133fa
c010ca7d:	e8 f5 f4 ff ff       	call   c010bf77 <__kprintf>
c010ca82:	83 c4 10             	add    $0x10,%esp
c010ca85:	c9                   	leave  
c010ca86:	c3                   	ret    

c010ca87 <syscall_install>:
extern void
syscall_hndlr(isr_param* param);

void
syscall_install()
{
c010ca87:	55                   	push   %ebp
c010ca88:	89 e5                	mov    %esp,%ebp
c010ca8a:	83 ec 10             	sub    $0x10,%esp
    intr_subscribe(LUNAIX_SYS_CALL, syscall_hndlr);
c010ca8d:	68 03 c8 10 c0       	push   $0xc010c803
c010ca92:	6a 21                	push   $0x21
c010ca94:	e8 dd f6 ff ff       	call   c010c176 <intr_subscribe>
c010ca99:	83 c4 10             	add    $0x10,%esp
c010ca9c:	c9                   	leave  
c010ca9d:	c3                   	ret    

c010ca9e <__flush_cb>:
    return !atomic_load(&mutex->counter);
c010ca9e:	a1 d8 16 d1 c0       	mov    0xc0d116d8,%eax
}

void
__flush_cb(void* arg)
{
    if (mutex_on_hold(&lx_console.buffer.lock)) {
c010caa3:	85 c0                	test   %eax,%eax
c010caa5:	74 09                	je     c010cab0 <__flush_cb+0x12>
        return;
    }
    if (!(lx_console.buffer.flags & FIFO_DIRTY)) {
c010caa7:	f6 05 d4 16 d1 c0 01 	testb  $0x1,0xc0d116d4
c010caae:	75 01                	jne    c010cab1 <__flush_cb+0x13>
c010cab0:	c3                   	ret    
{
c010cab1:	55                   	push   %ebp
c010cab2:	89 e5                	mov    %esp,%ebp
c010cab4:	83 ec 08             	sub    $0x8,%esp
        return;
    }

    tty_flush_buffer(lx_console.buffer.data,
c010cab7:	ff 35 d0 16 d1 c0    	push   0xc0d116d0
c010cabd:	ff 35 c8 16 d1 c0    	push   0xc0d116c8
c010cac3:	ff 35 dc 16 d1 c0    	push   0xc0d116dc
c010cac9:	ff 35 c4 16 d1 c0    	push   0xc0d116c4
c010cacf:	e8 21 e2 ff ff       	call   c010acf5 <tty_flush_buffer>
                     lx_console.erd_pos,
                     lx_console.buffer.wr_pos,
                     lx_console.buffer.size);
    lx_console.buffer.flags &= ~FIFO_DIRTY;
c010cad4:	a1 d4 16 d1 c0       	mov    0xc0d116d4,%eax
c010cad9:	83 e0 fe             	and    $0xfffffffe,%eax
c010cadc:	a3 d4 16 d1 c0       	mov    %eax,0xc0d116d4
c010cae1:	83 c4 10             	add    $0x10,%esp
}
c010cae4:	c9                   	leave  
c010cae5:	c3                   	ret    

c010cae6 <lxconsole_init>:
{
c010cae6:	55                   	push   %ebp
c010cae7:	89 e5                	mov    %esp,%ebp
c010cae9:	53                   	push   %ebx
c010caea:	83 ec 08             	sub    $0x8,%esp
    memset(&lx_console, 0, sizeof(lx_console));
c010caed:	6a 28                	push   $0x28
c010caef:	6a 00                	push   $0x0
c010caf1:	68 c0 16 d1 c0       	push   $0xc0d116c0
c010caf6:	e8 80 21 00 00       	call   c010ec7b <memset>
    lx_console.buffer.data = VGA_BUFFER_VADDR + 0x1000;
c010cafb:	c7 05 c4 16 d1 c0 00 	movl   $0xd0801000,0xc0d116c4
c010cb02:	10 80 d0 
    lx_console.buffer.size = 8192;
c010cb05:	c7 05 d0 16 d1 c0 00 	movl   $0x2000,0xc0d116d0
c010cb0c:	20 00 00 
    sem_init(mutex, 1);
c010cb0f:	83 c4 08             	add    $0x8,%esp
c010cb12:	6a 01                	push   $0x1
c010cb14:	68 d8 16 d1 c0       	push   $0xc0d116d8
c010cb19:	e8 65 eb ff ff       	call   c010b683 <sem_init>
    for (size_t i = 0; i < PG_ALIGN(lx_console.buffer.size); i += PG_SIZE) {
c010cb1e:	83 c4 10             	add    $0x10,%esp
c010cb21:	bb 00 00 00 00       	mov    $0x0,%ebx
c010cb26:	eb 32                	jmp    c010cb5a <lxconsole_init+0x74>
        uintptr_t pa = pmm_alloc_page(KERNEL_PID, 0);
c010cb28:	83 ec 08             	sub    $0x8,%esp
c010cb2b:	6a 00                	push   $0x0
c010cb2d:	6a ff                	push   $0xffffffff
c010cb2f:	e8 93 df ff ff       	call   c010aac7 <pmm_alloc_page>
        vmm_set_mapping(PD_REFERENCED,
c010cb34:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c010cb3b:	6a 07                	push   $0x7
c010cb3d:	50                   	push   %eax
c010cb3e:	89 d8                	mov    %ebx,%eax
c010cb40:	03 05 c4 16 d1 c0    	add    0xc0d116c4,%eax
c010cb46:	50                   	push   %eax
c010cb47:	68 00 00 c0 ff       	push   $0xffc00000
c010cb4c:	e8 ef d8 ff ff       	call   c010a440 <vmm_set_mapping>
    for (size_t i = 0; i < PG_ALIGN(lx_console.buffer.size); i += PG_SIZE) {
c010cb51:	81 c3 00 10 00 00    	add    $0x1000,%ebx
c010cb57:	83 c4 20             	add    $0x20,%esp
c010cb5a:	a1 d0 16 d1 c0       	mov    0xc0d116d0,%eax
c010cb5f:	89 c2                	mov    %eax,%edx
c010cb61:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
c010cb67:	39 da                	cmp    %ebx,%edx
c010cb69:	77 bd                	ja     c010cb28 <lxconsole_init+0x42>
    memset(lx_console.buffer.data, 0, lx_console.buffer.size);
c010cb6b:	83 ec 04             	sub    $0x4,%esp
c010cb6e:	50                   	push   %eax
c010cb6f:	6a 00                	push   $0x0
c010cb71:	ff 35 c4 16 d1 c0    	push   0xc0d116c4
c010cb77:	e8 ff 20 00 00       	call   c010ec7b <memset>
    lx_console.flush_timer = NULL;
c010cb7c:	c7 05 c0 16 d1 c0 00 	movl   $0x0,0xc0d116c0
c010cb83:	00 00 00 
}
c010cb86:	83 c4 10             	add    $0x10,%esp
c010cb89:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c010cb8c:	c9                   	leave  
c010cb8d:	c3                   	ret    

c010cb8e <console_schedule_flush>:
}
c010cb8e:	c3                   	ret    

c010cb8f <console_view_up>:
{
c010cb8f:	55                   	push   %ebp
c010cb90:	89 e5                	mov    %esp,%ebp
c010cb92:	83 ec 14             	sub    $0x14,%esp
    sem_wait(mutex);
c010cb95:	68 d8 16 d1 c0       	push   $0xc0d116d8
c010cb9a:	e8 f1 ea ff ff       	call   c010b690 <sem_wait>
    size_t p = lx_console.erd_pos - 2;
c010cb9f:	8b 0d dc 16 d1 c0    	mov    0xc0d116dc,%ecx
c010cba5:	8d 41 fe             	lea    -0x2(%ecx),%eax
    while (p < lx_console.erd_pos && p != buffer->wr_pos &&
c010cba8:	83 c4 10             	add    $0x10,%esp
c010cbab:	eb 03                	jmp    c010cbb0 <console_view_up+0x21>
        p--;
c010cbad:	83 e8 01             	sub    $0x1,%eax
    while (p < lx_console.erd_pos && p != buffer->wr_pos &&
c010cbb0:	39 c1                	cmp    %eax,%ecx
c010cbb2:	76 14                	jbe    c010cbc8 <console_view_up+0x39>
c010cbb4:	39 05 c8 16 d1 c0    	cmp    %eax,0xc0d116c8
c010cbba:	74 0c                	je     c010cbc8 <console_view_up+0x39>
c010cbbc:	8b 15 c4 16 d1 c0    	mov    0xc0d116c4,%edx
c010cbc2:	80 3c 02 0a          	cmpb   $0xa,(%edx,%eax,1)
c010cbc6:	75 e5                	jne    c010cbad <console_view_up+0x1e>
    p++;
c010cbc8:	83 c0 01             	add    $0x1,%eax
    if (p > lx_console.erd_pos) {
c010cbcb:	39 c1                	cmp    %eax,%ecx
c010cbcd:	73 05                	jae    c010cbd4 <console_view_up+0x45>
        p = 0;
c010cbcf:	b8 00 00 00 00       	mov    $0x0,%eax
    buffer->flags |= FIFO_DIRTY;
c010cbd4:	8b 15 d4 16 d1 c0    	mov    0xc0d116d4,%edx
c010cbda:	83 ca 01             	or     $0x1,%edx
c010cbdd:	89 15 d4 16 d1 c0    	mov    %edx,0xc0d116d4
    lx_console.erd_pos = p;
c010cbe3:	a3 dc 16 d1 c0       	mov    %eax,0xc0d116dc
    sem_post(mutex);
c010cbe8:	83 ec 0c             	sub    $0xc,%esp
c010cbeb:	68 d8 16 d1 c0       	push   $0xc0d116d8
c010cbf0:	e8 ad ea ff ff       	call   c010b6a2 <sem_post>
}
c010cbf5:	83 c4 10             	add    $0x10,%esp
c010cbf8:	c9                   	leave  
c010cbf9:	c3                   	ret    

c010cbfa <__find_next_line>:
{
c010cbfa:	55                   	push   %ebp
c010cbfb:	89 e5                	mov    %esp,%ebp
c010cbfd:	8b 55 08             	mov    0x8(%ebp),%edx
    while (p != lx_console.buffer.wr_pos &&
c010cc00:	eb 0e                	jmp    c010cc10 <__find_next_line+0x16>
        p = (p + 1) % lx_console.buffer.size;
c010cc02:	8d 42 01             	lea    0x1(%edx),%eax
c010cc05:	ba 00 00 00 00       	mov    $0x0,%edx
c010cc0a:	f7 35 d0 16 d1 c0    	divl   0xc0d116d0
    while (p != lx_console.buffer.wr_pos &&
c010cc10:	39 15 c8 16 d1 c0    	cmp    %edx,0xc0d116c8
c010cc16:	74 0b                	je     c010cc23 <__find_next_line+0x29>
c010cc18:	a1 c4 16 d1 c0       	mov    0xc0d116c4,%eax
c010cc1d:	80 3c 10 0a          	cmpb   $0xa,(%eax,%edx,1)
c010cc21:	75 df                	jne    c010cc02 <__find_next_line+0x8>
    return p + 1;
c010cc23:	8d 42 01             	lea    0x1(%edx),%eax
}
c010cc26:	5d                   	pop    %ebp
c010cc27:	c3                   	ret    

c010cc28 <console_view_down>:
{
c010cc28:	55                   	push   %ebp
c010cc29:	89 e5                	mov    %esp,%ebp
c010cc2b:	83 ec 14             	sub    $0x14,%esp
    sem_wait(mutex);
c010cc2e:	68 d8 16 d1 c0       	push   $0xc0d116d8
c010cc33:	e8 58 ea ff ff       	call   c010b690 <sem_wait>
    lx_console.erd_pos = __find_next_line(lx_console.erd_pos);
c010cc38:	83 c4 04             	add    $0x4,%esp
c010cc3b:	ff 35 dc 16 d1 c0    	push   0xc0d116dc
c010cc41:	e8 b4 ff ff ff       	call   c010cbfa <__find_next_line>
c010cc46:	a3 dc 16 d1 c0       	mov    %eax,0xc0d116dc
    buffer->flags |= FIFO_DIRTY;
c010cc4b:	a1 d4 16 d1 c0       	mov    0xc0d116d4,%eax
c010cc50:	83 c8 01             	or     $0x1,%eax
c010cc53:	a3 d4 16 d1 c0       	mov    %eax,0xc0d116d4
    sem_post(mutex);
c010cc58:	c7 04 24 d8 16 d1 c0 	movl   $0xc0d116d8,(%esp)
c010cc5f:	e8 3e ea ff ff       	call   c010b6a2 <sem_post>
}
c010cc64:	83 c4 10             	add    $0x10,%esp
c010cc67:	c9                   	leave  
c010cc68:	c3                   	ret    

c010cc69 <console_write>:

void
console_write(struct console* console, uint8_t* data, size_t size)
{
c010cc69:	55                   	push   %ebp
c010cc6a:	89 e5                	mov    %esp,%ebp
c010cc6c:	57                   	push   %edi
c010cc6d:	56                   	push   %esi
c010cc6e:	53                   	push   %ebx
c010cc6f:	83 ec 28             	sub    $0x28,%esp
c010cc72:	8b 5d 08             	mov    0x8(%ebp),%ebx
    mutex_lock(&console->buffer.lock);
c010cc75:	8d 43 18             	lea    0x18(%ebx),%eax
c010cc78:	89 45 dc             	mov    %eax,-0x24(%ebp)
    sem_wait(mutex);
c010cc7b:	50                   	push   %eax
c010cc7c:	e8 0f ea ff ff       	call   c010b690 <sem_wait>
    uint8_t* buffer = console->buffer.data;
c010cc81:	8b 7b 04             	mov    0x4(%ebx),%edi
    uintptr_t ptr = console->buffer.wr_pos;
c010cc84:	8b 43 08             	mov    0x8(%ebx),%eax
c010cc87:	89 45 e0             	mov    %eax,-0x20(%ebp)
    uintptr_t rd_ptr = console->buffer.rd_pos;
c010cc8a:	8b 43 0c             	mov    0xc(%ebx),%eax
c010cc8d:	89 45 d8             	mov    %eax,-0x28(%ebp)

    char c;
    int lines = 0;
    for (size_t i = 0; i < size; i++) {
c010cc90:	83 c4 10             	add    $0x10,%esp
c010cc93:	b9 00 00 00 00       	mov    $0x0,%ecx
    int lines = 0;
c010cc98:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
c010cc9f:	89 de                	mov    %ebx,%esi
    for (size_t i = 0; i < size; i++) {
c010cca1:	eb 26                	jmp    c010ccc9 <console_write+0x60>
        c = data[i];
c010cca3:	8b 45 0c             	mov    0xc(%ebp),%eax
c010cca6:	0f b6 1c 08          	movzbl (%eax,%ecx,1),%ebx
        buffer[(ptr + i) % console->buffer.size] = c;
c010ccaa:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010ccad:	01 c8                	add    %ecx,%eax
c010ccaf:	ba 00 00 00 00       	mov    $0x0,%edx
c010ccb4:	f7 76 10             	divl   0x10(%esi)
c010ccb7:	88 1c 17             	mov    %bl,(%edi,%edx,1)
        // chars += (31 < c && c < 127);
        lines += (c == '\n');
c010ccba:	80 fb 0a             	cmp    $0xa,%bl
c010ccbd:	0f 94 c0             	sete   %al
c010ccc0:	0f b6 c0             	movzbl %al,%eax
c010ccc3:	01 45 e4             	add    %eax,-0x1c(%ebp)
    for (size_t i = 0; i < size; i++) {
c010ccc6:	83 c1 01             	add    $0x1,%ecx
c010ccc9:	3b 4d 10             	cmp    0x10(%ebp),%ecx
c010cccc:	72 d5                	jb     c010cca3 <console_write+0x3a>
    }

    uintptr_t new_ptr = (ptr + size) % console->buffer.size;
c010ccce:	89 f3                	mov    %esi,%ebx
c010ccd0:	8b 7d e0             	mov    -0x20(%ebp),%edi
c010ccd3:	03 7d 10             	add    0x10(%ebp),%edi
c010ccd6:	8b 4e 10             	mov    0x10(%esi),%ecx
c010ccd9:	89 f8                	mov    %edi,%eax
c010ccdb:	ba 00 00 00 00       	mov    $0x0,%edx
c010cce0:	f7 f1                	div    %ecx
c010cce2:	89 d6                	mov    %edx,%esi
    console->buffer.wr_pos = new_ptr;
c010cce4:	89 53 08             	mov    %edx,0x8(%ebx)

    if (console->lines > TTY_HEIGHT && lines > 0) {
c010cce7:	8b 43 20             	mov    0x20(%ebx),%eax
c010ccea:	89 45 e0             	mov    %eax,-0x20(%ebp)
c010cced:	83 f8 19             	cmp    $0x19,%eax
c010ccf0:	76 06                	jbe    c010ccf8 <console_write+0x8f>
c010ccf2:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c010ccf6:	7f 35                	jg     c010cd2d <console_write+0xc4>
        console->buffer.rd_pos =
          __find_next_line((size + rd_ptr) % console->buffer.size);
    }

    if (new_ptr < ptr + size && new_ptr > rd_ptr) {
c010ccf8:	39 f7                	cmp    %esi,%edi
c010ccfa:	76 08                	jbe    c010cd04 <console_write+0x9b>
c010ccfc:	39 75 d8             	cmp    %esi,-0x28(%ebp)
c010ccff:	73 03                	jae    c010cd04 <console_write+0x9b>
        console->buffer.rd_pos = new_ptr;
c010cd01:	89 73 0c             	mov    %esi,0xc(%ebx)
    }

    console->lines += lines;
c010cd04:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010cd07:	03 45 e0             	add    -0x20(%ebp),%eax
c010cd0a:	89 43 20             	mov    %eax,0x20(%ebx)
    console->erd_pos = console->buffer.rd_pos;
c010cd0d:	8b 43 0c             	mov    0xc(%ebx),%eax
c010cd10:	89 43 1c             	mov    %eax,0x1c(%ebx)
    console->buffer.flags |= FIFO_DIRTY;
c010cd13:	83 4b 14 01          	orl    $0x1,0x14(%ebx)
    sem_post(mutex);
c010cd17:	83 ec 0c             	sub    $0xc,%esp
c010cd1a:	ff 75 dc             	push   -0x24(%ebp)
c010cd1d:	e8 80 e9 ff ff       	call   c010b6a2 <sem_post>
    mutex_unlock(&console->buffer.lock);
}
c010cd22:	83 c4 10             	add    $0x10,%esp
c010cd25:	8d 65 f4             	lea    -0xc(%ebp),%esp
c010cd28:	5b                   	pop    %ebx
c010cd29:	5e                   	pop    %esi
c010cd2a:	5f                   	pop    %edi
c010cd2b:	5d                   	pop    %ebp
c010cd2c:	c3                   	ret    
          __find_next_line((size + rd_ptr) % console->buffer.size);
c010cd2d:	8b 45 d8             	mov    -0x28(%ebp),%eax
c010cd30:	03 45 10             	add    0x10(%ebp),%eax
c010cd33:	83 ec 0c             	sub    $0xc,%esp
c010cd36:	ba 00 00 00 00       	mov    $0x0,%edx
c010cd3b:	f7 f1                	div    %ecx
c010cd3d:	52                   	push   %edx
c010cd3e:	e8 b7 fe ff ff       	call   c010cbfa <__find_next_line>
c010cd43:	83 c4 10             	add    $0x10,%esp
        console->buffer.rd_pos =
c010cd46:	89 43 0c             	mov    %eax,0xc(%ebx)
c010cd49:	eb ad                	jmp    c010ccf8 <console_write+0x8f>

c010cd4b <console_write_str>:

void
console_write_str(char* str)
{
c010cd4b:	55                   	push   %ebp
c010cd4c:	89 e5                	mov    %esp,%ebp
c010cd4e:	53                   	push   %ebx
c010cd4f:	83 ec 10             	sub    $0x10,%esp
c010cd52:	8b 5d 08             	mov    0x8(%ebp),%ebx
    console_write(&lx_console, str, strlen(str));
c010cd55:	53                   	push   %ebx
c010cd56:	e8 96 1f 00 00       	call   c010ecf1 <strlen>
c010cd5b:	83 c4 0c             	add    $0xc,%esp
c010cd5e:	50                   	push   %eax
c010cd5f:	53                   	push   %ebx
c010cd60:	68 c0 16 d1 c0       	push   $0xc0d116c0
c010cd65:	e8 ff fe ff ff       	call   c010cc69 <console_write>
}
c010cd6a:	83 c4 10             	add    $0x10,%esp
c010cd6d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c010cd70:	c9                   	leave  
c010cd71:	c3                   	ret    

c010cd72 <console_write_char>:

void
console_write_char(char str)
{
c010cd72:	55                   	push   %ebp
c010cd73:	89 e5                	mov    %esp,%ebp
c010cd75:	83 ec 1c             	sub    $0x1c,%esp
c010cd78:	8b 45 08             	mov    0x8(%ebp),%eax
c010cd7b:	88 45 f4             	mov    %al,-0xc(%ebp)
    console_write(&lx_console, &str, 1);
c010cd7e:	6a 01                	push   $0x1
c010cd80:	8d 45 f4             	lea    -0xc(%ebp),%eax
c010cd83:	50                   	push   %eax
c010cd84:	68 c0 16 d1 c0       	push   $0xc0d116c0
c010cd89:	e8 db fe ff ff       	call   c010cc69 <console_write>
}
c010cd8e:	83 c4 10             	add    $0x10,%esp
c010cd91:	c9                   	leave  
c010cd92:	c3                   	ret    

c010cd93 <console_start_flushing>:

void
console_start_flushing()
{
c010cd93:	55                   	push   %ebp
c010cd94:	89 e5                	mov    %esp,%ebp
c010cd96:	83 ec 08             	sub    $0x8,%esp
    struct lx_timer* timer =
      timer_run_ms(20, __flush_cb, NULL, TIMER_MODE_PERIODIC);
c010cd99:	6a 01                	push   $0x1
c010cd9b:	6a 00                	push   $0x0
c010cd9d:	68 9e ca 10 c0       	push   $0xc010ca9e
c010cda2:	6a 14                	push   $0x14
c010cda4:	e8 8c f1 ff ff       	call   c010bf35 <timer_run_ms>
    lx_console.flush_timer = timer;
c010cda9:	a3 c0 16 d1 c0       	mov    %eax,0xc0d116c0
c010cdae:	83 c4 10             	add    $0x10,%esp
c010cdb1:	c9                   	leave  
c010cdb2:	c3                   	ret    

c010cdb3 <ps2_post_cmd>:
    while(!(io_inb(PS2_PORT_CTRL_STATUS) & PS2_STATUS_OFULL));

    return io_inb(PS2_PORT_ENC_CMDREG);
}

static void ps2_post_cmd(uint8_t port, char cmd, uint16_t arg) {
c010cdb3:	55                   	push   %ebp
c010cdb4:	89 e5                	mov    %esp,%ebp
c010cdb6:	56                   	push   %esi
c010cdb7:	53                   	push   %ebx
c010cdb8:	89 c3                	mov    %eax,%ebx
c010cdba:	89 d6                	mov    %edx,%esi
    asm volatile("inb %w1,%0" : "=a"(data) : "d"(port));
c010cdbc:	ba 64 00 00 00       	mov    $0x64,%edx
c010cdc1:	ec                   	in     (%dx),%al
    // 等待PS/2输入缓冲区清空，这样我们才可以写入命令
    while(io_inb(PS2_PORT_CTRL_STATUS) & PS2_STATUS_IFULL);
c010cdc2:	a8 02                	test   $0x2,%al
c010cdc4:	75 f6                	jne    c010cdbc <ps2_post_cmd+0x9>

    io_outb(port, cmd);
c010cdc6:	0f b6 d3             	movzbl %bl,%edx
    asm volatile("outb %0, %w1" : : "a"(data), "d"(port));
c010cdc9:	89 f0                	mov    %esi,%eax
c010cdcb:	ee                   	out    %al,(%dx)
    asm volatile("outl %0,%w1" : : "a"(data), "d"(port));
}
static inline void
io_delay(int counter)
{
    asm volatile (
c010cdcc:	b8 e8 03 00 00       	mov    $0x3e8,%eax
c010cdd1:	85 c0                	test   %eax,%eax
c010cdd3:	74 03                	je     c010cdd8 <ps2_post_cmd+0x25>
c010cdd5:	48                   	dec    %eax
c010cdd6:	75 fd                	jne    c010cdd5 <ps2_post_cmd+0x22>
c010cdd8:	48                   	dec    %eax
    io_delay(PS2_DELAY);
    
    if (!(arg & PS2_NO_ARG)) {
c010cdd9:	66 f7 c1 00 ff       	test   $0xff00,%cx
c010cdde:	75 15                	jne    c010cdf5 <ps2_post_cmd+0x42>
    asm volatile("outb %0, %w1" : : "a"(data), "d"(port));
c010cde0:	ba 60 00 00 00       	mov    $0x60,%edx
c010cde5:	89 c8                	mov    %ecx,%eax
c010cde7:	ee                   	out    %al,(%dx)
    asm volatile (
c010cde8:	b8 e8 03 00 00       	mov    $0x3e8,%eax
c010cded:	85 c0                	test   %eax,%eax
c010cdef:	74 03                	je     c010cdf4 <ps2_post_cmd+0x41>
c010cdf1:	48                   	dec    %eax
c010cdf2:	75 fd                	jne    c010cdf1 <ps2_post_cmd+0x3e>
c010cdf4:	48                   	dec    %eax
        // 所有参数一律通过0x60传入。
        io_outb(PS2_PORT_ENC_CMDREG, (uint8_t)(arg & 0x00ff));
        io_delay(PS2_DELAY);
    }
}
c010cdf5:	5b                   	pop    %ebx
c010cdf6:	5e                   	pop    %esi
c010cdf7:	5d                   	pop    %ebp
c010cdf8:	c3                   	ret    

c010cdf9 <ps2_issue_cmd>:
static uint8_t ps2_issue_cmd(char cmd, uint16_t arg) {
c010cdf9:	55                   	push   %ebp
c010cdfa:	89 e5                	mov    %esp,%ebp
c010cdfc:	83 ec 08             	sub    $0x8,%esp
    ps2_post_cmd(PS2_PORT_CTRL_CMDREG, cmd, arg);
c010cdff:	0f b7 ca             	movzwl %dx,%ecx
c010ce02:	0f be d0             	movsbl %al,%edx
c010ce05:	b8 64 00 00 00       	mov    $0x64,%eax
c010ce0a:	e8 a4 ff ff ff       	call   c010cdb3 <ps2_post_cmd>
    asm volatile("inb %w1,%0" : "=a"(data) : "d"(port));
c010ce0f:	ba 64 00 00 00       	mov    $0x64,%edx
c010ce14:	ec                   	in     (%dx),%al
    while(!(io_inb(PS2_PORT_CTRL_STATUS) & PS2_STATUS_OFULL));
c010ce15:	a8 01                	test   $0x1,%al
c010ce17:	74 f6                	je     c010ce0f <ps2_issue_cmd+0x16>
c010ce19:	ba 60 00 00 00       	mov    $0x60,%edx
c010ce1e:	ec                   	in     (%dx),%al
}
c010ce1f:	c9                   	leave  
c010ce20:	c3                   	ret    

c010ce21 <ps2_issue_dev_cmd>:

static uint8_t ps2_issue_dev_cmd(char cmd, uint16_t arg) {
c010ce21:	55                   	push   %ebp
c010ce22:	89 e5                	mov    %esp,%ebp
c010ce24:	83 ec 08             	sub    $0x8,%esp
    ps2_post_cmd(PS2_PORT_ENC_CMDREG, cmd, arg);
c010ce27:	0f b7 ca             	movzwl %dx,%ecx
c010ce2a:	0f be d0             	movsbl %al,%edx
c010ce2d:	b8 60 00 00 00       	mov    $0x60,%eax
c010ce32:	e8 7c ff ff ff       	call   c010cdb3 <ps2_post_cmd>
c010ce37:	ba 64 00 00 00       	mov    $0x64,%edx
c010ce3c:	ec                   	in     (%dx),%al
    
    // 等待PS/2控制器返回。通过轮询（polling）状态寄存器的 bit 0
    // 如置位，则表明返回代码此时就在 0x60 IO口上等待读取。
    while(!(io_inb(PS2_PORT_CTRL_STATUS) & PS2_STATUS_OFULL));
c010ce3d:	a8 01                	test   $0x1,%al
c010ce3f:	74 f6                	je     c010ce37 <ps2_issue_dev_cmd+0x16>
c010ce41:	ba 60 00 00 00       	mov    $0x60,%edx
c010ce46:	ec                   	in     (%dx),%al

    return io_inb(PS2_PORT_ENC_CMDREG);
}
c010ce47:	c9                   	leave  
c010ce48:	c3                   	ret    

c010ce49 <ps2_keybuffer_next_write>:

    mutex_unlock(&key_buf.mutex);
    return 1;
}

static struct kdb_keyinfo_pkt* ps2_keybuffer_next_write() {
c010ce49:	55                   	push   %ebp
c010ce4a:	89 e5                	mov    %esp,%ebp
c010ce4c:	53                   	push   %ebx
    int index = (key_buf.read_ptr + key_buf.buffered_len) % PS2_KBD_RECV_BUFFER_SIZE;
c010ce4d:	8b 1d 80 17 d1 c0    	mov    0xc0d11780,%ebx
c010ce53:	8b 0d 84 17 d1 c0    	mov    0xc0d11784,%ecx
c010ce59:	8d 04 0b             	lea    (%ebx,%ecx,1),%eax
c010ce5c:	99                   	cltd   
c010ce5d:	c1 ea 1d             	shr    $0x1d,%edx
c010ce60:	01 d0                	add    %edx,%eax
c010ce62:	83 e0 07             	and    $0x7,%eax
c010ce65:	29 d0                	sub    %edx,%eax
    if (index == key_buf.read_ptr && key_buf.buffered_len) {
c010ce67:	39 c3                	cmp    %eax,%ebx
c010ce69:	74 1d                	je     c010ce88 <ps2_keybuffer_next_write+0x3f>
        // It is suggested to read from beginning for nearly up-to-date readings.
        key_buf.read_ptr = 0;
        key_buf.buffered_len = index;
    }
    else {
        key_buf.buffered_len++;
c010ce6b:	83 c1 01             	add    $0x1,%ecx
c010ce6e:	89 0d 84 17 d1 c0    	mov    %ecx,0xc0d11784
    }
    return &key_buf.buffer[index];
c010ce74:	8d 14 40             	lea    (%eax,%eax,2),%edx
c010ce77:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
c010ce7e:	05 20 17 d1 c0       	add    $0xc0d11720,%eax
c010ce83:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c010ce86:	c9                   	leave  
c010ce87:	c3                   	ret    
    if (index == key_buf.read_ptr && key_buf.buffered_len) {
c010ce88:	85 c9                	test   %ecx,%ecx
c010ce8a:	74 df                	je     c010ce6b <ps2_keybuffer_next_write+0x22>
        key_buf.read_ptr = 0;
c010ce8c:	c7 05 80 17 d1 c0 00 	movl   $0x0,0xc0d11780
c010ce93:	00 00 00 
        key_buf.buffered_len = index;
c010ce96:	a3 84 17 d1 c0       	mov    %eax,0xc0d11784
c010ce9b:	eb d7                	jmp    c010ce74 <ps2_keybuffer_next_write+0x2b>

c010ce9d <kprintf>:
LOG_MODULE("PS2KBD");
c010ce9d:	55                   	push   %ebp
c010ce9e:	89 e5                	mov    %esp,%ebp
c010cea0:	83 ec 0c             	sub    $0xc,%esp
c010cea3:	8d 45 0c             	lea    0xc(%ebp),%eax
c010cea6:	50                   	push   %eax
c010cea7:	ff 75 08             	push   0x8(%ebp)
c010ceaa:	68 4b 34 d1 c0       	push   $0xc0d1344b
c010ceaf:	e8 c3 f0 ff ff       	call   c010bf77 <__kprintf>
c010ceb4:	83 c4 10             	add    $0x10,%esp
c010ceb7:	c9                   	leave  
c010ceb8:	c3                   	ret    

c010ceb9 <ps2_process_cmd>:
    return !atomic_load(&mutex->counter);
c010ceb9:	a1 a4 17 d1 c0       	mov    0xc0d117a4,%eax
    if (mutex_on_hold(&cmd_q.mutex) || !cmd_q.queue_len) {
c010cebe:	85 c0                	test   %eax,%eax
c010cec0:	74 09                	je     c010cecb <ps2_process_cmd+0x12>
c010cec2:	83 3d a0 17 d1 c0 00 	cmpl   $0x0,0xc0d117a0
c010cec9:	75 01                	jne    c010cecc <ps2_process_cmd+0x13>
c010cecb:	c3                   	ret    
void ps2_process_cmd(void* arg) {
c010cecc:	55                   	push   %ebp
c010cecd:	89 e5                	mov    %esp,%ebp
c010cecf:	83 ec 08             	sub    $0x8,%esp
    struct ps2_cmd *pending_cmd = &cmd_q.cmd_queue[cmd_q.queue_ptr];
c010ced2:	b8 8c 17 d1 c0       	mov    $0xc0d1178c,%eax
c010ced7:	8b 0d 9c 17 d1 c0    	mov    0xc0d1179c,%ecx
        result = ps2_issue_dev_cmd(pending_cmd->cmd, pending_cmd->arg);
c010cedd:	66 0f be 54 48 01    	movsbw 0x1(%eax,%ecx,2),%dx
c010cee3:	0f b7 d2             	movzwl %dx,%edx
c010cee6:	0f be 04 48          	movsbl (%eax,%ecx,2),%eax
c010ceea:	e8 32 ff ff ff       	call   c010ce21 <ps2_issue_dev_cmd>
        kbd_state.state += KBD_STATE_CMDPROCS;
c010ceef:	0f b6 05 00 17 d1 c0 	movzbl 0xc0d11700,%eax
c010cef6:	83 c0 40             	add    $0x40,%eax
c010cef9:	a2 00 17 d1 c0       	mov    %al,0xc0d11700
    cmd_q.queue_ptr = (cmd_q.queue_ptr + 1) % PS2_CMD_QUEUE_SIZE;
c010cefe:	a1 9c 17 d1 c0       	mov    0xc0d1179c,%eax
c010cf03:	83 c0 01             	add    $0x1,%eax
c010cf06:	99                   	cltd   
c010cf07:	c1 ea 1d             	shr    $0x1d,%edx
c010cf0a:	01 d0                	add    %edx,%eax
c010cf0c:	83 e0 07             	and    $0x7,%eax
c010cf0f:	29 d0                	sub    %edx,%eax
c010cf11:	a3 9c 17 d1 c0       	mov    %eax,0xc0d1179c
    cmd_q.queue_len--;
c010cf16:	a1 a0 17 d1 c0       	mov    0xc0d117a0,%eax
c010cf1b:	83 e8 01             	sub    $0x1,%eax
c010cf1e:	a3 a0 17 d1 c0       	mov    %eax,0xc0d117a0
}
c010cf23:	c9                   	leave  
c010cf24:	c3                   	ret    

c010cf25 <ps2_device_post_cmd>:
void ps2_device_post_cmd(char cmd, char arg) {
c010cf25:	55                   	push   %ebp
c010cf26:	89 e5                	mov    %esp,%ebp
c010cf28:	57                   	push   %edi
c010cf29:	56                   	push   %esi
c010cf2a:	53                   	push   %ebx
c010cf2b:	83 ec 28             	sub    $0x28,%esp
c010cf2e:	8b 75 08             	mov    0x8(%ebp),%esi
c010cf31:	8b 45 0c             	mov    0xc(%ebp),%eax
c010cf34:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    sem_wait(mutex);
c010cf37:	68 a4 17 d1 c0       	push   $0xc0d117a4
c010cf3c:	e8 4f e7 ff ff       	call   c010b690 <sem_wait>
    int index = (cmd_q.queue_ptr + cmd_q.queue_len) % PS2_CMD_QUEUE_SIZE;
c010cf41:	8b 3d 9c 17 d1 c0    	mov    0xc0d1179c,%edi
c010cf47:	8b 15 a0 17 d1 c0    	mov    0xc0d117a0,%edx
c010cf4d:	8d 04 17             	lea    (%edi,%edx,1),%eax
c010cf50:	89 c1                	mov    %eax,%ecx
c010cf52:	c1 f9 1f             	sar    $0x1f,%ecx
c010cf55:	c1 e9 1d             	shr    $0x1d,%ecx
c010cf58:	01 c8                	add    %ecx,%eax
c010cf5a:	83 e0 07             	and    $0x7,%eax
c010cf5d:	29 c8                	sub    %ecx,%eax
    if (index == cmd_q.queue_ptr && cmd_q.queue_len) {
c010cf5f:	83 c4 10             	add    $0x10,%esp
c010cf62:	39 c7                	cmp    %eax,%edi
c010cf64:	75 04                	jne    c010cf6a <ps2_device_post_cmd+0x45>
c010cf66:	85 d2                	test   %edx,%edx
c010cf68:	75 33                	jne    c010cf9d <ps2_device_post_cmd+0x78>
    container->cmd = cmd;
c010cf6a:	b9 8c 17 d1 c0       	mov    $0xc0d1178c,%ecx
c010cf6f:	89 f3                	mov    %esi,%ebx
c010cf71:	88 1c 41             	mov    %bl,(%ecx,%eax,2)
    container->arg = arg;
c010cf74:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
c010cf78:	88 5c 41 01          	mov    %bl,0x1(%ecx,%eax,2)
    cmd_q.queue_len++;
c010cf7c:	83 c2 01             	add    $0x1,%edx
c010cf7f:	89 15 a0 17 d1 c0    	mov    %edx,0xc0d117a0
    sem_post(mutex);
c010cf85:	83 ec 0c             	sub    $0xc,%esp
c010cf88:	68 a4 17 d1 c0       	push   $0xc0d117a4
c010cf8d:	e8 10 e7 ff ff       	call   c010b6a2 <sem_post>
}
c010cf92:	83 c4 10             	add    $0x10,%esp
}
c010cf95:	8d 65 f4             	lea    -0xc(%ebp),%esp
c010cf98:	5b                   	pop    %ebx
c010cf99:	5e                   	pop    %esi
c010cf9a:	5f                   	pop    %edi
c010cf9b:	5d                   	pop    %ebp
c010cf9c:	c3                   	ret    
    sem_post(mutex);
c010cf9d:	83 ec 0c             	sub    $0xc,%esp
c010cfa0:	68 a4 17 d1 c0       	push   $0xc0d117a4
c010cfa5:	e8 f8 e6 ff ff       	call   c010b6a2 <sem_post>
        return;
c010cfaa:	83 c4 10             	add    $0x10,%esp
c010cfad:	eb e6                	jmp    c010cf95 <ps2_device_post_cmd+0x70>

c010cfaf <ps2_kbd_init>:
void ps2_kbd_init() {
c010cfaf:	55                   	push   %ebp
c010cfb0:	89 e5                	mov    %esp,%ebp
c010cfb2:	53                   	push   %ebx
c010cfb3:	83 ec 08             	sub    $0x8,%esp
    memset(&cmd_q, 0, sizeof(cmd_q));
c010cfb6:	6a 1c                	push   $0x1c
c010cfb8:	6a 00                	push   $0x0
c010cfba:	68 8c 17 d1 c0       	push   $0xc0d1178c
c010cfbf:	e8 b7 1c 00 00       	call   c010ec7b <memset>
    memset(&key_buf, 0, sizeof(key_buf));
c010cfc4:	83 c4 0c             	add    $0xc,%esp
c010cfc7:	6a 6c                	push   $0x6c
c010cfc9:	6a 00                	push   $0x0
c010cfcb:	68 20 17 d1 c0       	push   $0xc0d11720
c010cfd0:	e8 a6 1c 00 00       	call   c010ec7b <memset>
    memset(&kbd_state, 0, sizeof(kbd_state));
c010cfd5:	83 c4 0c             	add    $0xc,%esp
c010cfd8:	6a 0c                	push   $0xc
c010cfda:	6a 00                	push   $0x0
c010cfdc:	68 00 17 d1 c0       	push   $0xc0d11700
c010cfe1:	e8 95 1c 00 00       	call   c010ec7b <memset>
    sem_init(mutex, 1);
c010cfe6:	83 c4 08             	add    $0x8,%esp
c010cfe9:	6a 01                	push   $0x1
c010cfeb:	68 a4 17 d1 c0       	push   $0xc0d117a4
c010cff0:	e8 8e e6 ff ff       	call   c010b683 <sem_init>
c010cff5:	83 c4 08             	add    $0x8,%esp
c010cff8:	6a 01                	push   $0x1
c010cffa:	68 88 17 d1 c0       	push   $0xc0d11788
c010cfff:	e8 7f e6 ff ff       	call   c010b683 <sem_init>
    kbd_state.translation_table = scancode_set2;
c010d004:	c7 05 04 17 d1 c0 20 	movl   $0xc0d12520,0xc0d11704
c010d00b:	25 d1 c0 
    kbd_state.state = KBD_STATE_KWAIT;
c010d00e:	c6 05 00 17 d1 c0 00 	movb   $0x0,0xc0d11700
    acpi_context* acpi_ctx = acpi_get_context();
c010d015:	e8 73 0f 00 00       	call   c010df8d <acpi_get_context>
c010d01a:	89 c3                	mov    %eax,%ebx
    if (acpi_ctx->fadt.header.rev > 1) {
c010d01c:	83 c4 10             	add    $0x10,%esp
c010d01f:	80 78 1f 01          	cmpb   $0x1,0x1f(%eax)
c010d023:	0f 86 9f 00 00 00    	jbe    c010d0c8 <ps2_kbd_init+0x119>
        if (!(acpi_ctx->fadt.boot_arch & IAPC_ARCH_8042)) {
c010d029:	f6 80 84 00 00 00 02 	testb  $0x2,0x84(%eax)
c010d030:	0f 84 80 00 00 00    	je     c010d0b6 <ps2_kbd_init+0x107>
    asm volatile("cli");
c010d036:	fa                   	cli    
    ps2_post_cmd(PS2_PORT_CTRL_CMDREG, PS2_CMD_PORT1_DISABLE, PS2_NO_ARG);
c010d037:	b9 00 ff 00 00       	mov    $0xff00,%ecx
c010d03c:	ba ad ff ff ff       	mov    $0xffffffad,%edx
c010d041:	b8 64 00 00 00       	mov    $0x64,%eax
c010d046:	e8 68 fd ff ff       	call   c010cdb3 <ps2_post_cmd>
    ps2_post_cmd(PS2_PORT_CTRL_CMDREG, PS2_CMD_PORT2_DISABLE, PS2_NO_ARG);
c010d04b:	b9 00 ff 00 00       	mov    $0xff00,%ecx
c010d050:	ba a7 ff ff ff       	mov    $0xffffffa7,%edx
c010d055:	b8 64 00 00 00       	mov    $0x64,%eax
c010d05a:	e8 54 fd ff ff       	call   c010cdb3 <ps2_post_cmd>
c010d05f:	ba 60 00 00 00       	mov    $0x60,%edx
c010d064:	ec                   	in     (%dx),%al
    result = ps2_issue_cmd(PS2_CMD_READ_CFG, PS2_NO_ARG);
c010d065:	ba 00 ff 00 00       	mov    $0xff00,%edx
c010d06a:	b8 20 00 00 00       	mov    $0x20,%eax
c010d06f:	e8 85 fd ff ff       	call   c010cdf9 <ps2_issue_cmd>
    result = result & ~(PS2_CFG_P1INT | PS2_CFG_P2INT | PS2_CFG_TRANSLATION);
c010d074:	83 e0 bc             	and    $0xffffffbc,%eax
    ps2_post_cmd(PS2_PORT_CTRL_CMDREG, PS2_CMD_WRITE_CFG, result);
c010d077:	66 0f be c8          	movsbw %al,%cx
c010d07b:	0f b7 c9             	movzwl %cx,%ecx
c010d07e:	ba 60 00 00 00       	mov    $0x60,%edx
c010d083:	b8 64 00 00 00       	mov    $0x64,%eax
c010d088:	e8 26 fd ff ff       	call   c010cdb3 <ps2_post_cmd>
    result = ps2_issue_cmd(PS2_CMD_SELFTEST, PS2_NO_ARG);
c010d08d:	ba 00 ff 00 00       	mov    $0xff00,%edx
c010d092:	b8 aa ff ff ff       	mov    $0xffffffaa,%eax
c010d097:	e8 5d fd ff ff       	call   c010cdf9 <ps2_issue_cmd>
    if (result != PS2_RESULT_TEST_OK) {
c010d09c:	3c 55                	cmp    $0x55,%al
c010d09e:	74 3d                	je     c010d0dd <ps2_kbd_init+0x12e>
        kprintf(KERROR "Controller self-test failed.");
c010d0a0:	83 ec 0c             	sub    $0xc,%esp
c010d0a3:	68 08 38 d1 c0       	push   $0xc0d13808
c010d0a8:	e8 f0 fd ff ff       	call   c010ce9d <kprintf>
        goto done;
c010d0ad:	83 c4 10             	add    $0x10,%esp
    asm volatile("sti");
c010d0b0:	fb                   	sti    
}
c010d0b1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c010d0b4:	c9                   	leave  
c010d0b5:	c3                   	ret    
            kprintf(KERROR "No PS/2 controller detected.\n");
c010d0b6:	83 ec 0c             	sub    $0xc,%esp
c010d0b9:	68 b4 37 d1 c0       	push   $0xc0d137b4
c010d0be:	e8 da fd ff ff       	call   c010ce9d <kprintf>
            return;
c010d0c3:	83 c4 10             	add    $0x10,%esp
c010d0c6:	eb e9                	jmp    c010d0b1 <ps2_kbd_init+0x102>
        kprintf(KWARN "Outdated FADT used, assuming 8042 always exist.\n");
c010d0c8:	83 ec 0c             	sub    $0xc,%esp
c010d0cb:	68 d4 37 d1 c0       	push   $0xc0d137d4
c010d0d0:	e8 c8 fd ff ff       	call   c010ce9d <kprintf>
c010d0d5:	83 c4 10             	add    $0x10,%esp
c010d0d8:	e9 59 ff ff ff       	jmp    c010d036 <ps2_kbd_init+0x87>
    result = ps2_issue_cmd(PS2_CMD_SELFTEST_PORT1, PS2_NO_ARG);
c010d0dd:	ba 00 ff 00 00       	mov    $0xff00,%edx
c010d0e2:	b8 ab ff ff ff       	mov    $0xffffffab,%eax
c010d0e7:	e8 0d fd ff ff       	call   c010cdf9 <ps2_issue_cmd>
    if (result != 0) {
c010d0ec:	84 c0                	test   %al,%al
c010d0ee:	0f 85 83 00 00 00    	jne    c010d177 <ps2_kbd_init+0x1c8>
    ps2_post_cmd(PS2_PORT_CTRL_CMDREG, PS2_CMD_PORT1_ENABLE, PS2_NO_ARG);
c010d0f4:	b9 00 ff 00 00       	mov    $0xff00,%ecx
c010d0f9:	ba ae ff ff ff       	mov    $0xffffffae,%edx
c010d0fe:	b8 64 00 00 00       	mov    $0x64,%eax
c010d103:	e8 ab fc ff ff       	call   c010cdb3 <ps2_post_cmd>
    result = ps2_issue_cmd(PS2_CMD_READ_CFG, PS2_NO_ARG);
c010d108:	ba 00 ff 00 00       	mov    $0xff00,%edx
c010d10d:	b8 20 00 00 00       	mov    $0x20,%eax
c010d112:	e8 e2 fc ff ff       	call   c010cdf9 <ps2_issue_cmd>
    result = result | PS2_CFG_P1INT;
c010d117:	83 c8 01             	or     $0x1,%eax
    ps2_post_cmd(PS2_PORT_CTRL_CMDREG, PS2_CMD_WRITE_CFG, result);
c010d11a:	66 0f be c8          	movsbw %al,%cx
c010d11e:	0f b7 c9             	movzwl %cx,%ecx
c010d121:	ba 60 00 00 00       	mov    $0x60,%edx
c010d126:	b8 64 00 00 00       	mov    $0x64,%eax
c010d12b:	e8 83 fc ff ff       	call   c010cdb3 <ps2_post_cmd>
    intr_subscribe(PC_KBD_IV, intr_ps2_kbd_handler);
c010d130:	83 ec 08             	sub    $0x8,%esp
c010d133:	68 bd d2 10 c0       	push   $0xc010d2bd
c010d138:	68 c9 00 00 00       	push   $0xc9
c010d13d:	e8 34 f0 ff ff       	call   c010c176 <intr_subscribe>
    timer_run_ms(5, ps2_process_cmd, NULL, TIMER_MODE_PERIODIC);
c010d142:	6a 01                	push   $0x1
c010d144:	6a 00                	push   $0x0
c010d146:	68 b9 ce 10 c0       	push   $0xc010ceb9
c010d14b:	6a 05                	push   $0x5
c010d14d:	e8 e3 ed ff ff       	call   c010bf35 <timer_run_ms>
    uint8_t irq_kbd = ioapic_get_irq(acpi_ctx, PC_AT_IRQ_KBD);
c010d152:	83 c4 18             	add    $0x18,%esp
c010d155:	6a 01                	push   $0x1
c010d157:	53                   	push   %ebx
c010d158:	e8 af 10 00 00       	call   c010e20c <ioapic_get_irq>
    ioapic_redirect(irq_kbd, PC_KBD_IV, 0, IOAPIC_DELMOD_FIXED);
c010d15d:	6a 00                	push   $0x0
c010d15f:	6a 00                	push   $0x0
c010d161:	68 c9 00 00 00       	push   $0xc9
c010d166:	0f b6 c0             	movzbl %al,%eax
c010d169:	50                   	push   %eax
c010d16a:	e8 ec 10 00 00       	call   c010e25b <ioapic_redirect>
c010d16f:	83 c4 20             	add    $0x20,%esp
c010d172:	e9 39 ff ff ff       	jmp    c010d0b0 <ps2_kbd_init+0x101>
        kprintf(KERROR "Interface test on port 1 failed.");
c010d177:	83 ec 0c             	sub    $0xc,%esp
c010d17a:	68 28 38 d1 c0       	push   $0xc0d13828
c010d17f:	e8 19 fd ff ff       	call   c010ce9d <kprintf>
        goto done;
c010d184:	83 c4 10             	add    $0x10,%esp
c010d187:	e9 24 ff ff ff       	jmp    c010d0b0 <ps2_kbd_init+0x101>

c010d18c <kbd_buffer_key_event>:
void kbd_buffer_key_event(kbd_keycode_t key, uint8_t scancode, kbd_kstate_t state) {
c010d18c:	55                   	push   %ebp
c010d18d:	89 e5                	mov    %esp,%ebp
c010d18f:	57                   	push   %edi
c010d190:	56                   	push   %esi
c010d191:	53                   	push   %ebx
c010d192:	83 ec 1c             	sub    $0x1c,%esp
c010d195:	8b 4d 08             	mov    0x8(%ebp),%ecx
c010d198:	8b 75 0c             	mov    0xc(%ebp),%esi
c010d19b:	8b 5d 10             	mov    0x10(%ebp),%ebx
    if (key == KEY_CAPSLK) {
c010d19e:	66 81 f9 0c 02       	cmp    $0x20c,%cx
c010d1a3:	74 20                	je     c010d1c5 <kbd_buffer_key_event+0x39>
c010d1a5:	89 c8                	mov    %ecx,%eax
    } else if (key == KEY_NUMSLK) {
c010d1a7:	66 81 f9 0d 02       	cmp    $0x20d,%cx
c010d1ac:	74 36                	je     c010d1e4 <kbd_buffer_key_event+0x58>
    } else if (key == KEY_SCRLLK) {
c010d1ae:	66 81 f9 0e 02       	cmp    $0x20e,%cx
c010d1b3:	75 3f                	jne    c010d1f4 <kbd_buffer_key_event+0x68>
        kbd_state.key_state ^= KBD_KEY_FSCRLLKED & -state;
c010d1b5:	89 d8                	mov    %ebx,%eax
c010d1b7:	f7 d8                	neg    %eax
c010d1b9:	83 e0 02             	and    $0x2,%eax
c010d1bc:	66 31 05 08 17 d1 c0 	xor    %ax,0xc0d11708
c010d1c3:	eb 0e                	jmp    c010d1d3 <kbd_buffer_key_event+0x47>
        kbd_state.key_state ^= KBD_KEY_FCAPSLKED & -state;
c010d1c5:	89 d8                	mov    %ebx,%eax
c010d1c7:	f7 d8                	neg    %eax
c010d1c9:	83 e0 08             	and    $0x8,%eax
c010d1cc:	66 31 05 08 17 d1 c0 	xor    %ax,0xc0d11708
    if (state & KBD_KEY_FPRESSED) {
c010d1d3:	f6 c3 01             	test   $0x1,%bl
c010d1d6:	0f 85 c1 00 00 00    	jne    c010d29d <kbd_buffer_key_event+0x111>
}
c010d1dc:	8d 65 f4             	lea    -0xc(%ebp),%esp
c010d1df:	5b                   	pop    %ebx
c010d1e0:	5e                   	pop    %esi
c010d1e1:	5f                   	pop    %edi
c010d1e2:	5d                   	pop    %ebp
c010d1e3:	c3                   	ret    
        kbd_state.key_state ^= KBD_KEY_FNUMBLKED & -state;
c010d1e4:	89 d8                	mov    %ebx,%eax
c010d1e6:	f7 d8                	neg    %eax
c010d1e8:	83 e0 04             	and    $0x4,%eax
c010d1eb:	66 31 05 08 17 d1 c0 	xor    %ax,0xc0d11708
c010d1f2:	eb df                	jmp    c010d1d3 <kbd_buffer_key_event+0x47>
        if ((key & MODIFR)) {
c010d1f4:	f6 c5 04             	test   $0x4,%ch
c010d1f7:	74 3d                	je     c010d236 <kbd_buffer_key_event+0xaa>
            kbd_kstate_t tmp = (KBD_KEY_FLSHIFT_HELD << (key & 0x00ff));
c010d1f9:	ba 10 00 00 00       	mov    $0x10,%edx
c010d1fe:	d3 e2                	shl    %cl,%edx
            kbd_state.key_state = (kbd_state.key_state & ~tmp) | (tmp & -state);
c010d200:	89 d1                	mov    %edx,%ecx
c010d202:	f7 d1                	not    %ecx
c010d204:	66 23 0d 08 17 d1 c0 	and    0xc0d11708,%cx
c010d20b:	89 df                	mov    %ebx,%edi
c010d20d:	f7 df                	neg    %edi
c010d20f:	21 fa                	and    %edi,%edx
c010d211:	09 ca                	or     %ecx,%edx
c010d213:	66 89 15 08 17 d1 c0 	mov    %dx,0xc0d11708
        state = state | kbd_state.key_state;
c010d21a:	66 0b 1d 08 17 d1 c0 	or     0xc0d11708,%bx
        key = key & (0xffdf | -('a' > key || key > 'z' || !(state & KBD_KEY_FCAPSLKED)));
c010d221:	8d 50 9f             	lea    -0x61(%eax),%edx
c010d224:	66 83 fa 19          	cmp    $0x19,%dx
c010d228:	77 2b                	ja     c010d255 <kbd_buffer_key_event+0xc9>
c010d22a:	f6 c3 08             	test   $0x8,%bl
c010d22d:	75 67                	jne    c010d296 <kbd_buffer_key_event+0x10a>
c010d22f:	ba 01 00 00 00       	mov    $0x1,%edx
c010d234:	eb 24                	jmp    c010d25a <kbd_buffer_key_event+0xce>
        else if (!(key & 0xff00) && (kbd_state.key_state & (KBD_KEY_FLSHIFT_HELD | KBD_KEY_FRSHIFT_HELD))) {
c010d236:	66 f7 c1 00 ff       	test   $0xff00,%cx
c010d23b:	75 dd                	jne    c010d21a <kbd_buffer_key_event+0x8e>
c010d23d:	f6 05 08 17 d1 c0 30 	testb  $0x30,0xc0d11708
c010d244:	74 d4                	je     c010d21a <kbd_buffer_key_event+0x8e>
            key = scancode_set2_shift[scancode];
c010d246:	89 f0                	mov    %esi,%eax
c010d248:	0f b6 c0             	movzbl %al,%eax
c010d24b:	0f b7 84 00 00 30 d1 	movzwl -0x3f2ed000(%eax,%eax,1),%eax
c010d252:	c0 
c010d253:	eb c5                	jmp    c010d21a <kbd_buffer_key_event+0x8e>
        key = key & (0xffdf | -('a' > key || key > 'z' || !(state & KBD_KEY_FCAPSLKED)));
c010d255:	ba 01 00 00 00       	mov    $0x1,%edx
c010d25a:	f7 da                	neg    %edx
c010d25c:	83 ca df             	or     $0xffffffdf,%edx
c010d25f:	21 c2                	and    %eax,%edx
c010d261:	66 89 55 e6          	mov    %dx,-0x1a(%ebp)
    return !atomic_load(&mutex->counter);
c010d265:	a1 88 17 d1 c0       	mov    0xc0d11788,%eax
        if (!mutex_on_hold(&key_buf.mutex)) {
c010d26a:	85 c0                	test   %eax,%eax
c010d26c:	0f 84 6a ff ff ff    	je     c010d1dc <kbd_buffer_key_event+0x50>
            struct kdb_keyinfo_pkt* keyevent_pkt = ps2_keybuffer_next_write();
c010d272:	e8 d2 fb ff ff       	call   c010ce49 <ps2_keybuffer_next_write>
c010d277:	89 c7                	mov    %eax,%edi
                .timestamp = clock_systime()
c010d279:	e8 74 e9 ff ff       	call   c010bbf2 <clock_systime>
            *keyevent_pkt = (struct kdb_keyinfo_pkt) {
c010d27e:	89 f2                	mov    %esi,%edx
c010d280:	88 17                	mov    %dl,(%edi)
c010d282:	0f b7 75 e6          	movzwl -0x1a(%ebp),%esi
c010d286:	66 89 77 02          	mov    %si,0x2(%edi)
c010d28a:	66 89 5f 04          	mov    %bx,0x4(%edi)
c010d28e:	89 47 08             	mov    %eax,0x8(%edi)
        return;
c010d291:	e9 46 ff ff ff       	jmp    c010d1dc <kbd_buffer_key_event+0x50>
        key = key & (0xffdf | -('a' > key || key > 'z' || !(state & KBD_KEY_FCAPSLKED)));
c010d296:	ba 00 00 00 00       	mov    $0x0,%edx
c010d29b:	eb bd                	jmp    c010d25a <kbd_buffer_key_event+0xce>
        ps2_device_post_cmd(PS2_KBD_CMD_SETLED, (kbd_state.key_state >> 1) & 0x00ff);
c010d29d:	83 ec 08             	sub    $0x8,%esp
c010d2a0:	0f b7 05 08 17 d1 c0 	movzwl 0xc0d11708,%eax
c010d2a7:	66 d1 e8             	shr    %ax
c010d2aa:	0f be c0             	movsbl %al,%eax
c010d2ad:	50                   	push   %eax
c010d2ae:	6a ed                	push   $0xffffffed
c010d2b0:	e8 70 fc ff ff       	call   c010cf25 <ps2_device_post_cmd>
c010d2b5:	83 c4 10             	add    $0x10,%esp
c010d2b8:	e9 1f ff ff ff       	jmp    c010d1dc <kbd_buffer_key_event+0x50>

c010d2bd <intr_ps2_kbd_handler>:
c010d2bd:	ba 64 00 00 00       	mov    $0x64,%edx
c010d2c2:	ec                   	in     (%dx),%al
    while (!(io_inb(PS2_PORT_CTRL_STATUS) & PS2_STATUS_OFULL));
c010d2c3:	a8 01                	test   $0x1,%al
c010d2c5:	74 f6                	je     c010d2bd <intr_ps2_kbd_handler>
c010d2c7:	ba 60 00 00 00       	mov    $0x60,%edx
c010d2cc:	ec                   	in     (%dx),%al
    if ((kbd_state.state & 0xc0)) {
c010d2cd:	0f b6 15 00 17 d1 c0 	movzbl 0xc0d11700,%edx
c010d2d4:	f6 c2 c0             	test   $0xc0,%dl
c010d2d7:	75 21                	jne    c010d2fa <intr_ps2_kbd_handler+0x3d>
void intr_ps2_kbd_handler(const isr_param* param) {
c010d2d9:	55                   	push   %ebp
c010d2da:	89 e5                	mov    %esp,%ebp
c010d2dc:	83 ec 08             	sub    $0x8,%esp
    switch (kbd_state.state)
c010d2df:	0f b6 15 00 17 d1 c0 	movzbl 0xc0d11700,%edx
c010d2e6:	80 fa 01             	cmp    $0x1,%dl
c010d2e9:	74 66                	je     c010d351 <intr_ps2_kbd_handler+0x94>
c010d2eb:	80 fa 02             	cmp    $0x2,%dl
c010d2ee:	0f 84 a1 00 00 00    	je     c010d395 <intr_ps2_kbd_handler+0xd8>
c010d2f4:	84 d2                	test   %dl,%dl
c010d2f6:	74 12                	je     c010d30a <intr_ps2_kbd_handler+0x4d>
}
c010d2f8:	c9                   	leave  
c010d2f9:	c3                   	ret    
        kbd_state.state -= KBD_STATE_CMDPROCS;
c010d2fa:	0f b6 05 00 17 d1 c0 	movzbl 0xc0d11700,%eax
c010d301:	83 e8 40             	sub    $0x40,%eax
c010d304:	a2 00 17 d1 c0       	mov    %al,0xc0d11700
        return;
c010d309:	c3                   	ret    
        if (scancode == 0xf0) { // release code
c010d30a:	3c f0                	cmp    $0xf0,%al
c010d30c:	74 17                	je     c010d325 <intr_ps2_kbd_handler+0x68>
        } else if (scancode == 0xe0) {
c010d30e:	3c e0                	cmp    $0xe0,%al
c010d310:	75 1c                	jne    c010d32e <intr_ps2_kbd_handler+0x71>
            kbd_state.state = KBD_STATE_KSPECIAL;
c010d312:	c6 05 00 17 d1 c0 01 	movb   $0x1,0xc0d11700
            kbd_state.translation_table = scancode_set2_ex;
c010d319:	c7 05 04 17 d1 c0 20 	movl   $0xc0d12420,0xc0d11704
c010d320:	24 d1 c0 
c010d323:	eb d3                	jmp    c010d2f8 <intr_ps2_kbd_handler+0x3b>
            kbd_state.state = KBD_STATE_KRELEASED;       
c010d325:	c6 05 00 17 d1 c0 02 	movb   $0x2,0xc0d11700
c010d32c:	eb ca                	jmp    c010d2f8 <intr_ps2_kbd_handler+0x3b>
            key = kbd_state.translation_table[scancode];
c010d32e:	0f b6 c0             	movzbl %al,%eax
c010d331:	8d 14 00             	lea    (%eax,%eax,1),%edx
c010d334:	03 15 04 17 d1 c0    	add    0xc0d11704,%edx
c010d33a:	0f b7 12             	movzwl (%edx),%edx
            kbd_buffer_key_event(key, scancode, KBD_KEY_FPRESSED);
c010d33d:	83 ec 04             	sub    $0x4,%esp
c010d340:	6a 01                	push   $0x1
c010d342:	50                   	push   %eax
c010d343:	0f b7 c2             	movzwl %dx,%eax
c010d346:	50                   	push   %eax
c010d347:	e8 40 fe ff ff       	call   c010d18c <kbd_buffer_key_event>
c010d34c:	83 c4 10             	add    $0x10,%esp
c010d34f:	eb a7                	jmp    c010d2f8 <intr_ps2_kbd_handler+0x3b>
        if (scancode == 0xf0) { //release code
c010d351:	3c f0                	cmp    $0xf0,%al
c010d353:	75 09                	jne    c010d35e <intr_ps2_kbd_handler+0xa1>
            kbd_state.state = KBD_STATE_KRELEASED;       
c010d355:	c6 05 00 17 d1 c0 02 	movb   $0x2,0xc0d11700
c010d35c:	eb 9a                	jmp    c010d2f8 <intr_ps2_kbd_handler+0x3b>
            key = kbd_state.translation_table[scancode];
c010d35e:	0f b6 c0             	movzbl %al,%eax
c010d361:	8d 14 00             	lea    (%eax,%eax,1),%edx
c010d364:	03 15 04 17 d1 c0    	add    0xc0d11704,%edx
c010d36a:	0f b7 12             	movzwl (%edx),%edx
            kbd_buffer_key_event(key, scancode, KBD_KEY_FPRESSED);
c010d36d:	83 ec 04             	sub    $0x4,%esp
c010d370:	6a 01                	push   $0x1
c010d372:	50                   	push   %eax
c010d373:	0f b7 c2             	movzwl %dx,%eax
c010d376:	50                   	push   %eax
c010d377:	e8 10 fe ff ff       	call   c010d18c <kbd_buffer_key_event>
            kbd_state.state = KBD_STATE_KWAIT;
c010d37c:	c6 05 00 17 d1 c0 00 	movb   $0x0,0xc0d11700
            kbd_state.translation_table = scancode_set2;
c010d383:	c7 05 04 17 d1 c0 20 	movl   $0xc0d12520,0xc0d11704
c010d38a:	25 d1 c0 
c010d38d:	83 c4 10             	add    $0x10,%esp
c010d390:	e9 63 ff ff ff       	jmp    c010d2f8 <intr_ps2_kbd_handler+0x3b>
        key = kbd_state.translation_table[scancode];
c010d395:	0f b6 c0             	movzbl %al,%eax
c010d398:	8d 14 00             	lea    (%eax,%eax,1),%edx
c010d39b:	03 15 04 17 d1 c0    	add    0xc0d11704,%edx
c010d3a1:	0f b7 12             	movzwl (%edx),%edx
        kbd_buffer_key_event(key, scancode, KBD_KEY_FRELEASED);
c010d3a4:	83 ec 04             	sub    $0x4,%esp
c010d3a7:	6a 00                	push   $0x0
c010d3a9:	50                   	push   %eax
c010d3aa:	0f b7 c2             	movzwl %dx,%eax
c010d3ad:	50                   	push   %eax
c010d3ae:	e8 d9 fd ff ff       	call   c010d18c <kbd_buffer_key_event>
        kbd_state.state = KBD_STATE_KWAIT;   
c010d3b3:	c6 05 00 17 d1 c0 00 	movb   $0x0,0xc0d11700
        kbd_state.translation_table = scancode_set2;
c010d3ba:	c7 05 04 17 d1 c0 20 	movl   $0xc0d12520,0xc0d11704
c010d3c1:	25 d1 c0 
        break;
c010d3c4:	83 c4 10             	add    $0x10,%esp
c010d3c7:	e9 2c ff ff ff       	jmp    c010d2f8 <intr_ps2_kbd_handler+0x3b>

c010d3cc <kbd_recv_key>:
int kbd_recv_key(struct kdb_keyinfo_pkt* key_event) {
c010d3cc:	55                   	push   %ebp
c010d3cd:	89 e5                	mov    %esp,%ebp
c010d3cf:	53                   	push   %ebx
c010d3d0:	83 ec 04             	sub    $0x4,%esp
c010d3d3:	8b 5d 08             	mov    0x8(%ebp),%ebx
    if (!key_buf.buffered_len) {
c010d3d6:	a1 84 17 d1 c0       	mov    0xc0d11784,%eax
c010d3db:	85 c0                	test   %eax,%eax
c010d3dd:	75 05                	jne    c010d3e4 <kbd_recv_key+0x18>
}
c010d3df:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c010d3e2:	c9                   	leave  
c010d3e3:	c3                   	ret    
    sem_wait(mutex);
c010d3e4:	83 ec 0c             	sub    $0xc,%esp
c010d3e7:	68 88 17 d1 c0       	push   $0xc0d11788
c010d3ec:	e8 9f e2 ff ff       	call   c010b690 <sem_wait>
    struct kdb_keyinfo_pkt* pkt_current = &key_buf.buffer[key_buf.read_ptr];
c010d3f1:	a1 80 17 d1 c0       	mov    0xc0d11780,%eax
    *key_event = *pkt_current;
c010d3f6:	8d 14 40             	lea    (%eax,%eax,2),%edx
c010d3f9:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
c010d400:	8d 90 20 17 d1 c0    	lea    -0x3f2ee8e0(%eax),%edx
c010d406:	8b 80 20 17 d1 c0    	mov    -0x3f2ee8e0(%eax),%eax
c010d40c:	89 03                	mov    %eax,(%ebx)
c010d40e:	8b 42 04             	mov    0x4(%edx),%eax
c010d411:	89 43 04             	mov    %eax,0x4(%ebx)
c010d414:	8b 42 08             	mov    0x8(%edx),%eax
c010d417:	89 43 08             	mov    %eax,0x8(%ebx)
    key_buf.buffered_len--;
c010d41a:	a1 84 17 d1 c0       	mov    0xc0d11784,%eax
c010d41f:	83 e8 01             	sub    $0x1,%eax
c010d422:	a3 84 17 d1 c0       	mov    %eax,0xc0d11784
    key_buf.read_ptr = (key_buf.read_ptr + 1) % PS2_KBD_RECV_BUFFER_SIZE;
c010d427:	a1 80 17 d1 c0       	mov    0xc0d11780,%eax
c010d42c:	83 c0 01             	add    $0x1,%eax
c010d42f:	99                   	cltd   
c010d430:	c1 ea 1d             	shr    $0x1d,%edx
c010d433:	01 d0                	add    %edx,%eax
c010d435:	83 e0 07             	and    $0x7,%eax
c010d438:	29 d0                	sub    %edx,%eax
c010d43a:	a3 80 17 d1 c0       	mov    %eax,0xc0d11780
    sem_post(mutex);
c010d43f:	c7 04 24 88 17 d1 c0 	movl   $0xc0d11788,(%esp)
c010d446:	e8 57 e2 ff ff       	call   c010b6a2 <sem_post>
    return 1;
c010d44b:	83 c4 10             	add    $0x10,%esp
c010d44e:	b8 01 00 00 00       	mov    $0x1,%eax
c010d453:	eb 8a                	jmp    c010d3df <kbd_recv_key+0x13>

c010d455 <fork>:
__LXSYSCALL(pid_t, fork)
c010d455:	b8 01 00 00 00       	mov    $0x1,%eax
c010d45a:	cd 21                	int    $0x21
c010d45c:	c3                   	ret    

c010d45d <_exit>:
__LXSYSCALL1(void, _exit, int, status)
c010d45d:	55                   	push   %ebp
c010d45e:	89 e5                	mov    %esp,%ebp
c010d460:	53                   	push   %ebx
c010d461:	89 c3                	mov    %eax,%ebx
c010d463:	b8 08 00 00 00       	mov    $0x8,%eax
c010d468:	cd 21                	int    $0x21
c010d46a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c010d46d:	c9                   	leave  
c010d46e:	c3                   	ret    

c010d46f <sleep>:
__LXSYSCALL1(unsigned int, sleep, unsigned int, seconds)
c010d46f:	55                   	push   %ebp
c010d470:	89 e5                	mov    %esp,%ebp
c010d472:	53                   	push   %ebx
c010d473:	89 c3                	mov    %eax,%ebx
c010d475:	b8 07 00 00 00       	mov    $0x7,%eax
c010d47a:	cd 21                	int    $0x21
c010d47c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c010d47f:	c9                   	leave  
c010d480:	c3                   	ret    

c010d481 <yield>:
__LXSYSCALL(void, yield);
c010d481:	b8 02 00 00 00       	mov    $0x2,%eax
c010d486:	cd 21                	int    $0x21
c010d488:	c3                   	ret    

c010d489 <wait>:
__LXSYSCALL1(pid_t, wait, int*, status);
c010d489:	55                   	push   %ebp
c010d48a:	89 e5                	mov    %esp,%ebp
c010d48c:	53                   	push   %ebx
c010d48d:	89 c3                	mov    %eax,%ebx
c010d48f:	b8 09 00 00 00       	mov    $0x9,%eax
c010d494:	cd 21                	int    $0x21
c010d496:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c010d499:	c9                   	leave  
c010d49a:	c3                   	ret    

c010d49b <waitpid>:

__LXSYSCALL3(pid_t, waitpid, pid_t, pid, int*, status, int, options);
c010d49b:	55                   	push   %ebp
c010d49c:	89 e5                	mov    %esp,%ebp
c010d49e:	56                   	push   %esi
c010d49f:	53                   	push   %ebx
c010d4a0:	89 d6                	mov    %edx,%esi
c010d4a2:	89 ca                	mov    %ecx,%edx
c010d4a4:	89 c3                	mov    %eax,%ebx
c010d4a6:	89 f1                	mov    %esi,%ecx
c010d4a8:	b8 0a 00 00 00       	mov    $0xa,%eax
c010d4ad:	cd 21                	int    $0x21
c010d4af:	5b                   	pop    %ebx
c010d4b0:	5e                   	pop    %esi
c010d4b1:	5d                   	pop    %ebp
c010d4b2:	c3                   	ret    

c010d4b3 <kprintf>:
#include <lunaix/syslog.h>
#include <lunaix/timer.h>

extern uint8_t __kernel_start;

LOG_MODULE("INIT")
c010d4b3:	55                   	push   %ebp
c010d4b4:	89 e5                	mov    %esp,%ebp
c010d4b6:	83 ec 0c             	sub    $0xc,%esp
c010d4b9:	8d 45 0c             	lea    0xc(%ebp),%eax
c010d4bc:	50                   	push   %eax
c010d4bd:	ff 75 08             	push   0x8(%ebp)
c010d4c0:	68 52 34 d1 c0       	push   $0xc0d13452
c010d4c5:	e8 ad ea ff ff       	call   c010bf77 <__kprintf>
c010d4ca:	83 c4 10             	add    $0x10,%esp
c010d4cd:	c9                   	leave  
c010d4ce:	c3                   	ret    

c010d4cf <__dup_pagetable>:

LOG_MODULE("PROC")

void*
__dup_pagetable(pid_t pid, uintptr_t mount_point)
{
c010d4cf:	55                   	push   %ebp
c010d4d0:	89 e5                	mov    %esp,%ebp
c010d4d2:	57                   	push   %edi
c010d4d3:	56                   	push   %esi
c010d4d4:	53                   	push   %ebx
c010d4d5:	83 ec 34             	sub    $0x34,%esp
    void* ptd_pp = pmm_alloc_page(pid, PP_FGPERSIST);
c010d4d8:	6a 01                	push   $0x1
c010d4da:	ff 75 08             	push   0x8(%ebp)
c010d4dd:	e8 e5 d5 ff ff       	call   c010aac7 <pmm_alloc_page>
c010d4e2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    vmm_set_mapping(PD_REFERENCED, PG_MOUNT_1, ptd_pp, PG_PREM_RW, VMAP_NULL);
c010d4e5:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c010d4ec:	6a 03                	push   $0x3
c010d4ee:	50                   	push   %eax
c010d4ef:	68 00 00 40 d1       	push   $0xd1400000
c010d4f4:	68 00 00 c0 ff       	push   $0xffc00000
c010d4f9:	e8 42 cf ff ff       	call   c010a440 <vmm_set_mapping>

    x86_page_table* ptd = PG_MOUNT_1;
    x86_page_table* pptd = (x86_page_table*)(mount_point | (0x3FF << 12));
c010d4fe:	8b 45 0c             	mov    0xc(%ebp),%eax
c010d501:	0d 00 f0 3f 00       	or     $0x3ff000,%eax
c010d506:	89 45 dc             	mov    %eax,-0x24(%ebp)

    size_t kspace_l1inx = L1_INDEX(KERNEL_MM_BASE);

    for (size_t i = 0; i < PG_MAX_ENTRIES - 1; i++) {
c010d509:	83 c4 20             	add    $0x20,%esp
c010d50c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
c010d513:	eb 11                	jmp    c010d526 <__dup_pagetable+0x57>

        x86_pte_t ptde = pptd->entry[i];
        // 空或者是未在内存中的L1页表项直接照搬过去。
        // 内核地址空间直接共享过去。
        if (!ptde || i >= kspace_l1inx || !(ptde & PG_PRESENT)) {
            ptd->entry[i] = ptde;
c010d515:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010d518:	8b 55 e0             	mov    -0x20(%ebp),%edx
c010d51b:	89 14 85 00 00 40 d1 	mov    %edx,-0x2ec00000(,%eax,4)
    for (size_t i = 0; i < PG_MAX_ENTRIES - 1; i++) {
c010d522:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
c010d526:	81 7d e4 fe 03 00 00 	cmpl   $0x3fe,-0x1c(%ebp)
c010d52d:	0f 87 a4 00 00 00    	ja     c010d5d7 <__dup_pagetable+0x108>
        x86_pte_t ptde = pptd->entry[i];
c010d533:	8b 45 dc             	mov    -0x24(%ebp),%eax
c010d536:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c010d539:	8b 0c 90             	mov    (%eax,%edx,4),%ecx
c010d53c:	89 4d e0             	mov    %ecx,-0x20(%ebp)
        if (!ptde || i >= kspace_l1inx || !(ptde & PG_PRESENT)) {
c010d53f:	85 c9                	test   %ecx,%ecx
c010d541:	0f 94 c0             	sete   %al
c010d544:	81 fa ff 02 00 00    	cmp    $0x2ff,%edx
c010d54a:	0f 97 c2             	seta   %dl
c010d54d:	08 d0                	or     %dl,%al
c010d54f:	75 c4                	jne    c010d515 <__dup_pagetable+0x46>
c010d551:	f6 c1 01             	test   $0x1,%cl
c010d554:	74 bf                	je     c010d515 <__dup_pagetable+0x46>
            continue;
        }

        // 复制L2页表
        void* pt_pp = pmm_alloc_page(pid, PP_FGPERSIST);
c010d556:	83 ec 08             	sub    $0x8,%esp
c010d559:	6a 01                	push   $0x1
c010d55b:	ff 75 08             	push   0x8(%ebp)
c010d55e:	e8 64 d5 ff ff       	call   c010aac7 <pmm_alloc_page>
c010d563:	89 45 d8             	mov    %eax,-0x28(%ebp)
        vmm_set_mapping(
c010d566:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c010d56d:	6a 03                	push   $0x3
c010d56f:	50                   	push   %eax
c010d570:	68 00 10 40 d1       	push   $0xd1401000
c010d575:	68 00 00 c0 ff       	push   $0xffc00000
c010d57a:	e8 c1 ce ff ff       	call   c010a440 <vmm_set_mapping>
          PD_REFERENCED, PG_MOUNT_2, pt_pp, PG_PREM_RW, VMAP_NULL);

        x86_page_table* ppt = (x86_page_table*)(mount_point | (i << 12));
c010d57f:	8b 7d e4             	mov    -0x1c(%ebp),%edi
c010d582:	c1 e7 0c             	shl    $0xc,%edi
c010d585:	0b 7d 0c             	or     0xc(%ebp),%edi
        x86_page_table* pt = PG_MOUNT_2;

        for (size_t j = 0; j < PG_MAX_ENTRIES; j++) {
c010d588:	83 c4 20             	add    $0x20,%esp
c010d58b:	bb 00 00 00 00       	mov    $0x0,%ebx
c010d590:	eb 23                	jmp    c010d5b5 <__dup_pagetable+0xe6>
            x86_pte_t pte = ppt->entry[j];
c010d592:	8b 34 9f             	mov    (%edi,%ebx,4),%esi
            pmm_ref_page(pid, PG_ENTRY_ADDR(pte));
c010d595:	89 f0                	mov    %esi,%eax
c010d597:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c010d59c:	83 ec 08             	sub    $0x8,%esp
c010d59f:	50                   	push   %eax
c010d5a0:	ff 75 08             	push   0x8(%ebp)
c010d5a3:	e8 1f d6 ff ff       	call   c010abc7 <pmm_ref_page>
            pt->entry[j] = pte;
c010d5a8:	89 34 9d 00 10 40 d1 	mov    %esi,-0x2ebff000(,%ebx,4)
        for (size_t j = 0; j < PG_MAX_ENTRIES; j++) {
c010d5af:	83 c3 01             	add    $0x1,%ebx
c010d5b2:	83 c4 10             	add    $0x10,%esp
c010d5b5:	81 fb ff 03 00 00    	cmp    $0x3ff,%ebx
c010d5bb:	76 d5                	jbe    c010d592 <__dup_pagetable+0xc3>
        }

        ptd->entry[i] = (uintptr_t)pt_pp | PG_ENTRY_FLAGS(ptde);
c010d5bd:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010d5c0:	25 ff 0f 00 00       	and    $0xfff,%eax
c010d5c5:	0b 45 d8             	or     -0x28(%ebp),%eax
c010d5c8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c010d5cb:	89 04 95 00 00 40 d1 	mov    %eax,-0x2ec00000(,%edx,4)
c010d5d2:	e9 4b ff ff ff       	jmp    c010d522 <__dup_pagetable+0x53>
    }

    ptd->entry[PG_MAX_ENTRIES - 1] = NEW_L1_ENTRY(T_SELF_REF_PERM, ptd_pp);
c010d5d7:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c010d5da:	89 d0                	mov    %edx,%eax
c010d5dc:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c010d5e1:	83 c8 1b             	or     $0x1b,%eax
c010d5e4:	a3 fc 0f 40 d1       	mov    %eax,0xd1400ffc

    return ptd_pp;
}
c010d5e9:	89 d0                	mov    %edx,%eax
c010d5eb:	8d 65 f4             	lea    -0xc(%ebp),%esp
c010d5ee:	5b                   	pop    %ebx
c010d5ef:	5e                   	pop    %esi
c010d5f0:	5f                   	pop    %edi
c010d5f1:	5d                   	pop    %ebp
c010d5f2:	c3                   	ret    

c010d5f3 <__del_pagetable>:

void
__del_pagetable(pid_t pid, uintptr_t mount_point)
{
c010d5f3:	55                   	push   %ebp
c010d5f4:	89 e5                	mov    %esp,%ebp
c010d5f6:	57                   	push   %edi
c010d5f7:	56                   	push   %esi
c010d5f8:	53                   	push   %ebx
c010d5f9:	83 ec 1c             	sub    $0x1c,%esp
c010d5fc:	8b 7d 08             	mov    0x8(%ebp),%edi
    x86_page_table* pptd = (x86_page_table*)(mount_point | (0x3FF << 12));
c010d5ff:	8b 45 0c             	mov    0xc(%ebp),%eax
c010d602:	0d 00 f0 3f 00       	or     $0x3ff000,%eax
c010d607:	89 45 dc             	mov    %eax,-0x24(%ebp)

    // only remove user address space
    for (size_t i = 0; i < L1_INDEX(KERNEL_MM_BASE); i++) {
c010d60a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
c010d611:	eb 3f                	jmp    c010d652 <__del_pagetable+0x5f>
            continue;
        }

        x86_page_table* ppt = (x86_page_table*)(mount_point | (i << 12));

        for (size_t j = 0; j < PG_MAX_ENTRIES; j++) {
c010d613:	83 c3 01             	add    $0x1,%ebx
c010d616:	81 fb ff 03 00 00    	cmp    $0x3ff,%ebx
c010d61c:	77 1b                	ja     c010d639 <__del_pagetable+0x46>
            x86_pte_t pte = ppt->entry[j];
c010d61e:	8b 04 9e             	mov    (%esi,%ebx,4),%eax
            // free the 4KB data page
            if ((pte & PG_PRESENT)) {
c010d621:	a8 01                	test   $0x1,%al
c010d623:	74 ee                	je     c010d613 <__del_pagetable+0x20>
                pmm_free_page(pid, PG_ENTRY_ADDR(pte));
c010d625:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c010d62a:	83 ec 08             	sub    $0x8,%esp
c010d62d:	50                   	push   %eax
c010d62e:	57                   	push   %edi
c010d62f:	e8 2c d5 ff ff       	call   c010ab60 <pmm_free_page>
c010d634:	83 c4 10             	add    $0x10,%esp
c010d637:	eb da                	jmp    c010d613 <__del_pagetable+0x20>
            }
        }
        // free the L2 page table
        pmm_free_page(pid, PG_ENTRY_ADDR(ptde));
c010d639:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010d63c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c010d641:	83 ec 08             	sub    $0x8,%esp
c010d644:	50                   	push   %eax
c010d645:	57                   	push   %edi
c010d646:	e8 15 d5 ff ff       	call   c010ab60 <pmm_free_page>
c010d64b:	83 c4 10             	add    $0x10,%esp
    for (size_t i = 0; i < L1_INDEX(KERNEL_MM_BASE); i++) {
c010d64e:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
c010d652:	81 7d e4 ff 02 00 00 	cmpl   $0x2ff,-0x1c(%ebp)
c010d659:	77 23                	ja     c010d67e <__del_pagetable+0x8b>
        x86_pte_t ptde = pptd->entry[i];
c010d65b:	8b 45 dc             	mov    -0x24(%ebp),%eax
c010d65e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c010d661:	8b 04 90             	mov    (%eax,%edx,4),%eax
c010d664:	89 45 e0             	mov    %eax,-0x20(%ebp)
        if (!ptde || !(ptde & PG_PRESENT)) {
c010d667:	85 c0                	test   %eax,%eax
c010d669:	74 e3                	je     c010d64e <__del_pagetable+0x5b>
c010d66b:	a8 01                	test   $0x1,%al
c010d66d:	74 df                	je     c010d64e <__del_pagetable+0x5b>
        x86_page_table* ppt = (x86_page_table*)(mount_point | (i << 12));
c010d66f:	c1 e2 0c             	shl    $0xc,%edx
c010d672:	89 d6                	mov    %edx,%esi
c010d674:	0b 75 0c             	or     0xc(%ebp),%esi
        for (size_t j = 0; j < PG_MAX_ENTRIES; j++) {
c010d677:	bb 00 00 00 00       	mov    $0x0,%ebx
c010d67c:	eb 98                	jmp    c010d616 <__del_pagetable+0x23>
    }
    // free the L1 directory
    pmm_free_page(pid, PG_ENTRY_ADDR(pptd->entry[PG_MAX_ENTRIES - 1]));
c010d67e:	8b 45 dc             	mov    -0x24(%ebp),%eax
c010d681:	8b 80 fc 0f 00 00    	mov    0xffc(%eax),%eax
c010d687:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c010d68c:	83 ec 08             	sub    $0x8,%esp
c010d68f:	50                   	push   %eax
c010d690:	57                   	push   %edi
c010d691:	e8 ca d4 ff ff       	call   c010ab60 <pmm_free_page>
}
c010d696:	83 c4 10             	add    $0x10,%esp
c010d699:	8d 65 f4             	lea    -0xc(%ebp),%esp
c010d69c:	5b                   	pop    %ebx
c010d69d:	5e                   	pop    %esi
c010d69e:	5f                   	pop    %edi
c010d69f:	5d                   	pop    %ebp
c010d6a0:	c3                   	ret    

c010d6a1 <vmm_dup_vmspace>:

void*
vmm_dup_vmspace(pid_t pid)
{
c010d6a1:	55                   	push   %ebp
c010d6a2:	89 e5                	mov    %esp,%ebp
c010d6a4:	83 ec 10             	sub    $0x10,%esp
    return __dup_pagetable(pid, PD_REFERENCED);
c010d6a7:	68 00 00 c0 ff       	push   $0xffc00000
c010d6ac:	ff 75 08             	push   0x8(%ebp)
c010d6af:	e8 1b fe ff ff       	call   c010d4cf <__dup_pagetable>
}
c010d6b4:	c9                   	leave  
c010d6b5:	c3                   	ret    

c010d6b6 <__lxsys_getpid>:
    return dup_proc();
}

__DEFINE_LXSYSCALL(pid_t, getpid)
{
    return __current->pid;
c010d6b6:	a1 8c 05 d1 c0       	mov    0xc0d1058c,%eax
c010d6bb:	8b 00                	mov    (%eax),%eax
}
c010d6bd:	c3                   	ret    

c010d6be <__lxsys_getppid>:

__DEFINE_LXSYSCALL(pid_t, getppid)
{
    return __current->parent->pid;
c010d6be:	a1 8c 05 d1 c0       	mov    0xc0d1058c,%eax
c010d6c3:	8b 40 04             	mov    0x4(%eax),%eax
c010d6c6:	8b 00                	mov    (%eax),%eax
}
c010d6c8:	c3                   	ret    

c010d6c9 <__lxsys_getpgid>:

__DEFINE_LXSYSCALL(pid_t, getpgid)
{
    return __current->pgid;
c010d6c9:	a1 8c 05 d1 c0       	mov    0xc0d1058c,%eax
c010d6ce:	8b 80 08 01 00 00    	mov    0x108(%eax),%eax
}
c010d6d4:	c3                   	ret    

c010d6d5 <__lxsys_setpgid>:

__DEFINE_LXSYSCALL2(int, setpgid, pid_t, pid, pid_t, pgid)
{
c010d6d5:	55                   	push   %ebp
c010d6d6:	89 e5                	mov    %esp,%ebp
c010d6d8:	57                   	push   %edi
c010d6d9:	56                   	push   %esi
c010d6da:	53                   	push   %ebx
c010d6db:	83 ec 0c             	sub    $0xc,%esp
c010d6de:	8b 45 08             	mov    0x8(%ebp),%eax
c010d6e1:	8b 75 0c             	mov    0xc(%ebp),%esi
    struct proc_info* proc = pid ? get_process(pid) : __current;
c010d6e4:	85 c0                	test   %eax,%eax
c010d6e6:	75 65                	jne    c010d74d <__lxsys_setpgid+0x78>
c010d6e8:	8b 1d 8c 05 d1 c0    	mov    0xc0d1058c,%ebx

    if (!proc) {
c010d6ee:	85 db                	test   %ebx,%ebx
c010d6f0:	74 6b                	je     c010d75d <__lxsys_setpgid+0x88>
        __current->k_status = LXINVL;
        return -1;
    }

    pgid = pgid ? pgid : proc->pid;
c010d6f2:	85 f6                	test   %esi,%esi
c010d6f4:	75 02                	jne    c010d6f8 <__lxsys_setpgid+0x23>
c010d6f6:	8b 33                	mov    (%ebx),%esi

    struct proc_info* gruppenfuhrer = get_process(pgid);
c010d6f8:	83 ec 0c             	sub    $0xc,%esp
c010d6fb:	56                   	push   %esi
c010d6fc:	e8 00 df ff ff       	call   c010b601 <get_process>

    if (!gruppenfuhrer || proc->pgid == proc->pid) {
c010d701:	83 c4 10             	add    $0x10,%esp
c010d704:	85 c0                	test   %eax,%eax
c010d706:	74 6b                	je     c010d773 <__lxsys_setpgid+0x9e>
c010d708:	8b 13                	mov    (%ebx),%edx
c010d70a:	39 93 08 01 00 00    	cmp    %edx,0x108(%ebx)
c010d710:	74 61                	je     c010d773 <__lxsys_setpgid+0x9e>
        __current->k_status = LXINVL;
        return -1;
    }

    llist_delete(&proc->grp_member);
c010d712:	8d 53 6c             	lea    0x6c(%ebx),%edx
    elem->prev->next = elem->next;
c010d715:	8b 7b 6c             	mov    0x6c(%ebx),%edi
c010d718:	8b 4b 70             	mov    0x70(%ebx),%ecx
c010d71b:	89 4f 04             	mov    %ecx,0x4(%edi)
    elem->next->prev = elem->prev;
c010d71e:	8b 7b 6c             	mov    0x6c(%ebx),%edi
c010d721:	89 39                	mov    %edi,(%ecx)
    elem->prev = elem;
c010d723:	89 53 6c             	mov    %edx,0x6c(%ebx)
    elem->next = elem;
c010d726:	89 53 70             	mov    %edx,0x70(%ebx)
    llist_append(&gruppenfuhrer->grp_member, &proc->grp_member);
c010d729:	8d 78 6c             	lea    0x6c(%eax),%edi
    __llist_add(elem, head, head->next);
c010d72c:	8b 48 70             	mov    0x70(%eax),%ecx
    next->prev = elem;
c010d72f:	89 11                	mov    %edx,(%ecx)
    elem->next = next;
c010d731:	89 4b 70             	mov    %ecx,0x70(%ebx)
    elem->prev = prev;
c010d734:	89 7b 6c             	mov    %edi,0x6c(%ebx)
    prev->next = elem;
c010d737:	89 50 70             	mov    %edx,0x70(%eax)

    proc->pgid = pgid;
c010d73a:	89 b3 08 01 00 00    	mov    %esi,0x108(%ebx)
    return 0;
c010d740:	b8 00 00 00 00       	mov    $0x0,%eax
}
c010d745:	8d 65 f4             	lea    -0xc(%ebp),%esp
c010d748:	5b                   	pop    %ebx
c010d749:	5e                   	pop    %esi
c010d74a:	5f                   	pop    %edi
c010d74b:	5d                   	pop    %ebp
c010d74c:	c3                   	ret    
    struct proc_info* proc = pid ? get_process(pid) : __current;
c010d74d:	83 ec 0c             	sub    $0xc,%esp
c010d750:	50                   	push   %eax
c010d751:	e8 ab de ff ff       	call   c010b601 <get_process>
c010d756:	89 c3                	mov    %eax,%ebx
c010d758:	83 c4 10             	add    $0x10,%esp
c010d75b:	eb 91                	jmp    c010d6ee <__lxsys_setpgid+0x19>
        __current->k_status = LXINVL;
c010d75d:	a1 8c 05 d1 c0       	mov    0xc0d1058c,%eax
c010d762:	c7 80 b4 00 00 00 fa 	movl   $0xfffffffa,0xb4(%eax)
c010d769:	ff ff ff 
        return -1;
c010d76c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c010d771:	eb d2                	jmp    c010d745 <__lxsys_setpgid+0x70>
        __current->k_status = LXINVL;
c010d773:	a1 8c 05 d1 c0       	mov    0xc0d1058c,%eax
c010d778:	c7 80 b4 00 00 00 fa 	movl   $0xfffffffa,0xb4(%eax)
c010d77f:	ff ff ff 
        return -1;
c010d782:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c010d787:	eb bc                	jmp    c010d745 <__lxsys_setpgid+0x70>

c010d789 <init_proc_user_space>:

void
init_proc_user_space(struct proc_info* pcb)
{
c010d789:	55                   	push   %ebp
c010d78a:	89 e5                	mov    %esp,%ebp
c010d78c:	53                   	push   %ebx
c010d78d:	83 ec 0c             	sub    $0xc,%esp
c010d790:	8b 5d 08             	mov    0x8(%ebp),%ebx
    vmm_mount_pd(PD_MOUNT_1, pcb->page_table);
c010d793:	ff 73 58             	push   0x58(%ebx)
c010d796:	68 00 00 00 d1       	push   $0xd1000000
c010d79b:	e8 8b ce ff ff       	call   c010a62b <vmm_mount_pd>

    /*---  分配用户栈  ---*/

    // 注册用户栈区域
    region_add(
c010d7a0:	6a 0d                	push   $0xd
c010d7a2:	68 f0 ff ff 9f       	push   $0x9ffffff0
c010d7a7:	68 00 00 f0 9f       	push   $0x9ff00000
c010d7ac:	81 c3 94 00 00 00    	add    $0x94,%ebx
c010d7b2:	53                   	push   %ebx
c010d7b3:	e8 7e d0 ff ff       	call   c010a836 <region_add>
      &pcb->mm.regions, USTACK_END, USTACK_TOP, REGION_RW | REGION_RSHARED);

    // 预留地址空间，具体物理页将由Page Fault Handler按需分配。
    for (uintptr_t i = PG_ALIGN(USTACK_END); i < USTACK_TOP; i += PG_SIZE) {
c010d7b8:	83 c4 20             	add    $0x20,%esp
c010d7bb:	bb 00 00 f0 9f       	mov    $0x9ff00000,%ebx
c010d7c0:	eb 1d                	jmp    c010d7df <init_proc_user_space+0x56>
        vmm_set_mapping(PD_MOUNT_1, i, 0, PG_ALLOW_USER | PG_WRITE, VMAP_NULL);
c010d7c2:	83 ec 0c             	sub    $0xc,%esp
c010d7c5:	6a 00                	push   $0x0
c010d7c7:	6a 06                	push   $0x6
c010d7c9:	6a 00                	push   $0x0
c010d7cb:	53                   	push   %ebx
c010d7cc:	68 00 00 00 d1       	push   $0xd1000000
c010d7d1:	e8 6a cc ff ff       	call   c010a440 <vmm_set_mapping>
    for (uintptr_t i = PG_ALIGN(USTACK_END); i < USTACK_TOP; i += PG_SIZE) {
c010d7d6:	81 c3 00 10 00 00    	add    $0x1000,%ebx
c010d7dc:	83 c4 20             	add    $0x20,%esp
c010d7df:	81 fb ef ff ff 9f    	cmp    $0x9fffffef,%ebx
c010d7e5:	76 db                	jbe    c010d7c2 <init_proc_user_space+0x39>
    }

    // todo: other uspace initialization stuff

    vmm_unmount_pd(PD_MOUNT_1);
c010d7e7:	83 ec 0c             	sub    $0xc,%esp
c010d7ea:	68 00 00 00 d1       	push   $0xd1000000
c010d7ef:	e8 5b ce ff ff       	call   c010a64f <vmm_unmount_pd>
}
c010d7f4:	83 c4 10             	add    $0x10,%esp
c010d7f7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c010d7fa:	c9                   	leave  
c010d7fb:	c3                   	ret    

c010d7fc <__mark_region>:

void
__mark_region(uintptr_t start_vpn, uintptr_t end_vpn, int attr)
{
c010d7fc:	55                   	push   %ebp
c010d7fd:	89 e5                	mov    %esp,%ebp
c010d7ff:	57                   	push   %edi
c010d800:	56                   	push   %esi
c010d801:	53                   	push   %ebx
c010d802:	8b 55 08             	mov    0x8(%ebp),%edx
    for (size_t i = start_vpn; i <= end_vpn; i++) {
c010d805:	eb 20                	jmp    c010d827 <__mark_region+0x2b>
    asm volatile("invlpg (%0)" ::"r"((uintptr_t)va) : "memory");
c010d807:	0f 01 3f             	invlpg (%edi)
        cpu_invplg(newproc);

        if ((attr & REGION_MODE_MASK) == REGION_RSHARED) {
            // 如果读共享，则将两者的都标注为只读，那么任何写入都将会应用COW策略。
            cpu_invplg(curproc);
            cpu_invplg(i << 12);
c010d80a:	89 d1                	mov    %edx,%ecx
c010d80c:	c1 e1 0c             	shl    $0xc,%ecx
c010d80f:	0f 01 39             	invlpg (%ecx)
            *curproc = *curproc & ~PG_WRITE;
c010d812:	8b 0c 9e             	mov    (%esi,%ebx,4),%ecx
c010d815:	83 e1 fd             	and    $0xfffffffd,%ecx
c010d818:	89 0c 9e             	mov    %ecx,(%esi,%ebx,4)
            *newproc = *newproc & ~PG_WRITE;
c010d81b:	8b 0c 98             	mov    (%eax,%ebx,4),%ecx
c010d81e:	83 e1 fd             	and    $0xfffffffd,%ecx
c010d821:	89 0c 98             	mov    %ecx,(%eax,%ebx,4)
    for (size_t i = start_vpn; i <= end_vpn; i++) {
c010d824:	83 c2 01             	add    $0x1,%edx
c010d827:	3b 55 0c             	cmp    0xc(%ebp),%edx
c010d82a:	77 44                	ja     c010d870 <__mark_region+0x74>
        x86_pte_t* curproc = &PTE_MOUNTED(PD_REFERENCED, i);
c010d82c:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
c010d833:	25 00 f0 3f 00       	and    $0x3ff000,%eax
c010d838:	89 c6                	mov    %eax,%esi
c010d83a:	81 ce 00 00 c0 ff    	or     $0xffc00000,%esi
c010d840:	89 d3                	mov    %edx,%ebx
c010d842:	81 e3 ff 03 00 00    	and    $0x3ff,%ebx
c010d848:	8d 0c 9d 00 00 00 00 	lea    0x0(,%ebx,4),%ecx
c010d84f:	8d 3c 0e             	lea    (%esi,%ecx,1),%edi
        x86_pte_t* newproc = &PTE_MOUNTED(PD_MOUNT_1, i);
c010d852:	0d 00 00 00 d1       	or     $0xd1000000,%eax
c010d857:	01 c1                	add    %eax,%ecx
c010d859:	0f 01 39             	invlpg (%ecx)
        if ((attr & REGION_MODE_MASK) == REGION_RSHARED) {
c010d85c:	8b 4d 10             	mov    0x10(%ebp),%ecx
c010d85f:	83 e1 03             	and    $0x3,%ecx
c010d862:	83 f9 01             	cmp    $0x1,%ecx
c010d865:	74 a0                	je     c010d807 <__mark_region+0xb>
        } else {
            // 如果是私有页，则将该页从新进程中移除。
            *newproc = 0;
c010d867:	c7 04 98 00 00 00 00 	movl   $0x0,(%eax,%ebx,4)
c010d86e:	eb b4                	jmp    c010d824 <__mark_region+0x28>
        }
    }
}
c010d870:	5b                   	pop    %ebx
c010d871:	5e                   	pop    %esi
c010d872:	5f                   	pop    %edi
c010d873:	5d                   	pop    %ebp
c010d874:	c3                   	ret    

c010d875 <setup_proc_mem>:

extern void __kernel_end;

void
setup_proc_mem(struct proc_info* proc, uintptr_t usedMnt)
{
c010d875:	55                   	push   %ebp
c010d876:	89 e5                	mov    %esp,%ebp
c010d878:	57                   	push   %edi
c010d879:	56                   	push   %esi
c010d87a:	53                   	push   %ebx
c010d87b:	83 ec 34             	sub    $0x34,%esp
    // copy the entire kernel page table
    pid_t pid = proc->pid;
c010d87e:	8b 45 08             	mov    0x8(%ebp),%eax
c010d881:	8b 00                	mov    (%eax),%eax
c010d883:	89 45 e0             	mov    %eax,-0x20(%ebp)
    void* pt_copy = __dup_pagetable(pid, usedMnt);
c010d886:	ff 75 0c             	push   0xc(%ebp)
c010d889:	50                   	push   %eax
c010d88a:	e8 40 fc ff ff       	call   c010d4cf <__dup_pagetable>
c010d88f:	89 45 d4             	mov    %eax,-0x2c(%ebp)

    vmm_mount_pd(PD_MOUNT_1, pt_copy); // 将新进程的页表挂载到挂载点#2
c010d892:	83 c4 08             	add    $0x8,%esp
c010d895:	50                   	push   %eax
c010d896:	68 00 00 00 d1       	push   $0xd1000000
c010d89b:	e8 8b cd ff ff       	call   c010a62b <vmm_mount_pd>

    // copy the kernel stack
    for (size_t i = KSTACK_START >> 12; i <= KSTACK_TOP >> 12; i++) {
c010d8a0:	83 c4 10             	add    $0x10,%esp
c010d8a3:	bf f0 03 00 00       	mov    $0x3f0,%edi
c010d8a8:	eb 66                	jmp    c010d910 <setup_proc_mem+0x9b>
        volatile x86_pte_t* ppte = &PTE_MOUNTED(PD_MOUNT_1, i);
c010d8aa:	8d 04 bd 00 00 00 00 	lea    0x0(,%edi,4),%eax
c010d8b1:	25 00 f0 3f 00       	and    $0x3ff000,%eax
c010d8b6:	0d 00 00 00 d1       	or     $0xd1000000,%eax
c010d8bb:	89 c6                	mov    %eax,%esi
c010d8bd:	89 fb                	mov    %edi,%ebx
c010d8bf:	81 e3 ff 03 00 00    	and    $0x3ff,%ebx
c010d8c5:	8d 04 98             	lea    (%eax,%ebx,4),%eax
c010d8c8:	0f 01 38             	invlpg (%eax)
            In the name of Celestia our glorious goddess, I will fucking HATE
           the TLB for the rest of my LIFE!
        */
        cpu_invplg(ppte);

        x86_pte_t p = *ppte;
c010d8cb:	8b 04 9e             	mov    (%esi,%ebx,4),%eax
        void* ppa = vmm_dup_page(pid, PG_ENTRY_ADDR(p));
c010d8ce:	89 45 dc             	mov    %eax,-0x24(%ebp)
c010d8d1:	89 c2                	mov    %eax,%edx
c010d8d3:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
c010d8d9:	83 ec 08             	sub    $0x8,%esp
c010d8dc:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c010d8df:	52                   	push   %edx
c010d8e0:	ff 75 e0             	push   -0x20(%ebp)
c010d8e3:	e8 8f ca ff ff       	call   c010a377 <vmm_dup_page>
c010d8e8:	89 45 d8             	mov    %eax,-0x28(%ebp)
        pmm_free_page(pid, PG_ENTRY_ADDR(p));
c010d8eb:	83 c4 08             	add    $0x8,%esp
c010d8ee:	ff 75 e4             	push   -0x1c(%ebp)
c010d8f1:	ff 75 e0             	push   -0x20(%ebp)
c010d8f4:	e8 67 d2 ff ff       	call   c010ab60 <pmm_free_page>
        *ppte = (p & 0xfff) | (uintptr_t)ppa;
c010d8f9:	8b 55 dc             	mov    -0x24(%ebp),%edx
c010d8fc:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
c010d902:	89 d0                	mov    %edx,%eax
c010d904:	0b 45 d8             	or     -0x28(%ebp),%eax
c010d907:	89 04 9e             	mov    %eax,(%esi,%ebx,4)
    for (size_t i = KSTACK_START >> 12; i <= KSTACK_TOP >> 12; i++) {
c010d90a:	83 c7 01             	add    $0x1,%edi
c010d90d:	83 c4 10             	add    $0x10,%esp
c010d910:	81 ff ff 03 00 00    	cmp    $0x3ff,%edi
c010d916:	76 92                	jbe    c010d8aa <setup_proc_mem+0x35>

    // 我们不需要分配内核的区域，因为所有的内核代码和数据段只能通过系统调用来访问，任何非法的访问
    // 都会导致eip落在区域外面，从而segmentation fault.

    // 至于其他的区域我们暂时没有办法知道，因为那需要知道用户程序的信息。我们留到之后在处理。
    proc->page_table = pt_copy;
c010d918:	8b 45 08             	mov    0x8(%ebp),%eax
c010d91b:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
c010d91e:	89 48 58             	mov    %ecx,0x58(%eax)
c010d921:	8d 65 f4             	lea    -0xc(%ebp),%esp
c010d924:	5b                   	pop    %ebx
c010d925:	5e                   	pop    %esi
c010d926:	5f                   	pop    %edi
c010d927:	5d                   	pop    %ebp
c010d928:	c3                   	ret    

c010d929 <dup_proc>:
{
c010d929:	55                   	push   %ebp
c010d92a:	89 e5                	mov    %esp,%ebp
c010d92c:	57                   	push   %edi
c010d92d:	56                   	push   %esi
c010d92e:	53                   	push   %ebx
c010d92f:	83 ec 0c             	sub    $0xc,%esp
    struct proc_info* pcb = alloc_process();
c010d932:	e8 70 d9 ff ff       	call   c010b2a7 <alloc_process>
c010d937:	89 c3                	mov    %eax,%ebx
    pcb->mm.u_heap = __current->mm.u_heap;
c010d939:	a1 8c 05 d1 c0       	mov    0xc0d1058c,%eax
c010d93e:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
c010d944:	89 93 84 00 00 00    	mov    %edx,0x84(%ebx)
c010d94a:	8b 90 88 00 00 00    	mov    0x88(%eax),%edx
c010d950:	89 93 88 00 00 00    	mov    %edx,0x88(%ebx)
c010d956:	8b 90 8c 00 00 00    	mov    0x8c(%eax),%edx
c010d95c:	89 93 8c 00 00 00    	mov    %edx,0x8c(%ebx)
c010d962:	8b 90 90 00 00 00    	mov    0x90(%eax),%edx
c010d968:	89 93 90 00 00 00    	mov    %edx,0x90(%ebx)
    pcb->intr_ctx = __current->intr_ctx;
c010d96e:	8d 7b 08             	lea    0x8(%ebx),%edi
c010d971:	8d 70 08             	lea    0x8(%eax),%esi
c010d974:	b9 13 00 00 00       	mov    $0x13,%ecx
c010d979:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    pcb->parent = __current;
c010d97b:	89 43 04             	mov    %eax,0x4(%ebx)
    region_copy(&__current->mm.regions, &pcb->mm.regions);
c010d97e:	05 94 00 00 00       	add    $0x94,%eax
c010d983:	83 ec 08             	sub    $0x8,%esp
c010d986:	8d 93 94 00 00 00    	lea    0x94(%ebx),%edx
c010d98c:	52                   	push   %edx
c010d98d:	50                   	push   %eax
c010d98e:	e8 29 cf ff ff       	call   c010a8bc <region_copy>
    setup_proc_mem(pcb, PD_REFERENCED);
c010d993:	83 c4 08             	add    $0x8,%esp
c010d996:	68 00 00 c0 ff       	push   $0xffc00000
c010d99b:	53                   	push   %ebx
c010d99c:	e8 d4 fe ff ff       	call   c010d875 <setup_proc_mem>
    llist_for_each(pos, n, &pcb->mm.regions.head, head)
c010d9a1:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
c010d9a7:	8b 70 04             	mov    0x4(%eax),%esi
c010d9aa:	83 c4 10             	add    $0x10,%esp
c010d9ad:	eb 05                	jmp    c010d9b4 <dup_proc+0x8b>
c010d9af:	89 f0                	mov    %esi,%eax
c010d9b1:	8b 76 04             	mov    0x4(%esi),%esi
c010d9b4:	8d 93 94 00 00 00    	lea    0x94(%ebx),%edx
c010d9ba:	39 d0                	cmp    %edx,%eax
c010d9bc:	74 24                	je     c010d9e2 <dup_proc+0xb9>
        if ((pos->attr & REGION_WSHARED)) {
c010d9be:	8b 50 10             	mov    0x10(%eax),%edx
c010d9c1:	f6 c2 02             	test   $0x2,%dl
c010d9c4:	75 e9                	jne    c010d9af <dup_proc+0x86>
        uintptr_t start_vpn = pos->start >> 12;
c010d9c6:	8b 48 08             	mov    0x8(%eax),%ecx
c010d9c9:	c1 e9 0c             	shr    $0xc,%ecx
        uintptr_t end_vpn = pos->end >> 12;
c010d9cc:	8b 40 0c             	mov    0xc(%eax),%eax
c010d9cf:	c1 e8 0c             	shr    $0xc,%eax
        __mark_region(start_vpn, end_vpn, pos->attr);
c010d9d2:	83 ec 04             	sub    $0x4,%esp
c010d9d5:	52                   	push   %edx
c010d9d6:	50                   	push   %eax
c010d9d7:	51                   	push   %ecx
c010d9d8:	e8 1f fe ff ff       	call   c010d7fc <__mark_region>
c010d9dd:	83 c4 10             	add    $0x10,%esp
c010d9e0:	eb cd                	jmp    c010d9af <dup_proc+0x86>
    vmm_unmount_pd(PD_MOUNT_1);
c010d9e2:	83 ec 0c             	sub    $0xc,%esp
c010d9e5:	68 00 00 00 d1       	push   $0xd1000000
c010d9ea:	e8 60 cc ff ff       	call   c010a64f <vmm_unmount_pd>
    pcb->intr_ctx.registers.eax = 0;
c010d9ef:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    commit_process(pcb);
c010d9f6:	89 1c 24             	mov    %ebx,(%esp)
c010d9f9:	e8 7c d9 ff ff       	call   c010b37a <commit_process>
    return pcb->pid;
c010d9fe:	8b 03                	mov    (%ebx),%eax
}
c010da00:	8d 65 f4             	lea    -0xc(%ebp),%esp
c010da03:	5b                   	pop    %ebx
c010da04:	5e                   	pop    %esi
c010da05:	5f                   	pop    %edi
c010da06:	5d                   	pop    %ebp
c010da07:	c3                   	ret    

c010da08 <__lxsys_fork>:
{
c010da08:	55                   	push   %ebp
c010da09:	89 e5                	mov    %esp,%ebp
c010da0b:	83 ec 08             	sub    $0x8,%esp
    return dup_proc();
c010da0e:	e8 16 ff ff ff       	call   c010d929 <dup_proc>
}
c010da13:	c9                   	leave  
c010da14:	c3                   	ret    

c010da15 <kprintf>:

x86_page_table* __kernel_ptd;

struct proc_info tmp;

LOG_MODULE("BOOT");
c010da15:	55                   	push   %ebp
c010da16:	89 e5                	mov    %esp,%ebp
c010da18:	83 ec 0c             	sub    $0xc,%esp
c010da1b:	8d 45 0c             	lea    0xc(%ebp),%eax
c010da1e:	50                   	push   %eax
c010da1f:	ff 75 08             	push   0x8(%ebp)
c010da22:	68 84 34 d1 c0       	push   $0xc0d13484
c010da27:	e8 4b e5 ff ff       	call   c010bf77 <__kprintf>
c010da2c:	83 c4 10             	add    $0x10,%esp
c010da2f:	c9                   	leave  
c010da30:	c3                   	ret    

c010da31 <spawn_proc0>:
 * @brief 创建并运行proc0进程
 *
 */
void
spawn_proc0()
{
c010da31:	55                   	push   %ebp
c010da32:	89 e5                	mov    %esp,%ebp
c010da34:	57                   	push   %edi
c010da35:	56                   	push   %esi
c010da36:	53                   	push   %ebx
c010da37:	83 ec 0c             	sub    $0xc,%esp
    struct proc_info* proc0 = alloc_process();
c010da3a:	e8 68 d8 ff ff       	call   c010b2a7 <alloc_process>
c010da3f:	89 c6                	mov    %eax,%esi
    asm volatile("pushf\n"
c010da41:	9c                   	pushf  
c010da42:	5a                   	pop    %edx
     * （_kernel_post_init已经更名为init_platform）
     *
     * 目前的解决方案是2
     */

    proc0->intr_ctx = (isr_param){ .registers = { .ds = KDATA_SEG,
c010da43:	8d 78 08             	lea    0x8(%eax),%edi
c010da46:	b9 13 00 00 00       	mov    $0x13,%ecx
c010da4b:	b8 00 00 00 00       	mov    $0x0,%eax
c010da50:	f3 ab                	rep stos %eax,%es:(%edi)
c010da52:	c7 46 24 10 00 00 00 	movl   $0x10,0x24(%esi)
c010da59:	c7 46 28 10 00 00 00 	movl   $0x10,0x28(%esi)
c010da60:	c7 46 2c 10 00 00 00 	movl   $0x10,0x2c(%esi)
c010da67:	c7 46 30 10 00 00 00 	movl   $0x10,0x30(%esi)
c010da6e:	c7 46 40 37 df 10 c0 	movl   $0xc010df37,0x40(%esi)
c010da75:	c7 46 44 08 00 00 00 	movl   $0x8,0x44(%esi)
c010da7c:	89 56 48             	mov    %edx,0x48(%esi)
c010da7f:	c7 46 50 10 00 00 00 	movl   $0x10,0x50(%esi)
                                                  .gs = KDATA_SEG },
                                   .cs = KCODE_SEG,
                                   .eip = (void*)__proc0,
                                   .ss = KDATA_SEG,
                                   .eflags = cpu_reflags() };
    proc0->parent = proc0;
c010da86:	89 76 04             	mov    %esi,0x4(%esi)
    // cpu_disable_interrupt();

    /* Ok... 首先fork进我们的零号进程，而后由那里，我们fork进init进程。 */

    // 把当前虚拟地址空间（内核）复制一份。
    proc0->page_table = vmm_dup_vmspace(proc0->pid);
c010da89:	83 ec 0c             	sub    $0xc,%esp
c010da8c:	ff 36                	push   (%esi)
c010da8e:	e8 0e fc ff ff       	call   c010d6a1 <vmm_dup_vmspace>
c010da93:	89 46 58             	mov    %eax,0x58(%esi)
    asm("mov %0, %%cr3" ::"r"(v));
c010da96:	0f 22 d8             	mov    %eax,%cr3

    // 直接切换到新的拷贝，进行配置。
    cpu_lcr3(proc0->page_table);

    // 为内核创建一个专属栈空间。
    for (size_t i = 0; i < (KSTACK_SIZE >> PG_SIZE_BITS); i++) {
c010da99:	83 c4 10             	add    $0x10,%esp
c010da9c:	bf 00 00 00 00       	mov    $0x0,%edi
c010daa1:	eb 33                	jmp    c010dad6 <spawn_proc0+0xa5>
        uintptr_t pa = pmm_alloc_page(KERNEL_PID, 0);
c010daa3:	83 ec 08             	sub    $0x8,%esp
c010daa6:	6a 00                	push   $0x0
c010daa8:	6a ff                	push   $0xffffffff
c010daaa:	e8 18 d0 ff ff       	call   c010aac7 <pmm_alloc_page>
c010daaf:	89 c2                	mov    %eax,%edx
        vmm_set_mapping(PD_REFERENCED,
                        KSTACK_START + (i << PG_SIZE_BITS),
c010dab1:	89 f8                	mov    %edi,%eax
c010dab3:	c1 e0 0c             	shl    $0xc,%eax
        vmm_set_mapping(PD_REFERENCED,
c010dab6:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c010dabd:	6a 03                	push   $0x3
c010dabf:	52                   	push   %edx
c010dac0:	05 00 00 3f 00       	add    $0x3f0000,%eax
c010dac5:	50                   	push   %eax
c010dac6:	68 00 00 c0 ff       	push   $0xffc00000
c010dacb:	e8 70 c9 ff ff       	call   c010a440 <vmm_set_mapping>
    for (size_t i = 0; i < (KSTACK_SIZE >> PG_SIZE_BITS); i++) {
c010dad0:	83 c7 01             	add    $0x1,%edi
c010dad3:	83 c4 20             	add    $0x20,%esp
c010dad6:	83 ff 0f             	cmp    $0xf,%edi
c010dad9:	76 c8                	jbe    c010daa3 <spawn_proc0+0x72>
                 "pushl $0\n"
                 "pushl $0\n"
                 "movl %%esp, %0\n"
                 "movl %%ebx, %%esp\n"
                 : "=m"(proc0->intr_ctx.registers.esp)
                 : "i"(KSTACK_TOP), "i"(KCODE_SEG), "r"(proc0->intr_ctx.eip)
c010dadb:	8b 46 40             	mov    0x40(%esi),%eax
    asm volatile("movl %%esp, %%ebx\n"
c010dade:	89 e3                	mov    %esp,%ebx
c010dae0:	bc f0 ff 3f 00       	mov    $0x3ffff0,%esp
c010dae5:	9c                   	pushf  
c010dae6:	6a 08                	push   $0x8
c010dae8:	50                   	push   %eax
c010dae9:	6a 00                	push   $0x0
c010daeb:	6a 00                	push   $0x0
c010daed:	89 66 34             	mov    %esp,0x34(%esi)
c010daf0:	89 dc                	mov    %ebx,%esp
                 : "%ebx", "memory");

    // 向调度器注册进程。
    commit_process(proc0);
c010daf2:	83 ec 0c             	sub    $0xc,%esp
c010daf5:	56                   	push   %esi
c010daf6:	e8 7f d8 ff ff       	call   c010b37a <commit_process>

    // 由于时钟中断与APIC未就绪，我们需要手动进行第一次调度。这里也会同时隐式地恢复我们的eflags.IF位
    proc0->state = PS_RUNNING;
c010dafb:	c6 86 ac 00 00 00 01 	movb   $0x1,0xac(%esi)
    asm volatile("pushl %0\n"
c010db02:	56                   	push   %esi
c010db03:	e9 1d e9 ff ff       	jmp    c010c425 <switch_to>
                 "jmp switch_to\n" ::"r"(proc0));

    /* Should not return */
    assert_msg(0, "Unexpected Return");
c010db08:	83 c4 0c             	add    $0xc,%esp
c010db0b:	68 a9 00 00 00       	push   $0xa9
c010db10:	68 89 34 d1 c0       	push   $0xc0d13489
c010db15:	68 99 34 d1 c0       	push   $0xc0d13499
c010db1a:	e8 44 d4 ff ff       	call   c010af63 <__assert_fail>

c010db1f <_kernel_init>:
{
c010db1f:	55                   	push   %ebp
c010db20:	89 e5                	mov    %esp,%ebp
c010db22:	83 ec 08             	sub    $0x8,%esp
    lxconsole_init();
c010db25:	e8 bc ef ff ff       	call   c010cae6 <lxconsole_init>
    kprintf(KINFO "[MM] Allocated %d pages for stack start at %p\n",
c010db2a:	83 ec 04             	sub    $0x4,%esp
c010db2d:	68 00 00 3f 00       	push   $0x3f0000
c010db32:	6a 10                	push   $0x10
c010db34:	68 10 39 d1 c0       	push   $0xc0d13910
c010db39:	e8 d7 fe ff ff       	call   c010da15 <kprintf>
    sched_init();
c010db3e:	e8 56 d4 ff ff       	call   c010af99 <sched_init>
    spawn_proc0();
c010db43:	e8 e9 fe ff ff       	call   c010da31 <spawn_proc0>

c010db48 <setup_memory>:
extern void __usrtext_end;

// 按照 Memory map 标识可用的物理页
void
setup_memory(multiboot_memory_map_t* map, size_t map_size)
{
c010db48:	55                   	push   %ebp
c010db49:	89 e5                	mov    %esp,%ebp
c010db4b:	57                   	push   %edi
c010db4c:	56                   	push   %esi
c010db4d:	53                   	push   %ebx
c010db4e:	83 ec 2c             	sub    $0x2c,%esp
c010db51:	8b 7d 08             	mov    0x8(%ebp),%edi
c010db54:	8b 75 0c             	mov    0xc(%ebp),%esi

    // First pass, to mark the physical pages
    for (unsigned int i = 0; i < map_size; i++) {
c010db57:	bb 00 00 00 00       	mov    $0x0,%ebx
c010db5c:	eb 03                	jmp    c010db61 <setup_memory+0x19>
c010db5e:	83 c3 01             	add    $0x1,%ebx
c010db61:	39 f3                	cmp    %esi,%ebx
c010db63:	73 57                	jae    c010dbbc <setup_memory+0x74>
        multiboot_memory_map_t mmap = map[i];
c010db65:	8d 14 5b             	lea    (%ebx,%ebx,2),%edx
c010db68:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
c010db6f:	01 f8                	add    %edi,%eax
c010db71:	8b 10                	mov    (%eax),%edx
c010db73:	89 55 d0             	mov    %edx,-0x30(%ebp)
c010db76:	8b 50 04             	mov    0x4(%eax),%edx
c010db79:	89 55 d4             	mov    %edx,-0x2c(%ebp)
c010db7c:	8b 50 08             	mov    0x8(%eax),%edx
c010db7f:	89 55 d8             	mov    %edx,-0x28(%ebp)
c010db82:	8b 50 0c             	mov    0xc(%eax),%edx
c010db85:	89 55 dc             	mov    %edx,-0x24(%ebp)
c010db88:	8b 50 10             	mov    0x10(%eax),%edx
c010db8b:	89 55 e0             	mov    %edx,-0x20(%ebp)
c010db8e:	8b 50 14             	mov    0x14(%eax),%edx
c010db91:	89 55 e4             	mov    %edx,-0x1c(%ebp)
        if (mmap.type == MULTIBOOT_MEMORY_AVAILABLE) {
c010db94:	83 fa 01             	cmp    $0x1,%edx
c010db97:	75 c5                	jne    c010db5e <setup_memory+0x16>
            // 整数向上取整除法
            uintptr_t pg = map[i].addr_low + 0x0fffU;
c010db99:	8b 48 04             	mov    0x4(%eax),%ecx
c010db9c:	8d 91 ff 0f 00 00    	lea    0xfff(%ecx),%edx
            pmm_mark_chunk_free(pg >> PG_SIZE_BITS,
                                map[i].len_low >> PG_SIZE_BITS);
c010dba2:	8b 40 0c             	mov    0xc(%eax),%eax
c010dba5:	c1 e8 0c             	shr    $0xc,%eax
            pmm_mark_chunk_free(pg >> PG_SIZE_BITS,
c010dba8:	83 ec 08             	sub    $0x8,%esp
c010dbab:	50                   	push   %eax
c010dbac:	89 d0                	mov    %edx,%eax
c010dbae:	c1 e8 0c             	shr    $0xc,%eax
c010dbb1:	50                   	push   %eax
c010dbb2:	e8 cd cd ff ff       	call   c010a984 <pmm_mark_chunk_free>
c010dbb7:	83 c4 10             	add    $0x10,%esp
c010dbba:	eb a2                	jmp    c010db5e <setup_memory+0x16>
        }
    }

    // 将内核占据的页，包括前1MB，hhk_init 设为已占用
    size_t pg_count = V2P(&__kernel_end) >> PG_SIZE_BITS;
c010dbbc:	b8 00 e0 d1 00       	mov    $0xd1e000,%eax
c010dbc1:	c1 e8 0c             	shr    $0xc,%eax
    pmm_mark_chunk_occupied(KERNEL_PID, 0, pg_count, 0);
c010dbc4:	6a 00                	push   $0x0
c010dbc6:	50                   	push   %eax
c010dbc7:	6a 00                	push   $0x0
c010dbc9:	6a ff                	push   $0xffffffff
c010dbcb:	e8 ed cd ff ff       	call   c010a9bd <pmm_mark_chunk_occupied>

    size_t vga_buf_pgs = VGA_BUFFER_SIZE >> PG_SIZE_BITS;

    // 首先，标记VGA部分为已占用，并且锁定
    pmm_mark_chunk_occupied(
c010dbd0:	6a 02                	push   $0x2
c010dbd2:	6a 01                	push   $0x1
c010dbd4:	68 b8 00 00 00       	push   $0xb8
c010dbd9:	6a ff                	push   $0xffffffff
c010dbdb:	e8 dd cd ff ff       	call   c010a9bd <pmm_mark_chunk_occupied>
      KERNEL_PID, VGA_BUFFER_PADDR >> PG_SIZE_BITS, vga_buf_pgs, PP_FGLOCKED);

    // 重映射VGA文本缓冲区（以后会变成显存，i.e., framebuffer）
    for (size_t i = 0; i < vga_buf_pgs; i++) {
c010dbe0:	83 c4 20             	add    $0x20,%esp
c010dbe3:	bb 00 00 00 00       	mov    $0x0,%ebx
c010dbe8:	85 db                	test   %ebx,%ebx
c010dbea:	74 07                	je     c010dbf3 <setup_memory+0xab>
                        VGA_BUFFER_PADDR + (i << PG_SIZE_BITS),
                        PG_PREM_URW,
                        VMAP_NULL);
    }

    for (uintptr_t i = &__usrtext_start; i < &__usrtext_end; i += PG_SIZE) {
c010dbec:	bb 00 f0 10 c0       	mov    $0xc010f000,%ebx
c010dbf1:	eb 4d                	jmp    c010dc40 <setup_memory+0xf8>
                        VGA_BUFFER_PADDR + (i << PG_SIZE_BITS),
c010dbf3:	89 d8                	mov    %ebx,%eax
c010dbf5:	c1 e0 0c             	shl    $0xc,%eax
        vmm_set_mapping(PD_REFERENCED,
c010dbf8:	83 ec 0c             	sub    $0xc,%esp
c010dbfb:	6a 00                	push   $0x0
c010dbfd:	6a 07                	push   $0x7
c010dbff:	8d 90 00 80 0b 00    	lea    0xb8000(%eax),%edx
c010dc05:	52                   	push   %edx
c010dc06:	2d 00 00 80 2f       	sub    $0x2f800000,%eax
c010dc0b:	50                   	push   %eax
c010dc0c:	68 00 00 c0 ff       	push   $0xffc00000
c010dc11:	e8 2a c8 ff ff       	call   c010a440 <vmm_set_mapping>
    for (size_t i = 0; i < vga_buf_pgs; i++) {
c010dc16:	83 c3 01             	add    $0x1,%ebx
c010dc19:	83 c4 20             	add    $0x20,%esp
c010dc1c:	eb ca                	jmp    c010dbe8 <setup_memory+0xa0>
        vmm_set_mapping(PD_REFERENCED, i, V2P(i), PG_PREM_UR, VMAP_NULL);
c010dc1e:	83 ec 0c             	sub    $0xc,%esp
c010dc21:	6a 00                	push   $0x0
c010dc23:	6a 05                	push   $0x5
c010dc25:	8d 83 00 00 00 40    	lea    0x40000000(%ebx),%eax
c010dc2b:	50                   	push   %eax
c010dc2c:	53                   	push   %ebx
c010dc2d:	68 00 00 c0 ff       	push   $0xffc00000
c010dc32:	e8 09 c8 ff ff       	call   c010a440 <vmm_set_mapping>
    for (uintptr_t i = &__usrtext_start; i < &__usrtext_end; i += PG_SIZE) {
c010dc37:	81 c3 00 10 00 00    	add    $0x1000,%ebx
c010dc3d:	83 c4 20             	add    $0x20,%esp
c010dc40:	81 fb 00 00 11 c0    	cmp    $0xc0110000,%ebx
c010dc46:	72 d6                	jb     c010dc1e <setup_memory+0xd6>
    }
}
c010dc48:	8d 65 f4             	lea    -0xc(%ebp),%esp
c010dc4b:	5b                   	pop    %ebx
c010dc4c:	5e                   	pop    %esi
c010dc4d:	5f                   	pop    %edi
c010dc4e:	5d                   	pop    %ebp
c010dc4f:	c3                   	ret    

c010dc50 <_kernel_pre_init>:
{
c010dc50:	55                   	push   %ebp
c010dc51:	89 e5                	mov    %esp,%ebp
c010dc53:	57                   	push   %edi
c010dc54:	83 ec 04             	sub    $0x4,%esp
    _init_idt();
c010dc57:	e8 b1 ec ff ff       	call   c010c90d <_init_idt>
    intr_routine_init();
c010dc5c:	e8 1f eb ff ff       	call   c010c780 <intr_routine_init>
    pmm_init(MEM_1MB + (_k_init_mb_info->mem_upper << 10));
c010dc61:	a1 d0 18 d1 c0       	mov    0xc0d118d0,%eax
c010dc66:	8b 40 08             	mov    0x8(%eax),%eax
c010dc69:	c1 e0 0a             	shl    $0xa,%eax
c010dc6c:	05 00 00 10 00       	add    $0x100000,%eax
c010dc71:	83 ec 0c             	sub    $0xc,%esp
c010dc74:	50                   	push   %eax
c010dc75:	e8 91 cd ff ff       	call   c010aa0b <pmm_init>
    vmm_init();
c010dc7a:	e8 82 c7 ff ff       	call   c010a401 <vmm_init>
    rtc_init();
c010dc7f:	e8 ea 06 00 00       	call   c010e36e <rtc_init>
      _k_init_mb_info->mmap_length / sizeof(multiboot_memory_map_t);
c010dc84:	8b 0d d0 18 d1 c0    	mov    0xc0d118d0,%ecx
    unsigned int map_size =
c010dc8a:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
c010dc8f:	89 d0                	mov    %edx,%eax
c010dc91:	f7 61 2c             	mull   0x2c(%ecx)
c010dc94:	c1 ea 04             	shr    $0x4,%edx
    setup_memory((multiboot_memory_map_t*)_k_init_mb_info->mmap_addr, map_size);
c010dc97:	8b 41 30             	mov    0x30(%ecx),%eax
c010dc9a:	83 c4 08             	add    $0x8,%esp
c010dc9d:	52                   	push   %edx
c010dc9e:	50                   	push   %eax
c010dc9f:	e8 a4 fe ff ff       	call   c010db48 <setup_memory>
    tty_init((void*)VGA_BUFFER_VADDR);
c010dca4:	c7 04 24 00 00 80 d0 	movl   $0xd0800000,(%esp)
c010dcab:	e8 7b cf ff ff       	call   c010ac2b <tty_init>
    tty_set_theme(VGA_COLOR_WHITE, VGA_COLOR_BLACK);
c010dcb0:	83 c4 08             	add    $0x8,%esp
c010dcb3:	6a 00                	push   $0x0
c010dcb5:	6a 0f                	push   $0xf
c010dcb7:	e8 be cf ff ff       	call   c010ac7a <tty_set_theme>
    asm volatile("movl %%cr3,%0" : "=r"(val));
c010dcbc:	0f 20 da             	mov    %cr3,%edx
    __kernel_ptd = cpu_rcr3();
c010dcbf:	89 15 cc 18 d1 c0    	mov    %edx,0xc0d118cc
    tmp = (struct proc_info){ .page_table = __kernel_ptd };
c010dcc5:	bf c0 17 d1 c0       	mov    $0xc0d117c0,%edi
c010dcca:	b9 43 00 00 00       	mov    $0x43,%ecx
c010dccf:	b8 00 00 00 00       	mov    $0x0,%eax
c010dcd4:	f3 ab                	rep stos %eax,%es:(%edi)
c010dcd6:	89 15 18 18 d1 c0    	mov    %edx,0xc0d11818
    __current = &tmp;
c010dcdc:	c7 05 8c 05 d1 c0 c0 	movl   $0xc0d117c0,0xc0d1058c
c010dce3:	17 d1 c0 
}
c010dce6:	83 c4 10             	add    $0x10,%esp
c010dce9:	8b 7d fc             	mov    -0x4(%ebp),%edi
c010dcec:	c9                   	leave  
c010dced:	c3                   	ret    

c010dcee <fork>:
__LXSYSCALL(pid_t, fork)
c010dcee:	b8 01 00 00 00       	mov    $0x1,%eax
c010dcf3:	cd 21                	int    $0x21
c010dcf5:	c3                   	ret    

c010dcf6 <yield>:
__LXSYSCALL(void, yield);
c010dcf6:	b8 02 00 00 00       	mov    $0x2,%eax
c010dcfb:	cd 21                	int    $0x21
c010dcfd:	c3                   	ret    

c010dcfe <__do_reserved_memory>:
    __do_reserved_memory(1);
}

void
__do_reserved_memory(int unlock)
{
c010dcfe:	55                   	push   %ebp
c010dcff:	89 e5                	mov    %esp,%ebp
c010dd01:	57                   	push   %edi
c010dd02:	56                   	push   %esi
c010dd03:	53                   	push   %ebx
c010dd04:	83 ec 3c             	sub    $0x3c,%esp
    multiboot_memory_map_t* mmaps = _k_init_mb_info->mmap_addr;
c010dd07:	a1 d0 18 d1 c0       	mov    0xc0d118d0,%eax
c010dd0c:	8b 48 30             	mov    0x30(%eax),%ecx
c010dd0f:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    size_t map_size =
      _k_init_mb_info->mmap_length / sizeof(multiboot_memory_map_t);
c010dd12:	8b 50 2c             	mov    0x2c(%eax),%edx
    size_t map_size =
c010dd15:	b9 ab aa aa aa       	mov    $0xaaaaaaab,%ecx
c010dd1a:	89 d0                	mov    %edx,%eax
c010dd1c:	f7 e1                	mul    %ecx
c010dd1e:	c1 ea 04             	shr    $0x4,%edx
c010dd21:	89 55 bc             	mov    %edx,-0x44(%ebp)
    // v_mapping mapping;
    for (unsigned int i = 0; i < map_size; i++) {
c010dd24:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
c010dd2b:	eb 3d                	jmp    c010dd6a <__do_reserved_memory+0x6c>
        if (mmap.type == MULTIBOOT_MEMORY_AVAILABLE || pa <= MEM_4MB) {
            // Don't fuck up our kernel code or any free area!
            continue;
        }
        size_t pg_num = CEIL(mmap.len_low, PG_SIZE_BITS);
        size_t j = 0;
c010dd2d:	bb 00 00 00 00       	mov    $0x0,%ebx
        if (!unlock) {
            for (; j < pg_num; j++) {
c010dd32:	39 fb                	cmp    %edi,%ebx
c010dd34:	73 2a                	jae    c010dd60 <__do_reserved_memory+0x62>
                uintptr_t _pa = pa + (j << PG_SIZE_BITS);
c010dd36:	89 d8                	mov    %ebx,%eax
c010dd38:	c1 e0 0c             	shl    $0xc,%eax
c010dd3b:	03 45 c4             	add    -0x3c(%ebp),%eax
                if (_pa >= KERNEL_MM_BASE) {
c010dd3e:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c010dd43:	77 1b                	ja     c010dd60 <__do_reserved_memory+0x62>
                    // Don't fuck up our kernel space!
                    break;
                }
                vmm_set_mapping(PD_REFERENCED, _pa, _pa, PG_PREM_R, VMAP_NULL);
c010dd45:	83 ec 0c             	sub    $0xc,%esp
c010dd48:	6a 00                	push   $0x0
c010dd4a:	6a 01                	push   $0x1
c010dd4c:	50                   	push   %eax
c010dd4d:	50                   	push   %eax
c010dd4e:	68 00 00 c0 ff       	push   $0xffc00000
c010dd53:	e8 e8 c6 ff ff       	call   c010a440 <vmm_set_mapping>
            for (; j < pg_num; j++) {
c010dd58:	83 c3 01             	add    $0x1,%ebx
c010dd5b:	83 c4 20             	add    $0x20,%esp
c010dd5e:	eb d2                	jmp    c010dd32 <__do_reserved_memory+0x34>
            }
            // Save the progress for later unmapping.
            mmaps[i].len_low = j * PG_SIZE;
c010dd60:	c1 e3 0c             	shl    $0xc,%ebx
c010dd63:	89 5e 0c             	mov    %ebx,0xc(%esi)
    for (unsigned int i = 0; i < map_size; i++) {
c010dd66:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
c010dd6a:	8b 4d bc             	mov    -0x44(%ebp),%ecx
c010dd6d:	39 4d c0             	cmp    %ecx,-0x40(%ebp)
c010dd70:	0f 83 8c 00 00 00    	jae    c010de02 <__do_reserved_memory+0x104>
        multiboot_memory_map_t mmap = mmaps[i];
c010dd76:	8b 45 c0             	mov    -0x40(%ebp),%eax
c010dd79:	8d 04 40             	lea    (%eax,%eax,2),%eax
c010dd7c:	8d 34 c5 00 00 00 00 	lea    0x0(,%eax,8),%esi
c010dd83:	03 75 b8             	add    -0x48(%ebp),%esi
c010dd86:	8b 06                	mov    (%esi),%eax
c010dd88:	89 45 d0             	mov    %eax,-0x30(%ebp)
c010dd8b:	8b 56 04             	mov    0x4(%esi),%edx
c010dd8e:	89 55 d4             	mov    %edx,-0x2c(%ebp)
c010dd91:	8b 46 08             	mov    0x8(%esi),%eax
c010dd94:	89 45 d8             	mov    %eax,-0x28(%ebp)
c010dd97:	8b 46 0c             	mov    0xc(%esi),%eax
c010dd9a:	89 45 dc             	mov    %eax,-0x24(%ebp)
c010dd9d:	8b 46 10             	mov    0x10(%esi),%eax
c010dda0:	89 45 e0             	mov    %eax,-0x20(%ebp)
c010dda3:	8b 46 14             	mov    0x14(%esi),%eax
c010dda6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        uint8_t* pa = PG_ALIGN(mmap.addr_low);
c010dda9:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
c010ddaf:	89 55 c4             	mov    %edx,-0x3c(%ebp)
        if (mmap.type == MULTIBOOT_MEMORY_AVAILABLE || pa <= MEM_4MB) {
c010ddb2:	83 f8 01             	cmp    $0x1,%eax
c010ddb5:	74 af                	je     c010dd66 <__do_reserved_memory+0x68>
c010ddb7:	81 fa 00 00 40 00    	cmp    $0x400000,%edx
c010ddbd:	76 a7                	jbe    c010dd66 <__do_reserved_memory+0x68>
        size_t pg_num = CEIL(mmap.len_low, PG_SIZE_BITS);
c010ddbf:	8b 4d dc             	mov    -0x24(%ebp),%ecx
c010ddc2:	8d b9 ff 0f 00 00    	lea    0xfff(%ecx),%edi
c010ddc8:	c1 ef 0c             	shr    $0xc,%edi
        if (!unlock) {
c010ddcb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c010ddcf:	0f 84 58 ff ff ff    	je     c010dd2d <__do_reserved_memory+0x2f>
        size_t j = 0;
c010ddd5:	bb 00 00 00 00       	mov    $0x0,%ebx
c010ddda:	89 d6                	mov    %edx,%esi
c010dddc:	eb 1b                	jmp    c010ddf9 <__do_reserved_memory+0xfb>
        } else {
            for (; j < pg_num; j++) {
                uintptr_t _pa = pa + (j << PG_SIZE_BITS);
c010ddde:	89 d8                	mov    %ebx,%eax
c010dde0:	c1 e0 0c             	shl    $0xc,%eax
c010dde3:	01 f0                	add    %esi,%eax
                vmm_del_mapping(PD_REFERENCED, _pa);
c010dde5:	83 ec 08             	sub    $0x8,%esp
c010dde8:	50                   	push   %eax
c010dde9:	68 00 00 c0 ff       	push   $0xffc00000
c010ddee:	e8 5b c7 ff ff       	call   c010a54e <vmm_del_mapping>
            for (; j < pg_num; j++) {
c010ddf3:	83 c3 01             	add    $0x1,%ebx
c010ddf6:	83 c4 10             	add    $0x10,%esp
c010ddf9:	39 fb                	cmp    %edi,%ebx
c010ddfb:	72 e1                	jb     c010ddde <__do_reserved_memory+0xe0>
c010ddfd:	e9 64 ff ff ff       	jmp    c010dd66 <__do_reserved_memory+0x68>
            }
        }
    }
c010de02:	8d 65 f4             	lea    -0xc(%ebp),%esp
c010de05:	5b                   	pop    %ebx
c010de06:	5e                   	pop    %esi
c010de07:	5f                   	pop    %edi
c010de08:	5d                   	pop    %ebp
c010de09:	c3                   	ret    

c010de0a <lock_reserved_memory>:
{
c010de0a:	55                   	push   %ebp
c010de0b:	89 e5                	mov    %esp,%ebp
c010de0d:	83 ec 14             	sub    $0x14,%esp
    __do_reserved_memory(0);
c010de10:	6a 00                	push   $0x0
c010de12:	e8 e7 fe ff ff       	call   c010dcfe <__do_reserved_memory>
}
c010de17:	83 c4 10             	add    $0x10,%esp
c010de1a:	c9                   	leave  
c010de1b:	c3                   	ret    

c010de1c <unlock_reserved_memory>:
{
c010de1c:	55                   	push   %ebp
c010de1d:	89 e5                	mov    %esp,%ebp
c010de1f:	83 ec 14             	sub    $0x14,%esp
    __do_reserved_memory(1);
c010de22:	6a 01                	push   $0x1
c010de24:	e8 d5 fe ff ff       	call   c010dcfe <__do_reserved_memory>
}
c010de29:	83 c4 10             	add    $0x10,%esp
c010de2c:	c9                   	leave  
c010de2d:	c3                   	ret    

c010de2e <init_platform>:
{
c010de2e:	55                   	push   %ebp
c010de2f:	89 e5                	mov    %esp,%ebp
c010de31:	53                   	push   %ebx
c010de32:	83 ec 04             	sub    $0x4,%esp
    assert_msg(kalloc_init(), "Fail to initialize heap");
c010de35:	e8 95 c3 ff ff       	call   c010a1cf <kalloc_init>
c010de3a:	85 c0                	test   %eax,%eax
c010de3c:	0f 84 b2 00 00 00    	je     c010def4 <init_platform+0xc6>
    lock_reserved_memory();
c010de42:	e8 c3 ff ff ff       	call   c010de0a <lock_reserved_memory>
    acpi_init(_k_init_mb_info);
c010de47:	83 ec 0c             	sub    $0xc,%esp
c010de4a:	ff 35 d0 18 d1 c0    	push   0xc0d118d0
c010de50:	e8 9f 01 00 00       	call   c010dff4 <acpi_init>
    uintptr_t ioapic_addr = acpi_get_context()->madt.ioapic->ioapic_addr;
c010de55:	e8 33 01 00 00       	call   c010df8d <acpi_get_context>
c010de5a:	8b 40 0f             	mov    0xf(%eax),%eax
c010de5d:	8b 58 04             	mov    0x4(%eax),%ebx
    pmm_mark_page_occupied(
c010de60:	83 c4 0c             	add    $0xc,%esp
c010de63:	6a 00                	push   $0x0
c010de65:	68 00 ee 0f 00       	push   $0xfee00
c010de6a:	6a ff                	push   $0xffffffff
c010de6c:	e8 de ca ff ff       	call   c010a94f <pmm_mark_page_occupied>
    pmm_mark_page_occupied(KERNEL_PID, FLOOR(ioapic_addr, PG_SIZE_BITS), 0);
c010de71:	83 c4 0c             	add    $0xc,%esp
c010de74:	6a 00                	push   $0x0
c010de76:	89 d8                	mov    %ebx,%eax
c010de78:	c1 e8 0c             	shr    $0xc,%eax
c010de7b:	50                   	push   %eax
c010de7c:	6a ff                	push   $0xffffffff
c010de7e:	e8 cc ca ff ff       	call   c010a94f <pmm_mark_page_occupied>
    vmm_set_mapping(
c010de83:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c010de8a:	6a 03                	push   $0x3
c010de8c:	68 00 00 e0 fe       	push   $0xfee00000
c010de91:	68 00 00 c0 d0       	push   $0xd0c00000
c010de96:	68 00 00 c0 ff       	push   $0xffc00000
c010de9b:	e8 a0 c5 ff ff       	call   c010a440 <vmm_set_mapping>
    vmm_set_mapping(
c010dea0:	83 c4 14             	add    $0x14,%esp
c010dea3:	6a 00                	push   $0x0
c010dea5:	6a 03                	push   $0x3
c010dea7:	53                   	push   %ebx
c010dea8:	68 00 10 c0 d0       	push   $0xd0c01000
c010dead:	68 00 00 c0 ff       	push   $0xffc00000
c010deb2:	e8 89 c5 ff ff       	call   c010a440 <vmm_set_mapping>
    apic_init();
c010deb7:	83 c4 20             	add    $0x20,%esp
c010deba:	e8 1b 05 00 00       	call   c010e3da <apic_init>
    ioapic_init();
c010debf:	e8 dc 03 00 00       	call   c010e2a0 <ioapic_init>
    timer_init(SYS_TIMER_FREQUENCY_HZ);
c010dec4:	83 ec 0c             	sub    $0xc,%esp
c010dec7:	68 00 08 00 00       	push   $0x800
c010decc:	e8 82 de ff ff       	call   c010bd53 <timer_init>
    clock_init();
c010ded1:	e8 55 db ff ff       	call   c010ba2b <clock_init>
    ps2_kbd_init();
c010ded6:	e8 d4 f0 ff ff       	call   c010cfaf <ps2_kbd_init>
    syscall_install();
c010dedb:	e8 a7 eb ff ff       	call   c010ca87 <syscall_install>
    console_start_flushing();
c010dee0:	e8 ae ee ff ff       	call   c010cd93 <console_start_flushing>
    unlock_reserved_memory();
c010dee5:	e8 32 ff ff ff       	call   c010de1c <unlock_reserved_memory>
    for (size_t i = 0; i < (uintptr_t)(&__init_hhk_end); i += PG_SIZE) {
c010deea:	83 c4 10             	add    $0x10,%esp
c010deed:	bb 00 00 00 00       	mov    $0x0,%ebx
c010def2:	eb 36                	jmp    c010df2a <init_platform+0xfc>
    assert_msg(kalloc_init(), "Fail to initialize heap");
c010def4:	83 ec 04             	sub    $0x4,%esp
c010def7:	6a 5c                	push   $0x5c
c010def9:	68 ab 34 d1 c0       	push   $0xc0d134ab
c010defe:	68 ba 34 d1 c0       	push   $0xc0d134ba
c010df03:	e8 5b d0 ff ff       	call   c010af63 <__assert_fail>
        vmm_del_mapping(PD_REFERENCED, (void*)i);
c010df08:	83 ec 08             	sub    $0x8,%esp
c010df0b:	53                   	push   %ebx
c010df0c:	68 00 00 c0 ff       	push   $0xffc00000
c010df11:	e8 38 c6 ff ff       	call   c010a54e <vmm_del_mapping>
        pmm_free_page(KERNEL_PID, (void*)i);
c010df16:	83 c4 08             	add    $0x8,%esp
c010df19:	53                   	push   %ebx
c010df1a:	6a ff                	push   $0xffffffff
c010df1c:	e8 3f cc ff ff       	call   c010ab60 <pmm_free_page>
    for (size_t i = 0; i < (uintptr_t)(&__init_hhk_end); i += PG_SIZE) {
c010df21:	81 c3 00 10 00 00    	add    $0x1000,%ebx
c010df27:	83 c4 10             	add    $0x10,%esp
c010df2a:	81 fb 00 a0 10 00    	cmp    $0x10a000,%ebx
c010df30:	72 d6                	jb     c010df08 <init_platform+0xda>
}
c010df32:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c010df35:	c9                   	leave  
c010df36:	c3                   	ret    

c010df37 <__proc0>:
{
c010df37:	55                   	push   %ebp
c010df38:	89 e5                	mov    %esp,%ebp
c010df3a:	83 ec 08             	sub    $0x8,%esp
    init_platform();
c010df3d:	e8 ec fe ff ff       	call   c010de2e <init_platform>
    init_proc_user_space(__current);
c010df42:	83 ec 0c             	sub    $0xc,%esp
c010df45:	ff 35 8c 05 d1 c0    	push   0xc0d1058c
c010df4b:	e8 39 f8 ff ff       	call   c010d789 <init_proc_user_space>
    asm volatile("movw %0, %%ax\n"
c010df50:	ba c5 f3 10 c0       	mov    $0xc010f3c5,%edx
c010df55:	66 b8 23 00          	mov    $0x23,%ax
c010df59:	8e c0                	mov    %eax,%es
c010df5b:	8e d8                	mov    %eax,%ds
c010df5d:	8e e0                	mov    %eax,%fs
c010df5f:	8e e8                	mov    %eax,%gs
c010df61:	6a 23                	push   $0x23
c010df63:	68 f0 ff ff 9f       	push   $0x9ffffff0
c010df68:	6a 1b                	push   $0x1b
c010df6a:	52                   	push   %edx
c010df6b:	cb                   	lret   
}
c010df6c:	83 c4 10             	add    $0x10,%esp
c010df6f:	c9                   	leave  
c010df70:	c3                   	ret    

c010df71 <kprintf>:

#include "parser/madt_parser.h"

static acpi_context* ctx = NULL;

LOG_MODULE("ACPI")
c010df71:	55                   	push   %ebp
c010df72:	89 e5                	mov    %esp,%ebp
c010df74:	83 ec 0c             	sub    $0xc,%esp
c010df77:	8d 45 0c             	lea    0xc(%ebp),%eax
c010df7a:	50                   	push   %eax
c010df7b:	ff 75 08             	push   0x8(%ebp)
c010df7e:	68 db 34 d1 c0       	push   $0xc0d134db
c010df83:	e8 ef df ff ff       	call   c010bf77 <__kprintf>
c010df88:	83 c4 10             	add    $0x10,%esp
c010df8b:	c9                   	leave  
c010df8c:	c3                   	ret    

c010df8d <acpi_get_context>:
}

acpi_context*
acpi_get_context()
{
    assert_msg(ctx, "ACPI is not initialized");
c010df8d:	a1 d4 18 d1 c0       	mov    0xc0d118d4,%eax
c010df92:	85 c0                	test   %eax,%eax
c010df94:	74 01                	je     c010df97 <acpi_get_context+0xa>
    return ctx;
}
c010df96:	c3                   	ret    
{
c010df97:	55                   	push   %ebp
c010df98:	89 e5                	mov    %esp,%ebp
c010df9a:	83 ec 0c             	sub    $0xc,%esp
    assert_msg(ctx, "ACPI is not initialized");
c010df9d:	6a 47                	push   $0x47
c010df9f:	68 e0 34 d1 c0       	push   $0xc0d134e0
c010dfa4:	68 f0 34 d1 c0       	push   $0xc0d134f0
c010dfa9:	e8 b5 cf ff ff       	call   c010af63 <__assert_fail>

c010dfae <acpi_rsdp_validate>:

int
acpi_rsdp_validate(acpi_rsdp_t* rsdp)
{
c010dfae:	55                   	push   %ebp
c010dfaf:	89 e5                	mov    %esp,%ebp
c010dfb1:	8b 4d 08             	mov    0x8(%ebp),%ecx
    uint8_t sum = 0;
    uint8_t* rsdp_ptr = (uint8_t*)rsdp;
    for (size_t i = 0; i < 20; i++) {
c010dfb4:	b8 00 00 00 00       	mov    $0x0,%eax
    uint8_t sum = 0;
c010dfb9:	ba 00 00 00 00       	mov    $0x0,%edx
    for (size_t i = 0; i < 20; i++) {
c010dfbe:	eb 06                	jmp    c010dfc6 <acpi_rsdp_validate+0x18>
        sum += *(rsdp_ptr + i);
c010dfc0:	02 14 01             	add    (%ecx,%eax,1),%dl
    for (size_t i = 0; i < 20; i++) {
c010dfc3:	83 c0 01             	add    $0x1,%eax
c010dfc6:	83 f8 13             	cmp    $0x13,%eax
c010dfc9:	76 f5                	jbe    c010dfc0 <acpi_rsdp_validate+0x12>
    }

    return sum == 0;
c010dfcb:	84 d2                	test   %dl,%dl
c010dfcd:	0f 94 c0             	sete   %al
c010dfd0:	0f b6 c0             	movzbl %al,%eax
}
c010dfd3:	5d                   	pop    %ebp
c010dfd4:	c3                   	ret    

c010dfd5 <acpi_locate_rsdp>:
            }
        }
    }
#else
    // You know what, I just search the entire 1MiB for Celestia's sake.
    uint8_t* mem_start = 0x4000;
c010dfd5:	b8 00 40 00 00       	mov    $0x4000,%eax
    for (; mem_start < 0x100000; mem_start += 16) {
c010dfda:	3d ff ff 0f 00       	cmp    $0xfffff,%eax
c010dfdf:	77 0d                	ja     c010dfee <acpi_locate_rsdp+0x19>
        uint32_t sig_low = *((uint32_t*)(mem_start));
        // XXX: do we need to compare this as well?
        // uint32_t sig_high = *((uint32_t*)(mem_start+j) + 1);
        if (sig_low == ACPI_RSDP_SIG_L) {
c010dfe1:	81 38 52 53 44 20    	cmpl   $0x20445352,(%eax)
c010dfe7:	74 0a                	je     c010dff3 <acpi_locate_rsdp+0x1e>
    for (; mem_start < 0x100000; mem_start += 16) {
c010dfe9:	83 c0 10             	add    $0x10,%eax
c010dfec:	eb ec                	jmp    c010dfda <acpi_locate_rsdp+0x5>
    acpi_rsdp_t* rsdp = NULL;
c010dfee:	b8 00 00 00 00       	mov    $0x0,%eax
        }
    }
#endif

    return rsdp;
c010dff3:	c3                   	ret    

c010dff4 <acpi_init>:
{
c010dff4:	55                   	push   %ebp
c010dff5:	89 e5                	mov    %esp,%ebp
c010dff7:	57                   	push   %edi
c010dff8:	56                   	push   %esi
c010dff9:	53                   	push   %ebx
c010dffa:	83 ec 28             	sub    $0x28,%esp
    acpi_rsdp_t* rsdp = acpi_locate_rsdp(mb_info);
c010dffd:	ff 75 08             	push   0x8(%ebp)
c010e000:	e8 d0 ff ff ff       	call   c010dfd5 <acpi_locate_rsdp>
c010e005:	83 c4 10             	add    $0x10,%esp
    assert_msg(rsdp, "Fail to locate ACPI_RSDP");
c010e008:	85 c0                	test   %eax,%eax
c010e00a:	74 78                	je     c010e084 <acpi_init+0x90>
c010e00c:	89 c3                	mov    %eax,%ebx
    assert_msg(acpi_rsdp_validate(rsdp), "Invalid ACPI_RSDP (checksum failed)");
c010e00e:	83 ec 0c             	sub    $0xc,%esp
c010e011:	50                   	push   %eax
c010e012:	e8 97 ff ff ff       	call   c010dfae <acpi_rsdp_validate>
c010e017:	83 c4 10             	add    $0x10,%esp
c010e01a:	85 c0                	test   %eax,%eax
c010e01c:	74 7a                	je     c010e098 <acpi_init+0xa4>
    kprintf(KINFO "RSDP found at %p, RSDT: %p\n", rsdp, rsdp->rsdt);
c010e01e:	83 ec 04             	sub    $0x4,%esp
c010e021:	ff 73 10             	push   0x10(%ebx)
c010e024:	53                   	push   %ebx
c010e025:	68 21 35 d1 c0       	push   $0xc0d13521
c010e02a:	e8 42 ff ff ff       	call   c010df71 <kprintf>
    acpi_rsdt_t* rsdt = rsdp->rsdt;
c010e02f:	8b 43 10             	mov    0x10(%ebx),%eax
c010e032:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    ctx = lxcalloc(1, sizeof(acpi_context));
c010e035:	83 c4 08             	add    $0x8,%esp
c010e038:	68 86 00 00 00       	push   $0x86
c010e03d:	6a 01                	push   $0x1
c010e03f:	e8 ed c2 ff ff       	call   c010a331 <lxcalloc>
c010e044:	a3 d4 18 d1 c0       	mov    %eax,0xc0d118d4
    assert_msg(ctx, "Fail to create ACPI context");
c010e049:	83 c4 10             	add    $0x10,%esp
c010e04c:	85 c0                	test   %eax,%eax
c010e04e:	74 5c                	je     c010e0ac <acpi_init+0xb8>
    strncpy(ctx->oem_id, rsdt->header.oem_id, 6);
c010e050:	8b 7d e4             	mov    -0x1c(%ebp),%edi
c010e053:	8d 57 0a             	lea    0xa(%edi),%edx
c010e056:	83 ec 04             	sub    $0x4,%esp
c010e059:	6a 06                	push   $0x6
c010e05b:	52                   	push   %edx
c010e05c:	50                   	push   %eax
c010e05d:	e8 8c 0b 00 00       	call   c010ebee <strncpy>
    ctx->oem_id[6] = '\0';
c010e062:	a1 d4 18 d1 c0       	mov    0xc0d118d4,%eax
c010e067:	c6 40 06 00          	movb   $0x0,0x6(%eax)
    size_t entry_n = (rsdt->header.length - sizeof(acpi_sdthdr_t)) >> 2;
c010e06b:	8b 47 04             	mov    0x4(%edi),%eax
c010e06e:	89 45 e0             	mov    %eax,-0x20(%ebp)
c010e071:	83 e8 24             	sub    $0x24,%eax
c010e074:	c1 e8 02             	shr    $0x2,%eax
c010e077:	89 45 e0             	mov    %eax,-0x20(%ebp)
    for (size_t i = 0; i < entry_n; i++) {
c010e07a:	83 c4 10             	add    $0x10,%esp
c010e07d:	bb 00 00 00 00       	mov    $0x0,%ebx
c010e082:	eb 51                	jmp    c010e0d5 <acpi_init+0xe1>
    assert_msg(rsdp, "Fail to locate ACPI_RSDP");
c010e084:	83 ec 04             	sub    $0x4,%esp
c010e087:	6a 1a                	push   $0x1a
c010e089:	68 e0 34 d1 c0       	push   $0xc0d134e0
c010e08e:	68 08 35 d1 c0       	push   $0xc0d13508
c010e093:	e8 cb ce ff ff       	call   c010af63 <__assert_fail>
    assert_msg(acpi_rsdp_validate(rsdp), "Invalid ACPI_RSDP (checksum failed)");
c010e098:	83 ec 04             	sub    $0x4,%esp
c010e09b:	6a 1b                	push   $0x1b
c010e09d:	68 e0 34 d1 c0       	push   $0xc0d134e0
c010e0a2:	68 44 39 d1 c0       	push   $0xc0d13944
c010e0a7:	e8 b7 ce ff ff       	call   c010af63 <__assert_fail>
    assert_msg(ctx, "Fail to create ACPI context");
c010e0ac:	83 ec 04             	sub    $0x4,%esp
c010e0af:	6a 22                	push   $0x22
c010e0b1:	68 e0 34 d1 c0       	push   $0xc0d134e0
c010e0b6:	68 3f 35 d1 c0       	push   $0xc0d1353f
c010e0bb:	e8 a3 ce ff ff       	call   c010af63 <__assert_fail>
                madt_parse((acpi_madt_t*)sdthdr, ctx);
c010e0c0:	83 ec 08             	sub    $0x8,%esp
c010e0c3:	ff 35 d4 18 d1 c0    	push   0xc0d118d4
c010e0c9:	56                   	push   %esi
c010e0ca:	e8 da 00 00 00       	call   c010e1a9 <madt_parse>
                break;
c010e0cf:	83 c4 10             	add    $0x10,%esp
    for (size_t i = 0; i < entry_n; i++) {
c010e0d2:	83 c3 01             	add    $0x1,%ebx
c010e0d5:	3b 5d e0             	cmp    -0x20(%ebp),%ebx
c010e0d8:	73 42                	jae    c010e11c <acpi_init+0x128>
        acpi_sdthdr_t* sdthdr = ((acpi_apic_t**)&(rsdt->entry))[i];
c010e0da:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010e0dd:	8b 74 98 24          	mov    0x24(%eax,%ebx,4),%esi
        switch (sdthdr->signature) {
c010e0e1:	8b 06                	mov    (%esi),%eax
c010e0e3:	3d 41 50 49 43       	cmp    $0x43495041,%eax
c010e0e8:	74 d6                	je     c010e0c0 <acpi_init+0xcc>
c010e0ea:	3d 46 41 43 50       	cmp    $0x50434146,%eax
c010e0ef:	75 e1                	jne    c010e0d2 <acpi_init+0xde>
                ctx->fadt = *(acpi_fadt_t*)sdthdr;
c010e0f1:	8b 3d d4 18 d1 c0    	mov    0xc0d118d4,%edi
c010e0f7:	8d 4f 17             	lea    0x17(%edi),%ecx
c010e0fa:	8b 06                	mov    (%esi),%eax
c010e0fc:	89 47 17             	mov    %eax,0x17(%edi)
c010e0ff:	8b 46 6b             	mov    0x6b(%esi),%eax
c010e102:	89 87 82 00 00 00    	mov    %eax,0x82(%edi)
c010e108:	83 c7 1b             	add    $0x1b,%edi
c010e10b:	83 e7 fc             	and    $0xfffffffc,%edi
c010e10e:	29 f9                	sub    %edi,%ecx
c010e110:	29 ce                	sub    %ecx,%esi
c010e112:	83 c1 6f             	add    $0x6f,%ecx
c010e115:	c1 e9 02             	shr    $0x2,%ecx
c010e118:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
                break;
c010e11a:	eb b6                	jmp    c010e0d2 <acpi_init+0xde>
    kprintf(KINFO "OEM: %s\n", ctx->oem_id);
c010e11c:	83 ec 08             	sub    $0x8,%esp
c010e11f:	ff 35 d4 18 d1 c0    	push   0xc0d118d4
c010e125:	68 5b 35 d1 c0       	push   $0xc0d1355b
c010e12a:	e8 42 fe ff ff       	call   c010df71 <kprintf>
    kprintf(KINFO "IOAPIC address: %p\n", ctx->madt.ioapic->ioapic_addr);
c010e12f:	a1 d4 18 d1 c0       	mov    0xc0d118d4,%eax
c010e134:	8b 40 0f             	mov    0xf(%eax),%eax
c010e137:	83 c4 08             	add    $0x8,%esp
c010e13a:	ff 70 04             	push   0x4(%eax)
c010e13d:	68 66 35 d1 c0       	push   $0xc0d13566
c010e142:	e8 2a fe ff ff       	call   c010df71 <kprintf>
    kprintf(KINFO "APIC address: %p\n", ctx->madt.apic_addr);
c010e147:	83 c4 08             	add    $0x8,%esp
c010e14a:	a1 d4 18 d1 c0       	mov    0xc0d118d4,%eax
c010e14f:	ff 70 07             	push   0x7(%eax)
c010e152:	68 7c 35 d1 c0       	push   $0xc0d1357c
c010e157:	e8 15 fe ff ff       	call   c010df71 <kprintf>
    for (size_t i = 0; i < 24; i++) {
c010e15c:	83 c4 10             	add    $0x10,%esp
c010e15f:	bb 00 00 00 00       	mov    $0x0,%ebx
c010e164:	eb 03                	jmp    c010e169 <acpi_init+0x175>
c010e166:	83 c3 01             	add    $0x1,%ebx
c010e169:	83 fb 17             	cmp    $0x17,%ebx
c010e16c:	77 33                	ja     c010e1a1 <acpi_init+0x1ad>
        acpi_intso_t* intso = ctx->madt.irq_exception[i];
c010e16e:	8d 04 9d 00 00 00 00 	lea    0x0(,%ebx,4),%eax
c010e175:	8b 15 d4 18 d1 c0    	mov    0xc0d118d4,%edx
c010e17b:	03 42 13             	add    0x13(%edx),%eax
c010e17e:	8b 00                	mov    (%eax),%eax
        if (!intso)
c010e180:	85 c0                	test   %eax,%eax
c010e182:	74 e2                	je     c010e166 <acpi_init+0x172>
        kprintf(KINFO "IRQ #%u -> GSI #%u\n", intso->source, intso->gsi);
c010e184:	0f b6 50 03          	movzbl 0x3(%eax),%edx
c010e188:	83 ec 04             	sub    $0x4,%esp
c010e18b:	ff 70 04             	push   0x4(%eax)
c010e18e:	0f b6 c2             	movzbl %dl,%eax
c010e191:	50                   	push   %eax
c010e192:	68 90 35 d1 c0       	push   $0xc0d13590
c010e197:	e8 d5 fd ff ff       	call   c010df71 <kprintf>
c010e19c:	83 c4 10             	add    $0x10,%esp
c010e19f:	eb c5                	jmp    c010e166 <acpi_init+0x172>
}
c010e1a1:	8d 65 f4             	lea    -0xc(%ebp),%esp
c010e1a4:	5b                   	pop    %ebx
c010e1a5:	5e                   	pop    %esi
c010e1a6:	5f                   	pop    %edi
c010e1a7:	5d                   	pop    %ebp
c010e1a8:	c3                   	ret    

c010e1a9 <madt_parse>:
#include "madt_parser.h"
#include <lunaix/mm/kalloc.h>

void
madt_parse(acpi_madt_t* madt, acpi_context* toc)
{
c010e1a9:	55                   	push   %ebp
c010e1aa:	89 e5                	mov    %esp,%ebp
c010e1ac:	57                   	push   %edi
c010e1ad:	56                   	push   %esi
c010e1ae:	53                   	push   %ebx
c010e1af:	83 ec 14             	sub    $0x14,%esp
c010e1b2:	8b 75 08             	mov    0x8(%ebp),%esi
c010e1b5:	8b 7d 0c             	mov    0xc(%ebp),%edi
    toc->madt.apic_addr = madt->apic_addr;
c010e1b8:	8b 46 24             	mov    0x24(%esi),%eax
c010e1bb:	89 47 07             	mov    %eax,0x7(%edi)

    // FUTURE: make madt.{apic,ioapic} as array or linked list.
    uint8_t* ics_start = (uint8_t*)((uintptr_t)madt + sizeof(acpi_madt_t));
c010e1be:	8d 5e 2c             	lea    0x2c(%esi),%ebx
    uintptr_t ics_end = (uintptr_t)madt + madt->header.length;
c010e1c1:	03 76 04             	add    0x4(%esi),%esi

    // Cosidering only one IOAPIC present (max 24 pins)
    // FIXME: use hash table instead
    toc->madt.irq_exception =
      (acpi_intso_t*)lxcalloc(24, sizeof(acpi_intso_t*));
c010e1c4:	6a 04                	push   $0x4
c010e1c6:	6a 18                	push   $0x18
c010e1c8:	e8 64 c1 ff ff       	call   c010a331 <lxcalloc>
    toc->madt.irq_exception =
c010e1cd:	89 47 13             	mov    %eax,0x13(%edi)

    size_t so_idx = 0;
    while (ics_start < ics_end) {
c010e1d0:	83 c4 10             	add    $0x10,%esp
c010e1d3:	eb 09                	jmp    c010e1de <madt_parse+0x35>
        switch (entry->type) {
            case ACPI_MADT_LAPIC:
                toc->madt.apic = (acpi_apic_t*)entry;
                break;
            case ACPI_MADT_IOAPIC:
                toc->madt.ioapic = (acpi_ioapic_t*)entry;
c010e1d5:	89 5f 0f             	mov    %ebx,0xf(%edi)
            }
            default:
                break;
        }

        ics_start += entry->length;
c010e1d8:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c010e1dc:	01 c3                	add    %eax,%ebx
    while (ics_start < ics_end) {
c010e1de:	39 f3                	cmp    %esi,%ebx
c010e1e0:	73 22                	jae    c010e204 <madt_parse+0x5b>
        switch (entry->type) {
c010e1e2:	0f b6 03             	movzbl (%ebx),%eax
c010e1e5:	3c 01                	cmp    $0x1,%al
c010e1e7:	74 ec                	je     c010e1d5 <madt_parse+0x2c>
c010e1e9:	3c 02                	cmp    $0x2,%al
c010e1eb:	74 09                	je     c010e1f6 <madt_parse+0x4d>
c010e1ed:	84 c0                	test   %al,%al
c010e1ef:	75 e7                	jne    c010e1d8 <madt_parse+0x2f>
                toc->madt.apic = (acpi_apic_t*)entry;
c010e1f1:	89 5f 0b             	mov    %ebx,0xb(%edi)
                break;
c010e1f4:	eb e2                	jmp    c010e1d8 <madt_parse+0x2f>
                toc->madt.irq_exception[intso_tbl->source] = intso_tbl;
c010e1f6:	0f b6 43 03          	movzbl 0x3(%ebx),%eax
c010e1fa:	c1 e0 02             	shl    $0x2,%eax
c010e1fd:	03 47 13             	add    0x13(%edi),%eax
c010e200:	89 18                	mov    %ebx,(%eax)
                break;
c010e202:	eb d4                	jmp    c010e1d8 <madt_parse+0x2f>
    }
c010e204:	8d 65 f4             	lea    -0xc(%ebp),%esp
c010e207:	5b                   	pop    %ebx
c010e208:	5e                   	pop    %esi
c010e209:	5f                   	pop    %edi
c010e20a:	5d                   	pop    %ebp
c010e20b:	c3                   	ret    

c010e20c <ioapic_get_irq>:
    ioapic_redirect(irq_rtc, RTC_TIMER_IV, 0, IOAPIC_DELMOD_FIXED);
}

uint8_t
ioapic_get_irq(acpi_context* acpi_ctx, uint8_t old_irq)
{
c010e20c:	55                   	push   %ebp
c010e20d:	89 e5                	mov    %esp,%ebp
c010e20f:	8b 45 0c             	mov    0xc(%ebp),%eax
c010e212:	89 c2                	mov    %eax,%edx
    if (old_irq >= 24) {
c010e214:	3c 17                	cmp    $0x17,%al
c010e216:	77 16                	ja     c010e22e <ioapic_get_irq+0x22>
        return old_irq;
    }
    acpi_intso_t* int_override = acpi_ctx->madt.irq_exception[old_irq];
c010e218:	0f b6 c0             	movzbl %al,%eax
c010e21b:	c1 e0 02             	shl    $0x2,%eax
c010e21e:	8b 4d 08             	mov    0x8(%ebp),%ecx
c010e221:	03 41 13             	add    0x13(%ecx),%eax
c010e224:	8b 00                	mov    (%eax),%eax
    return int_override ? (uint8_t)int_override->gsi : old_irq;
c010e226:	85 c0                	test   %eax,%eax
c010e228:	74 04                	je     c010e22e <ioapic_get_irq+0x22>
c010e22a:	0f b6 50 04          	movzbl 0x4(%eax),%edx
}
c010e22e:	89 d0                	mov    %edx,%eax
c010e230:	5d                   	pop    %ebp
c010e231:	c3                   	ret    

c010e232 <ioapic_write>:

void
ioapic_write(uint8_t sel, uint32_t val)
{
c010e232:	55                   	push   %ebp
c010e233:	89 e5                	mov    %esp,%ebp
    IOAPIC_REG_SEL = sel;
c010e235:	0f b6 45 08          	movzbl 0x8(%ebp),%eax
c010e239:	a3 00 10 c0 d0       	mov    %eax,0xd0c01000
    IOAPIC_REG_WIN = val;
c010e23e:	8b 45 0c             	mov    0xc(%ebp),%eax
c010e241:	a3 10 10 c0 d0       	mov    %eax,0xd0c01010
}
c010e246:	5d                   	pop    %ebp
c010e247:	c3                   	ret    

c010e248 <ioapic_read>:

uint32_t
ioapic_read(uint8_t sel)
{
c010e248:	55                   	push   %ebp
c010e249:	89 e5                	mov    %esp,%ebp
    IOAPIC_REG_SEL = sel;
c010e24b:	0f b6 45 08          	movzbl 0x8(%ebp),%eax
c010e24f:	a3 00 10 c0 d0       	mov    %eax,0xd0c01000
    return IOAPIC_REG_WIN;
c010e254:	a1 10 10 c0 d0       	mov    0xd0c01010,%eax
}
c010e259:	5d                   	pop    %ebp
c010e25a:	c3                   	ret    

c010e25b <ioapic_redirect>:

void
ioapic_redirect(uint8_t irq, uint8_t vector, uint8_t dest, uint32_t flags)
{
c010e25b:	55                   	push   %ebp
c010e25c:	89 e5                	mov    %esp,%ebp
c010e25e:	56                   	push   %esi
c010e25f:	53                   	push   %ebx
c010e260:	8b 75 10             	mov    0x10(%ebp),%esi
    uint8_t reg_sel = IOAPIC_IOREDTBL_BASE + irq * 2;
c010e263:	8b 5d 08             	mov    0x8(%ebp),%ebx
c010e266:	8d 5c 1b 10          	lea    0x10(%ebx,%ebx,1),%ebx

    // Write low 32 bits
    ioapic_write(reg_sel, (vector | flags) & 0x1FFFF);
c010e26a:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
c010e26e:	0b 45 14             	or     0x14(%ebp),%eax
c010e271:	83 ec 08             	sub    $0x8,%esp
c010e274:	25 ff ff 01 00       	and    $0x1ffff,%eax
c010e279:	50                   	push   %eax
c010e27a:	0f b6 c3             	movzbl %bl,%eax
c010e27d:	50                   	push   %eax
c010e27e:	e8 af ff ff ff       	call   c010e232 <ioapic_write>

    // Write high 32 bits
    ioapic_write(reg_sel + 1, (dest << 24));
c010e283:	c1 e6 18             	shl    $0x18,%esi
c010e286:	83 c3 01             	add    $0x1,%ebx
c010e289:	83 c4 08             	add    $0x8,%esp
c010e28c:	56                   	push   %esi
c010e28d:	0f b6 db             	movzbl %bl,%ebx
c010e290:	53                   	push   %ebx
c010e291:	e8 9c ff ff ff       	call   c010e232 <ioapic_write>
c010e296:	83 c4 10             	add    $0x10,%esp
c010e299:	8d 65 f8             	lea    -0x8(%ebp),%esp
c010e29c:	5b                   	pop    %ebx
c010e29d:	5e                   	pop    %esi
c010e29e:	5d                   	pop    %ebp
c010e29f:	c3                   	ret    

c010e2a0 <ioapic_init>:
{
c010e2a0:	55                   	push   %ebp
c010e2a1:	89 e5                	mov    %esp,%ebp
c010e2a3:	83 ec 08             	sub    $0x8,%esp
    acpi_context* acpi_ctx = acpi_get_context();
c010e2a6:	e8 e2 fc ff ff       	call   c010df8d <acpi_get_context>
    uint8_t irq_rtc = ioapic_get_irq(acpi_ctx, PC_AT_IRQ_RTC);
c010e2ab:	83 ec 08             	sub    $0x8,%esp
c010e2ae:	6a 08                	push   $0x8
c010e2b0:	50                   	push   %eax
c010e2b1:	e8 56 ff ff ff       	call   c010e20c <ioapic_get_irq>
c010e2b6:	83 c4 10             	add    $0x10,%esp
    ioapic_redirect(irq_rtc, RTC_TIMER_IV, 0, IOAPIC_DELMOD_FIXED);
c010e2b9:	6a 00                	push   $0x0
c010e2bb:	6a 00                	push   $0x0
c010e2bd:	68 d2 00 00 00       	push   $0xd2
c010e2c2:	0f b6 c0             	movzbl %al,%eax
c010e2c5:	50                   	push   %eax
c010e2c6:	e8 90 ff ff ff       	call   c010e25b <ioapic_redirect>
}
c010e2cb:	83 c4 10             	add    $0x10,%esp
c010e2ce:	c9                   	leave  
c010e2cf:	c3                   	ret    

c010e2d0 <rtc_read_reg>:
    rtc_disable_timer();
}

uint8_t
rtc_read_reg(uint8_t reg_selector)
{
c010e2d0:	55                   	push   %ebp
c010e2d1:	89 e5                	mov    %esp,%ebp
    asm volatile("outb %0, %w1" : : "a"(data), "d"(port));
c010e2d3:	0f b6 45 08          	movzbl 0x8(%ebp),%eax
c010e2d7:	ba 70 00 00 00       	mov    $0x70,%edx
c010e2dc:	ee                   	out    %al,(%dx)
    asm volatile("inb %w1,%0" : "=a"(data) : "d"(port));
c010e2dd:	ba 71 00 00 00       	mov    $0x71,%edx
c010e2e2:	ec                   	in     (%dx),%al
    io_outb(RTC_INDEX_PORT, reg_selector);
    return io_inb(RTC_TARGET_PORT);
}
c010e2e3:	5d                   	pop    %ebp
c010e2e4:	c3                   	ret    

c010e2e5 <rtc_write_reg>:

void
rtc_write_reg(uint8_t reg_selector, uint8_t val)
{
c010e2e5:	55                   	push   %ebp
c010e2e6:	89 e5                	mov    %esp,%ebp
    asm volatile("outb %0, %w1" : : "a"(data), "d"(port));
c010e2e8:	0f b6 45 08          	movzbl 0x8(%ebp),%eax
c010e2ec:	ba 70 00 00 00       	mov    $0x70,%edx
c010e2f1:	ee                   	out    %al,(%dx)
c010e2f2:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
c010e2f6:	ba 71 00 00 00       	mov    $0x71,%edx
c010e2fb:	ee                   	out    %al,(%dx)
    io_outb(RTC_INDEX_PORT, reg_selector);
    io_outb(RTC_TARGET_PORT, val);
}
c010e2fc:	5d                   	pop    %ebp
c010e2fd:	c3                   	ret    

c010e2fe <bcd2dec>:

uint8_t
bcd2dec(uint8_t bcd)
{
c010e2fe:	55                   	push   %ebp
c010e2ff:	89 e5                	mov    %esp,%ebp
c010e301:	8b 4d 08             	mov    0x8(%ebp),%ecx
    return ((bcd & 0xF0) >> 1) + ((bcd & 0xF0) >> 3) + (bcd & 0xf);
c010e304:	0f b6 d1             	movzbl %cl,%edx
c010e307:	89 d0                	mov    %edx,%eax
c010e309:	d1 f8                	sar    %eax
c010e30b:	83 e0 78             	and    $0x78,%eax
c010e30e:	c1 fa 03             	sar    $0x3,%edx
c010e311:	83 e2 1e             	and    $0x1e,%edx
c010e314:	01 d0                	add    %edx,%eax
c010e316:	83 e1 0f             	and    $0xf,%ecx
c010e319:	01 c8                	add    %ecx,%eax
}
c010e31b:	5d                   	pop    %ebp
c010e31c:	c3                   	ret    

c010e31d <rtc_enable_timer>:


void
rtc_enable_timer() {
c010e31d:	55                   	push   %ebp
c010e31e:	89 e5                	mov    %esp,%ebp
c010e320:	83 ec 14             	sub    $0x14,%esp
    uint8_t regB = rtc_read_reg(RTC_REG_B | WITH_NMI_DISABLED);
c010e323:	68 8b 00 00 00       	push   $0x8b
c010e328:	e8 a3 ff ff ff       	call   c010e2d0 <rtc_read_reg>
    rtc_write_reg(RTC_REG_B | WITH_NMI_DISABLED, regB | RTC_TIMER_ON);
c010e32d:	83 c4 08             	add    $0x8,%esp
c010e330:	83 c8 40             	or     $0x40,%eax
c010e333:	0f b6 c0             	movzbl %al,%eax
c010e336:	50                   	push   %eax
c010e337:	68 8b 00 00 00       	push   $0x8b
c010e33c:	e8 a4 ff ff ff       	call   c010e2e5 <rtc_write_reg>
}
c010e341:	83 c4 10             	add    $0x10,%esp
c010e344:	c9                   	leave  
c010e345:	c3                   	ret    

c010e346 <rtc_disable_timer>:

void
rtc_disable_timer() {
c010e346:	55                   	push   %ebp
c010e347:	89 e5                	mov    %esp,%ebp
c010e349:	83 ec 14             	sub    $0x14,%esp
    uint8_t regB = rtc_read_reg(RTC_REG_B | WITH_NMI_DISABLED);
c010e34c:	68 8b 00 00 00       	push   $0x8b
c010e351:	e8 7a ff ff ff       	call   c010e2d0 <rtc_read_reg>
    rtc_write_reg(RTC_REG_B | WITH_NMI_DISABLED, regB & ~RTC_TIMER_ON);
c010e356:	83 c4 08             	add    $0x8,%esp
c010e359:	25 bf 00 00 00       	and    $0xbf,%eax
c010e35e:	50                   	push   %eax
c010e35f:	68 8b 00 00 00       	push   $0x8b
c010e364:	e8 7c ff ff ff       	call   c010e2e5 <rtc_write_reg>
c010e369:	83 c4 10             	add    $0x10,%esp
c010e36c:	c9                   	leave  
c010e36d:	c3                   	ret    

c010e36e <rtc_init>:
rtc_init() {
c010e36e:	55                   	push   %ebp
c010e36f:	89 e5                	mov    %esp,%ebp
c010e371:	83 ec 14             	sub    $0x14,%esp
    uint8_t regA = rtc_read_reg(RTC_REG_A | WITH_NMI_DISABLED);
c010e374:	68 8a 00 00 00       	push   $0x8a
c010e379:	e8 52 ff ff ff       	call   c010e2d0 <rtc_read_reg>
    regA = (regA & ~0x7f) | RTC_FREQUENCY_1024HZ | RTC_DIVIDER_33KHZ;
c010e37e:	83 e0 80             	and    $0xffffff80,%eax
c010e381:	83 c8 26             	or     $0x26,%eax
    rtc_write_reg(RTC_REG_A | WITH_NMI_DISABLED, regA);
c010e384:	83 c4 08             	add    $0x8,%esp
c010e387:	0f b6 c0             	movzbl %al,%eax
c010e38a:	50                   	push   %eax
c010e38b:	68 8a 00 00 00       	push   $0x8a
c010e390:	e8 50 ff ff ff       	call   c010e2e5 <rtc_write_reg>
    rtc_disable_timer();
c010e395:	e8 ac ff ff ff       	call   c010e346 <rtc_disable_timer>
}
c010e39a:	83 c4 10             	add    $0x10,%esp
c010e39d:	c9                   	leave  
c010e39e:	c3                   	ret    

c010e39f <kprintf>:
#include <arch/x86/interrupts.h>

#include <lunaix/spike.h>
#include <lunaix/syslog.h>

LOG_MODULE("APIC")
c010e39f:	55                   	push   %ebp
c010e3a0:	89 e5                	mov    %esp,%ebp
c010e3a2:	83 ec 0c             	sub    $0xc,%esp
c010e3a5:	8d 45 0c             	lea    0xc(%ebp),%eax
c010e3a8:	50                   	push   %eax
c010e3a9:	ff 75 08             	push   0x8(%ebp)
c010e3ac:	68 a6 35 d1 c0       	push   $0xc0d135a6
c010e3b1:	e8 c1 db ff ff       	call   c010bf77 <__kprintf>
c010e3b6:	83 c4 10             	add    $0x10,%esp
c010e3b9:	c9                   	leave  
c010e3ba:	c3                   	ret    

c010e3bb <apic_setup_lvts>:
#define LVT_ENTRY_ERROR(vector) (LVT_DELIVERY_FIXED | vector)

void
apic_setup_lvts()
{
    apic_write_reg(APIC_LVT_LINT0, LVT_ENTRY_LINT0(APIC_LINT0_IV));
c010e3bb:	c7 05 50 03 c0 d0 fb 	movl   $0xfb,0xd0c00350
c010e3c2:	00 00 00 
    apic_write_reg(APIC_LVT_LINT1, LVT_ENTRY_LINT1);
c010e3c5:	c7 05 60 03 c0 d0 00 	movl   $0x10400,0xd0c00360
c010e3cc:	04 01 00 
    apic_write_reg(APIC_LVT_ERROR, LVT_ENTRY_ERROR(APIC_ERROR_IV));
c010e3cf:	c7 05 70 03 c0 d0 fa 	movl   $0xfa,0xd0c00370
c010e3d6:	00 00 00 
}
c010e3d9:	c3                   	ret    

c010e3da <apic_init>:
{
c010e3da:	55                   	push   %ebp
c010e3db:	89 e5                	mov    %esp,%ebp
c010e3dd:	83 ec 08             	sub    $0x8,%esp
    asm volatile("cli");
c010e3e0:	fa                   	cli    
    assert_msg(cpu_has_apic(), "No APIC detected!");
c010e3e1:	e8 e7 01 00 00       	call   c010e5cd <cpu_has_apic>
c010e3e6:	85 c0                	test   %eax,%eax
c010e3e8:	74 60                	je     c010e44a <apic_init+0x70>

static inline void
pic_disable()
{
    // ref: https://wiki.osdev.org/8259_PIC
    asm volatile ("movb $0xff, %al\n"
c010e3ea:	b0 ff                	mov    $0xff,%al
c010e3ec:	e6 a1                	out    %al,$0xa1
c010e3ee:	e6 21                	out    %al,$0x21
    asm volatile("movl %0, %%ecx\n"
c010e3f0:	b9 1b 00 00 00       	mov    $0x1b,%ecx
c010e3f5:	0f 32                	rdmsr  
c010e3f7:	0d 00 08 00 00       	or     $0x800,%eax
c010e3fc:	0f 30                	wrmsr  
    uint32_t apic_id = apic_read_reg(APIC_IDR) >> 24;
c010e3fe:	0f b6 0d 23 00 c0 d0 	movzbl 0xd0c00023,%ecx
    uint32_t apic_ver = apic_read_reg(APIC_VER);
c010e405:	a1 30 00 c0 d0       	mov    0xd0c00030,%eax
            (apic_ver >> 16) & 0xff);
c010e40a:	89 c2                	mov    %eax,%edx
c010e40c:	c1 ea 10             	shr    $0x10,%edx
    kprintf(KINFO "ID: %x, Version: %x, Max LVT: %u\n",
c010e40f:	0f b6 d2             	movzbl %dl,%edx
c010e412:	52                   	push   %edx
c010e413:	0f b6 c0             	movzbl %al,%eax
c010e416:	50                   	push   %eax
c010e417:	51                   	push   %ecx
c010e418:	68 68 39 d1 c0       	push   $0xc0d13968
c010e41d:	e8 7d ff ff ff       	call   c010e39f <kprintf>
    apic_setup_lvts();
c010e422:	e8 94 ff ff ff       	call   c010e3bb <apic_setup_lvts>
    apic_write_reg(APIC_TPR, APIC_PRIORITY(2, 0));
c010e427:	c7 05 80 00 c0 d0 20 	movl   $0x20,0xd0c00080
c010e42e:	00 00 00 
    spiv = (spiv & ~0xff) | APIC_SPIV_APIC_ENABLE | APIC_SPIV_IV;
c010e431:	a1 f0 00 c0 d0       	mov    0xd0c000f0,%eax
c010e436:	25 00 fe ff ff       	and    $0xfffffe00,%eax
c010e43b:	0d fc 01 00 00       	or     $0x1fc,%eax
    apic_write_reg(APIC_SPIVR, spiv);
c010e440:	a3 f0 00 c0 d0       	mov    %eax,0xd0c000f0
}
c010e445:	83 c4 10             	add    $0x10,%esp
c010e448:	c9                   	leave  
c010e449:	c3                   	ret    
    assert_msg(cpu_has_apic(), "No APIC detected!");
c010e44a:	83 ec 04             	sub    $0x4,%esp
c010e44d:	6a 22                	push   $0x22
c010e44f:	68 ab 35 d1 c0       	push   $0xc0d135ab
c010e454:	68 b6 35 d1 c0       	push   $0xc0d135b6
c010e459:	e8 05 cb ff ff       	call   c010af63 <__assert_fail>

c010e45e <cpu_get_model>:
#include <hal/cpu.h>
#include <stdint.h>
#include <cpuid.h>

void cpu_get_model(char* model_out) {
c010e45e:	55                   	push   %ebp
c010e45f:	89 e5                	mov    %esp,%ebp
c010e461:	56                   	push   %esi
c010e462:	53                   	push   %ebx
c010e463:	8b 75 08             	mov    0x8(%ebp),%esi
  unsigned int __eax, __ebx, __ecx, __edx;

#ifndef __x86_64__
  /* See if we can use cpuid.  On AMD64 we always can.  */
#if __GNUC__ >= 3
  __asm__ ("pushf{l|d}\n\t"
c010e466:	9c                   	pushf  
c010e467:	9c                   	pushf  
c010e468:	58                   	pop    %eax
c010e469:	89 c2                	mov    %eax,%edx
c010e46b:	35 00 00 20 00       	xor    $0x200000,%eax
c010e470:	50                   	push   %eax
c010e471:	9d                   	popf   
c010e472:	9c                   	pushf  
c010e473:	58                   	pop    %eax
c010e474:	9d                   	popf   
	   "popfl\n\t"
	   : "=&r" (__eax), "=&r" (__ebx)
	   : "i" (0x00200000));
#endif

  if (!((__eax ^ __ebx) & 0x00200000))
c010e475:	31 d0                	xor    %edx,%eax
c010e477:	25 00 00 20 00       	and    $0x200000,%eax
c010e47c:	74 07                	je     c010e485 <cpu_get_model+0x27>
    return 0;
#endif

  /* Host supports cpuid.  Return highest supported cpuid input value.  */
  __cpuid (__ext, __eax, __ebx, __ecx, __edx);
c010e47e:	b8 00 00 00 00       	mov    $0x0,%eax
c010e483:	0f a2                	cpuid  
	     unsigned int *__ecx, unsigned int *__edx)
{
  unsigned int __ext = __leaf & 0x80000000;
  unsigned int __maxlevel = __get_cpuid_max (__ext, 0);

  if (__maxlevel == 0 || __maxlevel < __leaf)
c010e485:	85 c0                	test   %eax,%eax
c010e487:	74 09                	je     c010e492 <cpu_get_model+0x34>
    return 0;

  __cpuid (__leaf, *__eax, *__ebx, *__ecx, *__edx);
c010e489:	b8 00 00 00 00       	mov    $0x0,%eax
c010e48e:	0f a2                	cpuid  
c010e490:	eb 0f                	jmp    c010e4a1 <cpu_get_model+0x43>
    uint32_t* out = (uint32_t*)model_out;
    reg32 eax = 0, ebx = 0, edx = 0, ecx = 0;
c010e492:	b9 00 00 00 00       	mov    $0x0,%ecx
c010e497:	ba 00 00 00 00       	mov    $0x0,%edx
c010e49c:	bb 00 00 00 00       	mov    $0x0,%ebx
    
    __get_cpuid(0, &eax, &ebx, &ecx, &edx);

    out[0] = ebx;
c010e4a1:	89 1e                	mov    %ebx,(%esi)
    out[1] = edx;
c010e4a3:	89 56 04             	mov    %edx,0x4(%esi)
    out[2] = ecx;
c010e4a6:	89 4e 08             	mov    %ecx,0x8(%esi)
    model_out[12] = '\0';
c010e4a9:	c6 46 0c 00          	movb   $0x0,0xc(%esi)
}
c010e4ad:	5b                   	pop    %ebx
c010e4ae:	5e                   	pop    %esi
c010e4af:	5d                   	pop    %ebp
c010e4b0:	c3                   	ret    

c010e4b1 <cpu_brand_string_supported>:
  __asm__ ("pushf{l|d}\n\t"
c010e4b1:	9c                   	pushf  
c010e4b2:	9c                   	pushf  
c010e4b3:	58                   	pop    %eax
c010e4b4:	89 c2                	mov    %eax,%edx
c010e4b6:	35 00 00 20 00       	xor    $0x200000,%eax
c010e4bb:	50                   	push   %eax
c010e4bc:	9d                   	popf   
c010e4bd:	9c                   	pushf  
c010e4be:	58                   	pop    %eax
c010e4bf:	9d                   	popf   
  if (!((__eax ^ __ebx) & 0x00200000))
c010e4c0:	31 d0                	xor    %edx,%eax
c010e4c2:	25 00 00 20 00       	and    $0x200000,%eax
c010e4c7:	74 1b                	je     c010e4e4 <cpu_brand_string_supported+0x33>

#define BRAND_LEAF 0x80000000UL

int cpu_brand_string_supported() {
c010e4c9:	55                   	push   %ebp
c010e4ca:	89 e5                	mov    %esp,%ebp
c010e4cc:	53                   	push   %ebx
  __cpuid (__ext, __eax, __ebx, __ecx, __edx);
c010e4cd:	b8 00 00 00 80       	mov    $0x80000000,%eax
c010e4d2:	0f a2                	cpuid  
    reg32 supported = __get_cpuid_max(BRAND_LEAF, 0);
    return (supported >= 0x80000004UL);
c010e4d4:	3d 03 00 00 80       	cmp    $0x80000003,%eax
c010e4d9:	0f 97 c0             	seta   %al
c010e4dc:	0f b6 c0             	movzbl %al,%eax
}
c010e4df:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c010e4e2:	c9                   	leave  
c010e4e3:	c3                   	ret    
    return (supported >= 0x80000004UL);
c010e4e4:	3d 03 00 00 80       	cmp    $0x80000003,%eax
c010e4e9:	0f 97 c0             	seta   %al
c010e4ec:	0f b6 c0             	movzbl %al,%eax
}
c010e4ef:	c3                   	ret    

c010e4f0 <cpu_get_brand>:

void cpu_get_brand(char* brand_out) {
c010e4f0:	55                   	push   %ebp
c010e4f1:	89 e5                	mov    %esp,%ebp
c010e4f3:	57                   	push   %edi
c010e4f4:	56                   	push   %esi
c010e4f5:	53                   	push   %ebx
c010e4f6:	83 ec 2c             	sub    $0x2c,%esp
c010e4f9:	8b 75 08             	mov    0x8(%ebp),%esi
    if(!cpu_brand_string_supported()) {
c010e4fc:	e8 b0 ff ff ff       	call   c010e4b1 <cpu_brand_string_supported>
c010e501:	85 c0                	test   %eax,%eax
c010e503:	75 07                	jne    c010e50c <cpu_get_brand+0x1c>
        brand_out[0] = '?';
c010e505:	c6 06 3f             	movb   $0x3f,(%esi)
        brand_out[1] = '\0';
c010e508:	c6 46 01 00          	movb   $0x0,0x1(%esi)
    }
    uint32_t* out = (uint32_t*) brand_out;
    reg32 eax = 0, ebx = 0, edx = 0, ecx = 0;
c010e50c:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
c010e513:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
c010e51a:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
c010e521:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
    for (uint32_t i = 2, j = 0; i < 5; i++)
c010e528:	bf 00 00 00 00       	mov    $0x0,%edi
c010e52d:	c7 45 e4 02 00 00 00 	movl   $0x2,-0x1c(%ebp)
c010e534:	eb 22                	jmp    c010e558 <cpu_get_brand+0x68>
    {
        __get_cpuid(BRAND_LEAF + i, &eax, &ebx, &ecx, &edx);
        out[j] = eax;
c010e536:	8b 45 dc             	mov    -0x24(%ebp),%eax
c010e539:	89 04 be             	mov    %eax,(%esi,%edi,4)
        out[j + 1] = ebx;
c010e53c:	8b 45 d8             	mov    -0x28(%ebp),%eax
c010e53f:	89 44 be 04          	mov    %eax,0x4(%esi,%edi,4)
        out[j + 2] = ecx;
c010e543:	8b 45 d0             	mov    -0x30(%ebp),%eax
c010e546:	89 44 be 08          	mov    %eax,0x8(%esi,%edi,4)
        out[j + 3] = edx;
c010e54a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c010e54d:	89 44 be 0c          	mov    %eax,0xc(%esi,%edi,4)
        j+=4;
c010e551:	83 c7 04             	add    $0x4,%edi
    for (uint32_t i = 2, j = 0; i < 5; i++)
c010e554:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
c010e558:	83 7d e4 04          	cmpl   $0x4,-0x1c(%ebp)
c010e55c:	77 63                	ja     c010e5c1 <cpu_get_brand+0xd1>
        __get_cpuid(BRAND_LEAF + i, &eax, &ebx, &ecx, &edx);
c010e55e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010e561:	05 00 00 00 80       	add    $0x80000000,%eax
c010e566:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned int __ext = __leaf & 0x80000000;
c010e569:	89 c2                	mov    %eax,%edx
c010e56b:	81 e2 00 00 00 80    	and    $0x80000000,%edx
  __asm__ ("pushf{l|d}\n\t"
c010e571:	9c                   	pushf  
c010e572:	9c                   	pushf  
c010e573:	58                   	pop    %eax
c010e574:	89 c1                	mov    %eax,%ecx
c010e576:	35 00 00 20 00       	xor    $0x200000,%eax
c010e57b:	50                   	push   %eax
c010e57c:	9d                   	popf   
c010e57d:	9c                   	pushf  
c010e57e:	58                   	pop    %eax
c010e57f:	9d                   	popf   
  if (!((__eax ^ __ebx) & 0x00200000))
c010e580:	31 c8                	xor    %ecx,%eax
c010e582:	25 00 00 20 00       	and    $0x200000,%eax
c010e587:	74 0b                	je     c010e594 <cpu_get_brand+0xa4>
  __cpuid (__ext, __eax, __ebx, __ecx, __edx);
c010e589:	89 d0                	mov    %edx,%eax
c010e58b:	bb 00 00 00 00       	mov    $0x0,%ebx
c010e590:	89 d9                	mov    %ebx,%ecx
c010e592:	0f a2                	cpuid  
  if (__maxlevel == 0 || __maxlevel < __leaf)
c010e594:	85 c0                	test   %eax,%eax
c010e596:	0f 94 c2             	sete   %dl
c010e599:	8b 5d e0             	mov    -0x20(%ebp),%ebx
c010e59c:	39 c3                	cmp    %eax,%ebx
c010e59e:	0f 97 c0             	seta   %al
c010e5a1:	08 c2                	or     %al,%dl
c010e5a3:	75 91                	jne    c010e536 <cpu_get_brand+0x46>
  __cpuid (__leaf, *__eax, *__ebx, *__ecx, *__edx);
c010e5a5:	89 d8                	mov    %ebx,%eax
c010e5a7:	bb 00 00 00 00       	mov    $0x0,%ebx
c010e5ac:	89 d9                	mov    %ebx,%ecx
c010e5ae:	0f a2                	cpuid  
c010e5b0:	89 5d d8             	mov    %ebx,-0x28(%ebp)
c010e5b3:	89 4d d0             	mov    %ecx,-0x30(%ebp)
c010e5b6:	89 55 d4             	mov    %edx,-0x2c(%ebp)
c010e5b9:	89 45 dc             	mov    %eax,-0x24(%ebp)
c010e5bc:	e9 75 ff ff ff       	jmp    c010e536 <cpu_get_brand+0x46>
    }
    brand_out[48] = '\0';
c010e5c1:	c6 46 30 00          	movb   $0x0,0x30(%esi)
}
c010e5c5:	83 c4 2c             	add    $0x2c,%esp
c010e5c8:	5b                   	pop    %ebx
c010e5c9:	5e                   	pop    %esi
c010e5ca:	5f                   	pop    %edi
c010e5cb:	5d                   	pop    %ebp
c010e5cc:	c3                   	ret    

c010e5cd <cpu_has_apic>:


int
cpu_has_apic() {
c010e5cd:	55                   	push   %ebp
c010e5ce:	89 e5                	mov    %esp,%ebp
c010e5d0:	53                   	push   %ebx
  __asm__ ("pushf{l|d}\n\t"
c010e5d1:	9c                   	pushf  
c010e5d2:	9c                   	pushf  
c010e5d3:	58                   	pop    %eax
c010e5d4:	89 c2                	mov    %eax,%edx
c010e5d6:	35 00 00 20 00       	xor    $0x200000,%eax
c010e5db:	50                   	push   %eax
c010e5dc:	9d                   	popf   
c010e5dd:	9c                   	pushf  
c010e5de:	58                   	pop    %eax
c010e5df:	9d                   	popf   
  if (!((__eax ^ __ebx) & 0x00200000))
c010e5e0:	31 d0                	xor    %edx,%eax
c010e5e2:	25 00 00 20 00       	and    $0x200000,%eax
c010e5e7:	74 07                	je     c010e5f0 <cpu_has_apic+0x23>
  __cpuid (__ext, __eax, __ebx, __ecx, __edx);
c010e5e9:	b8 00 00 00 00       	mov    $0x0,%eax
c010e5ee:	0f a2                	cpuid  
  if (__maxlevel == 0 || __maxlevel < __leaf)
c010e5f0:	85 c0                	test   %eax,%eax
c010e5f2:	74 1a                	je     c010e60e <cpu_has_apic+0x41>
  __cpuid (__leaf, *__eax, *__ebx, *__ecx, *__edx);
c010e5f4:	b8 01 00 00 00       	mov    $0x1,%eax
c010e5f9:	bb 00 00 00 00       	mov    $0x0,%ebx
c010e5fe:	89 d9                	mov    %ebx,%ecx
c010e600:	0f a2                	cpuid  
c010e602:	89 d0                	mov    %edx,%eax
    // reference: Intel manual, section 10.4.2
    reg32 eax = 0, ebx = 0, edx = 0, ecx = 0;
    __get_cpuid(1, &eax, &ebx, &ecx, &edx);
    
    return (edx & 0x100);
c010e604:	25 00 01 00 00       	and    $0x100,%eax
}
c010e609:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c010e60c:	c9                   	leave  
c010e60d:	c3                   	ret    
    reg32 eax = 0, ebx = 0, edx = 0, ecx = 0;
c010e60e:	b8 00 00 00 00       	mov    $0x0,%eax
c010e613:	eb ef                	jmp    c010e604 <cpu_has_apic+0x37>

c010e615 <cpu_rdmsr>:

void
cpu_rdmsr(uint32_t msr_idx, uint32_t* reg_high, uint32_t* reg_low)
{
c010e615:	55                   	push   %ebp
c010e616:	89 e5                	mov    %esp,%ebp
    uint32_t h = 0, l = 0;
    asm volatile("rdmsr" : "=d"(h), "=a"(l) : "c"(msr_idx));
c010e618:	8b 4d 08             	mov    0x8(%ebp),%ecx
c010e61b:	0f 32                	rdmsr  

    *reg_high = h;
c010e61d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c010e620:	89 11                	mov    %edx,(%ecx)
    *reg_low = l;
c010e622:	8b 55 10             	mov    0x10(%ebp),%edx
c010e625:	89 02                	mov    %eax,(%edx)
}
c010e627:	5d                   	pop    %ebp
c010e628:	c3                   	ret    

c010e629 <cpu_wrmsr>:

void
cpu_wrmsr(uint32_t msr_idx, uint32_t reg_high, uint32_t reg_low)
{
c010e629:	55                   	push   %ebp
c010e62a:	89 e5                	mov    %esp,%ebp
    asm volatile("wrmsr" : : "d"(reg_high), "a"(reg_low), "c"(msr_idx));
c010e62c:	8b 4d 08             	mov    0x8(%ebp),%ecx
c010e62f:	8b 55 0c             	mov    0xc(%ebp),%edx
c010e632:	8b 45 10             	mov    0x10(%ebp),%eax
c010e635:	0f 30                	wrmsr  
c010e637:	5d                   	pop    %ebp
c010e638:	c3                   	ret    

c010e639 <__sprintf_internal>:


// FIXME: use something like IO_FILE to abstract this into a more flexible, stream based, vprintf
void
__sprintf_internal(char* buffer, char* fmt, size_t max_len, va_list vargs)
{
c010e639:	55                   	push   %ebp
c010e63a:	89 e5                	mov    %esp,%ebp
c010e63c:	57                   	push   %edi
c010e63d:	56                   	push   %esi
c010e63e:	53                   	push   %ebx
c010e63f:	83 ec 4c             	sub    $0x4c,%esp
c010e642:	8b 75 08             	mov    0x8(%ebp),%esi
c010e645:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    // This sprintf just a random implementation I found it on Internet . lol.
    //      Of course, with some modifications for porting to LunaixOS :)

    char numbuf[NUMBUFSIZ];
    uint32_t ptr = 0;
c010e648:	bf 00 00 00 00       	mov    $0x0,%edi
    for (; *fmt; ++fmt) {
c010e64d:	eb 11                	jmp    c010e660 <__sprintf_internal+0x27>
        if (max_len && ptr >= max_len - 1) {
            break;
        }
        
        if (*fmt != '%') {
c010e64f:	0f b6 45 c4          	movzbl -0x3c(%ebp),%eax
c010e653:	3c 25                	cmp    $0x25,%al
c010e655:	74 2f                	je     c010e686 <__sprintf_internal+0x4d>
            buffer[ptr++] = *fmt;
c010e657:	88 04 3e             	mov    %al,(%esi,%edi,1)
c010e65a:	8d 7f 01             	lea    0x1(%edi),%edi
    for (; *fmt; ++fmt) {
c010e65d:	83 c3 01             	add    $0x1,%ebx
c010e660:	0f b6 03             	movzbl (%ebx),%eax
c010e663:	88 45 c4             	mov    %al,-0x3c(%ebp)
c010e666:	84 c0                	test   %al,%al
c010e668:	74 10                	je     c010e67a <__sprintf_internal+0x41>
        if (max_len && ptr >= max_len - 1) {
c010e66a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c010e66e:	74 df                	je     c010e64f <__sprintf_internal+0x16>
c010e670:	8b 45 10             	mov    0x10(%ebp),%eax
c010e673:	83 e8 01             	sub    $0x1,%eax
c010e676:	39 f8                	cmp    %edi,%eax
c010e678:	77 d5                	ja     c010e64f <__sprintf_internal+0x16>
        }
        for (; width > 0; --width) {
            buffer[ptr++] = ' ';
        }
    }
    buffer[ptr++] = '\0';
c010e67a:	c6 04 3e 00          	movb   $0x0,(%esi,%edi,1)
}
c010e67e:	8d 65 f4             	lea    -0xc(%ebp),%esp
c010e681:	5b                   	pop    %ebx
c010e682:	5e                   	pop    %esi
c010e683:	5f                   	pop    %edi
c010e684:	5d                   	pop    %ebp
c010e685:	c3                   	ret    
        for (++fmt; *fmt; ++fmt) {
c010e686:	83 c3 01             	add    $0x1,%ebx
        int flags = 0;
c010e689:	b8 00 00 00 00       	mov    $0x0,%eax
c010e68e:	89 7d bc             	mov    %edi,-0x44(%ebp)
c010e691:	89 c7                	mov    %eax,%edi
        for (++fmt; *fmt; ++fmt) {
c010e693:	0f b6 03             	movzbl (%ebx),%eax
c010e696:	84 c0                	test   %al,%al
c010e698:	74 2e                	je     c010e6c8 <__sprintf_internal+0x8f>
            const char* flagc = strchr(flag_chars, *fmt);
c010e69a:	83 ec 08             	sub    $0x8,%esp
c010e69d:	0f be c0             	movsbl %al,%eax
c010e6a0:	50                   	push   %eax
c010e6a1:	68 94 31 d1 c0       	push   $0xc0d13194
c010e6a6:	e8 1d 06 00 00       	call   c010ecc8 <strchr>
c010e6ab:	89 c1                	mov    %eax,%ecx
            if (flagc) {
c010e6ad:	83 c4 10             	add    $0x10,%esp
c010e6b0:	85 c0                	test   %eax,%eax
c010e6b2:	74 14                	je     c010e6c8 <__sprintf_internal+0x8f>
                flags |= 1 << (flagc - flag_chars);
c010e6b4:	81 e9 94 31 d1 c0    	sub    $0xc0d13194,%ecx
c010e6ba:	b8 01 00 00 00       	mov    $0x1,%eax
c010e6bf:	d3 e0                	shl    %cl,%eax
c010e6c1:	09 c7                	or     %eax,%edi
        for (++fmt; *fmt; ++fmt) {
c010e6c3:	83 c3 01             	add    $0x1,%ebx
c010e6c6:	eb cb                	jmp    c010e693 <__sprintf_internal+0x5a>
        if (*fmt >= '1' && *fmt <= '9') {
c010e6c8:	89 7d c0             	mov    %edi,-0x40(%ebp)
c010e6cb:	8b 7d bc             	mov    -0x44(%ebp),%edi
c010e6ce:	0f b6 03             	movzbl (%ebx),%eax
c010e6d1:	8d 50 cf             	lea    -0x31(%eax),%edx
c010e6d4:	80 fa 08             	cmp    $0x8,%dl
c010e6d7:	76 51                	jbe    c010e72a <__sprintf_internal+0xf1>
        } else if (*fmt == '*') {
c010e6d9:	3c 2a                	cmp    $0x2a,%al
c010e6db:	74 54                	je     c010e731 <__sprintf_internal+0xf8>
        int width = -1;
c010e6dd:	c7 45 ac ff ff ff ff 	movl   $0xffffffff,-0x54(%ebp)
        if (*fmt == '.') {
c010e6e4:	80 3b 2e             	cmpb   $0x2e,(%ebx)
c010e6e7:	74 5b                	je     c010e744 <__sprintf_internal+0x10b>
        int precision = -1;
c010e6e9:	c7 45 b4 ff ff ff ff 	movl   $0xffffffff,-0x4c(%ebp)
        int length = 0;
c010e6f0:	b9 00 00 00 00       	mov    $0x0,%ecx
        switch (*fmt) {
c010e6f5:	0f b6 13             	movzbl (%ebx),%edx
c010e6f8:	8d 42 a8             	lea    -0x58(%edx),%eax
c010e6fb:	3c 22                	cmp    $0x22,%al
c010e6fd:	0f 87 44 02 00 00    	ja     c010e947 <__sprintf_internal+0x30e>
c010e703:	0f b6 c0             	movzbl %al,%eax
c010e706:	ff 24 85 08 31 d1 c0 	jmp    *-0x3f2ecef8(,%eax,4)
                width = 10 * width + *fmt++ - '0';
c010e70d:	8d 14 92             	lea    (%edx,%edx,4),%edx
c010e710:	83 c3 01             	add    $0x1,%ebx
c010e713:	0f be c0             	movsbl %al,%eax
c010e716:	8d 54 50 d0          	lea    -0x30(%eax,%edx,2),%edx
            for (width = 0; *fmt >= '0' && *fmt <= '9'; ) {
c010e71a:	0f b6 03             	movzbl (%ebx),%eax
c010e71d:	8d 48 d0             	lea    -0x30(%eax),%ecx
c010e720:	80 f9 09             	cmp    $0x9,%cl
c010e723:	76 e8                	jbe    c010e70d <__sprintf_internal+0xd4>
c010e725:	89 55 ac             	mov    %edx,-0x54(%ebp)
c010e728:	eb ba                	jmp    c010e6e4 <__sprintf_internal+0xab>
c010e72a:	ba 00 00 00 00       	mov    $0x0,%edx
c010e72f:	eb e9                	jmp    c010e71a <__sprintf_internal+0xe1>
            width = va_arg(vargs, int);
c010e731:	8b 45 14             	mov    0x14(%ebp),%eax
c010e734:	8d 50 04             	lea    0x4(%eax),%edx
c010e737:	89 55 14             	mov    %edx,0x14(%ebp)
c010e73a:	8b 00                	mov    (%eax),%eax
c010e73c:	89 45 ac             	mov    %eax,-0x54(%ebp)
            ++fmt;
c010e73f:	83 c3 01             	add    $0x1,%ebx
c010e742:	eb a0                	jmp    c010e6e4 <__sprintf_internal+0xab>
            ++fmt;
c010e744:	8d 53 01             	lea    0x1(%ebx),%edx
            if (*fmt >= '0' && *fmt <= '9') {
c010e747:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c010e74b:	8d 48 d0             	lea    -0x30(%eax),%ecx
c010e74e:	80 f9 09             	cmp    $0x9,%cl
c010e751:	76 42                	jbe    c010e795 <__sprintf_internal+0x15c>
            } else if (*fmt == '*') {
c010e753:	3c 2a                	cmp    $0x2a,%al
c010e755:	74 45                	je     c010e79c <__sprintf_internal+0x163>
            ++fmt;
c010e757:	89 d3                	mov    %edx,%ebx
                precision = 0;
c010e759:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
c010e760:	eb 8e                	jmp    c010e6f0 <__sprintf_internal+0xb7>
                    precision = 10 * precision + *fmt++ - '0';
c010e762:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
c010e765:	83 c2 01             	add    $0x1,%edx
c010e768:	0f be c0             	movsbl %al,%eax
c010e76b:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
                for (precision = 0; *fmt >= '0' && *fmt <= '9'; ) {
c010e76f:	0f b6 02             	movzbl (%edx),%eax
c010e772:	8d 58 d0             	lea    -0x30(%eax),%ebx
c010e775:	80 fb 09             	cmp    $0x9,%bl
c010e778:	76 e8                	jbe    c010e762 <__sprintf_internal+0x129>
c010e77a:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
c010e77d:	89 d3                	mov    %edx,%ebx
            if (precision < 0) {
c010e77f:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
c010e783:	0f 89 67 ff ff ff    	jns    c010e6f0 <__sprintf_internal+0xb7>
                precision = 0;
c010e789:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
c010e790:	e9 5b ff ff ff       	jmp    c010e6f0 <__sprintf_internal+0xb7>
                for (precision = 0; *fmt >= '0' && *fmt <= '9'; ) {
c010e795:	b9 00 00 00 00       	mov    $0x0,%ecx
c010e79a:	eb d3                	jmp    c010e76f <__sprintf_internal+0x136>
                precision = va_arg(vargs, int);
c010e79c:	8b 45 14             	mov    0x14(%ebp),%eax
c010e79f:	8d 50 04             	lea    0x4(%eax),%edx
c010e7a2:	89 55 14             	mov    %edx,0x14(%ebp)
c010e7a5:	8b 00                	mov    (%eax),%eax
c010e7a7:	89 45 b4             	mov    %eax,-0x4c(%ebp)
                ++fmt;
c010e7aa:	83 c3 02             	add    $0x2,%ebx
c010e7ad:	eb d0                	jmp    c010e77f <__sprintf_internal+0x146>
            ++fmt;
c010e7af:	83 c3 01             	add    $0x1,%ebx
            length = 1;
c010e7b2:	b9 01 00 00 00       	mov    $0x1,%ecx
            goto again;
c010e7b7:	e9 39 ff ff ff       	jmp    c010e6f5 <__sprintf_internal+0xbc>
            long x = length ? va_arg(vargs, long) : va_arg(vargs, int);
c010e7bc:	85 c9                	test   %ecx,%ecx
c010e7be:	74 32                	je     c010e7f2 <__sprintf_internal+0x1b9>
c010e7c0:	8b 45 14             	mov    0x14(%ebp),%eax
c010e7c3:	8d 50 04             	lea    0x4(%eax),%edx
c010e7c6:	89 55 14             	mov    %edx,0x14(%ebp)
c010e7c9:	8b 10                	mov    (%eax),%edx
            int negative = x < 0 ? FLAG_NEGATIVE : 0;
c010e7cb:	89 d0                	mov    %edx,%eax
c010e7cd:	c1 f8 18             	sar    $0x18,%eax
            num = negative ? -x : x;
c010e7d0:	25 80 00 00 00       	and    $0x80,%eax
c010e7d5:	74 28                	je     c010e7ff <__sprintf_internal+0x1c6>
c010e7d7:	f7 da                	neg    %edx
c010e7d9:	89 55 bc             	mov    %edx,-0x44(%ebp)
            flags |= FLAG_NUMERIC | FLAG_SIGNED | negative;
c010e7dc:	83 c8 60             	or     $0x60,%eax
c010e7df:	09 45 c0             	or     %eax,-0x40(%ebp)
        char* data = "";
c010e7e2:	c7 45 c4 83 34 d1 c0 	movl   $0xc0d13483,-0x3c(%ebp)
        int base = 10;
c010e7e9:	c7 45 b8 0a 00 00 00 	movl   $0xa,-0x48(%ebp)
            break;
c010e7f0:	eb 5f                	jmp    c010e851 <__sprintf_internal+0x218>
            long x = length ? va_arg(vargs, long) : va_arg(vargs, int);
c010e7f2:	8b 45 14             	mov    0x14(%ebp),%eax
c010e7f5:	8d 50 04             	lea    0x4(%eax),%edx
c010e7f8:	89 55 14             	mov    %edx,0x14(%ebp)
c010e7fb:	8b 10                	mov    (%eax),%edx
c010e7fd:	eb cc                	jmp    c010e7cb <__sprintf_internal+0x192>
            num = negative ? -x : x;
c010e7ff:	89 55 bc             	mov    %edx,-0x44(%ebp)
c010e802:	eb d8                	jmp    c010e7dc <__sprintf_internal+0x1a3>
        switch (*fmt) {
c010e804:	c7 45 b8 0a 00 00 00 	movl   $0xa,-0x48(%ebp)
c010e80b:	eb 27                	jmp    c010e834 <__sprintf_internal+0x1fb>
            base = 16;
c010e80d:	c7 45 b8 10 00 00 00 	movl   $0x10,-0x48(%ebp)
c010e814:	eb 1e                	jmp    c010e834 <__sprintf_internal+0x1fb>
            num = length ? va_arg(vargs, unsigned long) : va_arg(vargs, unsigned);
c010e816:	8b 45 14             	mov    0x14(%ebp),%eax
c010e819:	8d 50 04             	lea    0x4(%eax),%edx
c010e81c:	89 55 14             	mov    %edx,0x14(%ebp)
c010e81f:	8b 00                	mov    (%eax),%eax
c010e821:	89 45 bc             	mov    %eax,-0x44(%ebp)
c010e824:	eb 20                	jmp    c010e846 <__sprintf_internal+0x20d>
            flags = flags | FLAG_CAPS;
c010e826:	81 4d c0 00 02 00 00 	orl    $0x200,-0x40(%ebp)
            base = 16;
c010e82d:	c7 45 b8 10 00 00 00 	movl   $0x10,-0x48(%ebp)
            num = length ? va_arg(vargs, unsigned long) : va_arg(vargs, unsigned);
c010e834:	85 c9                	test   %ecx,%ecx
c010e836:	74 de                	je     c010e816 <__sprintf_internal+0x1dd>
c010e838:	8b 45 14             	mov    0x14(%ebp),%eax
c010e83b:	8d 50 04             	lea    0x4(%eax),%edx
c010e83e:	89 55 14             	mov    %edx,0x14(%ebp)
c010e841:	8b 00                	mov    (%eax),%eax
c010e843:	89 45 bc             	mov    %eax,-0x44(%ebp)
            flags |= FLAG_NUMERIC;
c010e846:	83 4d c0 20          	orl    $0x20,-0x40(%ebp)
        char* data = "";
c010e84a:	c7 45 c4 83 34 d1 c0 	movl   $0xc0d13483,-0x3c(%ebp)
        if (flags & FLAG_NUMERIC) {
c010e851:	8b 45 c0             	mov    -0x40(%ebp),%eax
c010e854:	83 e0 20             	and    $0x20,%eax
c010e857:	89 45 b0             	mov    %eax,-0x50(%ebp)
c010e85a:	0f 85 30 01 00 00    	jne    c010e990 <__sprintf_internal+0x357>
        if ((flags & FLAG_NUMERIC) && (flags & FLAG_SIGNED)) {
c010e860:	8b 45 c0             	mov    -0x40(%ebp),%eax
c010e863:	89 45 a8             	mov    %eax,-0x58(%ebp)
c010e866:	83 e0 60             	and    $0x60,%eax
c010e869:	83 f8 60             	cmp    $0x60,%eax
c010e86c:	0f 84 84 01 00 00    	je     c010e9f6 <__sprintf_internal+0x3bd>
        } else if ((flags & FLAG_NUMERIC) && (flags & FLAG_ALT)
c010e872:	8b 45 c0             	mov    -0x40(%ebp),%eax
c010e875:	83 e0 21             	and    $0x21,%eax
c010e878:	83 f8 21             	cmp    $0x21,%eax
c010e87b:	0f 84 90 01 00 00    	je     c010ea11 <__sprintf_internal+0x3d8>
        const char* prefix = "";
c010e881:	c7 45 b8 83 34 d1 c0 	movl   $0xc0d13483,-0x48(%ebp)
        if (precision >= 0 && !(flags & FLAG_NUMERIC)) {
c010e888:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
c010e88c:	78 0a                	js     c010e898 <__sprintf_internal+0x25f>
c010e88e:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
c010e892:	0f 84 e2 01 00 00    	je     c010ea7a <__sprintf_internal+0x441>
            len = strlen(data);
c010e898:	83 ec 0c             	sub    $0xc,%esp
c010e89b:	ff 75 c4             	push   -0x3c(%ebp)
c010e89e:	e8 4e 04 00 00       	call   c010ecf1 <strlen>
c010e8a3:	89 45 bc             	mov    %eax,-0x44(%ebp)
c010e8a6:	83 c4 10             	add    $0x10,%esp
        if ((flags & FLAG_NUMERIC) && precision >= 0) {
c010e8a9:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
c010e8ad:	0f 84 e0 01 00 00    	je     c010ea93 <__sprintf_internal+0x45a>
c010e8b3:	8b 45 b4             	mov    -0x4c(%ebp),%eax
c010e8b6:	85 c0                	test   %eax,%eax
c010e8b8:	0f 88 d5 01 00 00    	js     c010ea93 <__sprintf_internal+0x45a>
            zeros = precision > len ? precision - len : 0;
c010e8be:	8b 4d bc             	mov    -0x44(%ebp),%ecx
c010e8c1:	39 c8                	cmp    %ecx,%eax
c010e8c3:	0f 8e 43 02 00 00    	jle    c010eb0c <__sprintf_internal+0x4d3>
c010e8c9:	29 c8                	sub    %ecx,%eax
c010e8cb:	89 45 b4             	mov    %eax,-0x4c(%ebp)
c010e8ce:	e9 d2 01 00 00       	jmp    c010eaa5 <__sprintf_internal+0x46c>
            num = (uintptr_t) va_arg(vargs, void*);
c010e8d3:	8b 45 14             	mov    0x14(%ebp),%eax
c010e8d6:	8d 50 04             	lea    0x4(%eax),%edx
c010e8d9:	89 55 14             	mov    %edx,0x14(%ebp)
c010e8dc:	8b 00                	mov    (%eax),%eax
c010e8de:	89 45 bc             	mov    %eax,-0x44(%ebp)
            flags |= FLAG_ALT | FLAG_ALT2 | FLAG_NUMERIC;
c010e8e1:	81 4d c0 21 01 00 00 	orl    $0x121,-0x40(%ebp)
        char* data = "";
c010e8e8:	c7 45 c4 83 34 d1 c0 	movl   $0xc0d13483,-0x3c(%ebp)
            base = 16;
c010e8ef:	c7 45 b8 10 00 00 00 	movl   $0x10,-0x48(%ebp)
            break;
c010e8f6:	e9 56 ff ff ff       	jmp    c010e851 <__sprintf_internal+0x218>
            data = va_arg(vargs, char*);
c010e8fb:	8b 45 14             	mov    0x14(%ebp),%eax
c010e8fe:	8d 50 04             	lea    0x4(%eax),%edx
c010e901:	89 55 14             	mov    %edx,0x14(%ebp)
c010e904:	8b 00                	mov    (%eax),%eax
c010e906:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        unsigned long num = 0;
c010e909:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
        int base = 10;
c010e910:	c7 45 b8 0a 00 00 00 	movl   $0xa,-0x48(%ebp)
            break;
c010e917:	e9 35 ff ff ff       	jmp    c010e851 <__sprintf_internal+0x218>
            numbuf[0] = va_arg(vargs, int);
c010e91c:	8b 45 14             	mov    0x14(%ebp),%eax
c010e91f:	8d 50 04             	lea    0x4(%eax),%edx
c010e922:	89 55 14             	mov    %edx,0x14(%ebp)
c010e925:	8b 00                	mov    (%eax),%eax
c010e927:	88 45 d0             	mov    %al,-0x30(%ebp)
            numbuf[1] = '\0';
c010e92a:	c6 45 d1 00          	movb   $0x0,-0x2f(%ebp)
            data = numbuf;
c010e92e:	8d 45 d0             	lea    -0x30(%ebp),%eax
c010e931:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        unsigned long num = 0;
c010e934:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
        int base = 10;
c010e93b:	c7 45 b8 0a 00 00 00 	movl   $0xa,-0x48(%ebp)
            break;
c010e942:	e9 0a ff ff ff       	jmp    c010e851 <__sprintf_internal+0x218>
            numbuf[0] = (*fmt ? *fmt : '%');
c010e947:	84 d2                	test   %dl,%dl
c010e949:	75 04                	jne    c010e94f <__sprintf_internal+0x316>
c010e94b:	0f b6 55 c4          	movzbl -0x3c(%ebp),%edx
c010e94f:	88 55 d0             	mov    %dl,-0x30(%ebp)
            numbuf[1] = '\0';
c010e952:	c6 45 d1 00          	movb   $0x0,-0x2f(%ebp)
            if (!*fmt) {
c010e956:	80 3b 00             	cmpb   $0x0,(%ebx)
c010e959:	75 1c                	jne    c010e977 <__sprintf_internal+0x33e>
                fmt--;
c010e95b:	83 eb 01             	sub    $0x1,%ebx
            data = numbuf;
c010e95e:	8d 45 d0             	lea    -0x30(%ebp),%eax
c010e961:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        unsigned long num = 0;
c010e964:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
        int base = 10;
c010e96b:	c7 45 b8 0a 00 00 00 	movl   $0xa,-0x48(%ebp)
c010e972:	e9 da fe ff ff       	jmp    c010e851 <__sprintf_internal+0x218>
            data = numbuf;
c010e977:	8d 45 d0             	lea    -0x30(%ebp),%eax
c010e97a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        unsigned long num = 0;
c010e97d:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
        int base = 10;
c010e984:	c7 45 b8 0a 00 00 00 	movl   $0xa,-0x48(%ebp)
c010e98b:	e9 c1 fe ff ff       	jmp    c010e851 <__sprintf_internal+0x218>
            data = itoa(num, numbuf, base);
c010e990:	83 ec 04             	sub    $0x4,%esp
c010e993:	ff 75 b8             	push   -0x48(%ebp)
c010e996:	8d 45 d0             	lea    -0x30(%ebp),%eax
c010e999:	50                   	push   %eax
c010e99a:	ff 75 bc             	push   -0x44(%ebp)
c010e99d:	e8 57 04 00 00       	call   c010edf9 <itoa>
c010e9a2:	89 45 c4             	mov    %eax,-0x3c(%ebp)
            while ((flags & FLAG_CAPS) && (c = data[i]))
c010e9a5:	83 c4 10             	add    $0x10,%esp
            int i = 0;
c010e9a8:	b8 00 00 00 00       	mov    $0x0,%eax
c010e9ad:	89 7d a8             	mov    %edi,-0x58(%ebp)
c010e9b0:	8b 7d c0             	mov    -0x40(%ebp),%edi
c010e9b3:	89 75 08             	mov    %esi,0x8(%ebp)
c010e9b6:	89 c6                	mov    %eax,%esi
            while ((flags & FLAG_CAPS) && (c = data[i]))
c010e9b8:	f7 c7 00 02 00 00    	test   $0x200,%edi
c010e9be:	74 2b                	je     c010e9eb <__sprintf_internal+0x3b2>
c010e9c0:	8b 45 c4             	mov    -0x3c(%ebp),%eax
c010e9c3:	8d 0c 30             	lea    (%eax,%esi,1),%ecx
c010e9c6:	0f b6 11             	movzbl (%ecx),%edx
c010e9c9:	84 d2                	test   %dl,%dl
c010e9cb:	74 13                	je     c010e9e0 <__sprintf_internal+0x3a7>
                data[i] = c & ~((c & 0x40) >> 1);
c010e9cd:	0f be c2             	movsbl %dl,%eax
c010e9d0:	d1 f8                	sar    %eax
c010e9d2:	83 e0 20             	and    $0x20,%eax
c010e9d5:	f7 d0                	not    %eax
c010e9d7:	21 d0                	and    %edx,%eax
c010e9d9:	88 01                	mov    %al,(%ecx)
                i++;
c010e9db:	83 c6 01             	add    $0x1,%esi
c010e9de:	eb d8                	jmp    c010e9b8 <__sprintf_internal+0x37f>
c010e9e0:	8b 7d a8             	mov    -0x58(%ebp),%edi
c010e9e3:	8b 75 08             	mov    0x8(%ebp),%esi
c010e9e6:	e9 75 fe ff ff       	jmp    c010e860 <__sprintf_internal+0x227>
c010e9eb:	8b 7d a8             	mov    -0x58(%ebp),%edi
c010e9ee:	8b 75 08             	mov    0x8(%ebp),%esi
c010e9f1:	e9 6a fe ff ff       	jmp    c010e860 <__sprintf_internal+0x227>
            if (flags & FLAG_NEGATIVE) {
c010e9f6:	8b 45 c0             	mov    -0x40(%ebp),%eax
c010e9f9:	a8 80                	test   $0x80,%al
c010e9fb:	75 35                	jne    c010ea32 <__sprintf_internal+0x3f9>
            } else if (flags & FLAG_PLUSPOSITIVE) {
c010e9fd:	a8 10                	test   $0x10,%al
c010e9ff:	75 3d                	jne    c010ea3e <__sprintf_internal+0x405>
            } else if (flags & FLAG_SPACEPOSITIVE) {
c010ea01:	a8 08                	test   $0x8,%al
c010ea03:	75 45                	jne    c010ea4a <__sprintf_internal+0x411>
        const char* prefix = "";
c010ea05:	c7 45 b8 83 34 d1 c0 	movl   $0xc0d13483,-0x48(%ebp)
c010ea0c:	e9 77 fe ff ff       	jmp    c010e888 <__sprintf_internal+0x24f>
                   && (base == 16 || base == -16)
c010ea11:	83 7d b8 10          	cmpl   $0x10,-0x48(%ebp)
c010ea15:	75 3f                	jne    c010ea56 <__sprintf_internal+0x41d>
                   && (num || (flags & FLAG_ALT2))) {
c010ea17:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
c010ea1b:	75 45                	jne    c010ea62 <__sprintf_internal+0x429>
c010ea1d:	f7 45 c0 00 01 00 00 	testl  $0x100,-0x40(%ebp)
c010ea24:	75 48                	jne    c010ea6e <__sprintf_internal+0x435>
        const char* prefix = "";
c010ea26:	c7 45 b8 83 34 d1 c0 	movl   $0xc0d13483,-0x48(%ebp)
c010ea2d:	e9 56 fe ff ff       	jmp    c010e888 <__sprintf_internal+0x24f>
                prefix = "-";
c010ea32:	c7 45 b8 d7 34 d1 c0 	movl   $0xc0d134d7,-0x48(%ebp)
c010ea39:	e9 4a fe ff ff       	jmp    c010e888 <__sprintf_internal+0x24f>
                prefix = "+";
c010ea3e:	c7 45 b8 d2 34 d1 c0 	movl   $0xc0d134d2,-0x48(%ebp)
c010ea45:	e9 3e fe ff ff       	jmp    c010e888 <__sprintf_internal+0x24f>
                prefix = " ";
c010ea4a:	c7 45 b8 d9 34 d1 c0 	movl   $0xc0d134d9,-0x48(%ebp)
c010ea51:	e9 32 fe ff ff       	jmp    c010e888 <__sprintf_internal+0x24f>
        const char* prefix = "";
c010ea56:	c7 45 b8 83 34 d1 c0 	movl   $0xc0d13483,-0x48(%ebp)
c010ea5d:	e9 26 fe ff ff       	jmp    c010e888 <__sprintf_internal+0x24f>
            prefix = "0x";
c010ea62:	c7 45 b8 d4 34 d1 c0 	movl   $0xc0d134d4,-0x48(%ebp)
c010ea69:	e9 1a fe ff ff       	jmp    c010e888 <__sprintf_internal+0x24f>
c010ea6e:	c7 45 b8 d4 34 d1 c0 	movl   $0xc0d134d4,-0x48(%ebp)
c010ea75:	e9 0e fe ff ff       	jmp    c010e888 <__sprintf_internal+0x24f>
            len = strnlen(data, precision);
c010ea7a:	83 ec 08             	sub    $0x8,%esp
c010ea7d:	ff 75 b4             	push   -0x4c(%ebp)
c010ea80:	ff 75 c4             	push   -0x3c(%ebp)
c010ea83:	e8 81 02 00 00       	call   c010ed09 <strnlen>
c010ea88:	89 45 bc             	mov    %eax,-0x44(%ebp)
c010ea8b:	83 c4 10             	add    $0x10,%esp
c010ea8e:	e9 16 fe ff ff       	jmp    c010e8a9 <__sprintf_internal+0x270>
                   && !(flags & FLAG_LEFTJUSTIFY)
c010ea93:	8b 45 a8             	mov    -0x58(%ebp),%eax
c010ea96:	83 e0 26             	and    $0x26,%eax
        } else if ((flags & FLAG_NUMERIC) && (flags & FLAG_ZERO)
c010ea99:	83 f8 22             	cmp    $0x22,%eax
c010ea9c:	74 2e                	je     c010eacc <__sprintf_internal+0x493>
            zeros = 0;
c010ea9e:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
        width -= len + zeros + strlen(prefix);
c010eaa5:	8b 45 bc             	mov    -0x44(%ebp),%eax
c010eaa8:	03 45 b4             	add    -0x4c(%ebp),%eax
c010eaab:	89 45 b0             	mov    %eax,-0x50(%ebp)
c010eaae:	83 ec 0c             	sub    $0xc,%esp
c010eab1:	ff 75 b8             	push   -0x48(%ebp)
c010eab4:	e8 38 02 00 00       	call   c010ecf1 <strlen>
c010eab9:	8b 4d b0             	mov    -0x50(%ebp),%ecx
c010eabc:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c010eabf:	8b 45 ac             	mov    -0x54(%ebp),%eax
c010eac2:	29 d0                	sub    %edx,%eax
        for (; !(flags & FLAG_LEFTJUSTIFY) && width > 0; --width) {
c010eac4:	83 c4 10             	add    $0x10,%esp
c010eac7:	8b 55 c0             	mov    -0x40(%ebp),%edx
c010eaca:	eb 53                	jmp    c010eb1f <__sprintf_internal+0x4e6>
                   && len + (int) strlen(prefix) < width) {
c010eacc:	83 ec 0c             	sub    $0xc,%esp
c010eacf:	ff 75 b8             	push   -0x48(%ebp)
c010ead2:	e8 1a 02 00 00       	call   c010ecf1 <strlen>
c010ead7:	03 45 bc             	add    -0x44(%ebp),%eax
c010eada:	83 c4 10             	add    $0x10,%esp
c010eadd:	3b 45 ac             	cmp    -0x54(%ebp),%eax
c010eae0:	7c 09                	jl     c010eaeb <__sprintf_internal+0x4b2>
            zeros = 0;
c010eae2:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
c010eae9:	eb ba                	jmp    c010eaa5 <__sprintf_internal+0x46c>
            zeros = width - len - strlen(prefix);
c010eaeb:	8b 45 ac             	mov    -0x54(%ebp),%eax
c010eaee:	2b 45 bc             	sub    -0x44(%ebp),%eax
c010eaf1:	89 45 b4             	mov    %eax,-0x4c(%ebp)
c010eaf4:	83 ec 0c             	sub    $0xc,%esp
c010eaf7:	ff 75 b8             	push   -0x48(%ebp)
c010eafa:	e8 f2 01 00 00       	call   c010ecf1 <strlen>
c010eaff:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
c010eb02:	29 c1                	sub    %eax,%ecx
c010eb04:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
c010eb07:	83 c4 10             	add    $0x10,%esp
c010eb0a:	eb 99                	jmp    c010eaa5 <__sprintf_internal+0x46c>
            zeros = precision > len ? precision - len : 0;
c010eb0c:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
c010eb13:	eb 90                	jmp    c010eaa5 <__sprintf_internal+0x46c>
            buffer[ptr++] = ' ';
c010eb15:	c6 04 3e 20          	movb   $0x20,(%esi,%edi,1)
        for (; !(flags & FLAG_LEFTJUSTIFY) && width > 0; --width) {
c010eb19:	83 e8 01             	sub    $0x1,%eax
            buffer[ptr++] = ' ';
c010eb1c:	8d 7f 01             	lea    0x1(%edi),%edi
        for (; !(flags & FLAG_LEFTJUSTIFY) && width > 0; --width) {
c010eb1f:	f6 c2 04             	test   $0x4,%dl
c010eb22:	75 1e                	jne    c010eb42 <__sprintf_internal+0x509>
c010eb24:	85 c0                	test   %eax,%eax
c010eb26:	7f ed                	jg     c010eb15 <__sprintf_internal+0x4dc>
c010eb28:	8b 4d b8             	mov    -0x48(%ebp),%ecx
c010eb2b:	eb 09                	jmp    c010eb36 <__sprintf_internal+0x4fd>
            buffer[ptr++] = *prefix;
c010eb2d:	88 14 3e             	mov    %dl,(%esi,%edi,1)
        for (; *prefix; ++prefix) {
c010eb30:	83 c1 01             	add    $0x1,%ecx
            buffer[ptr++] = *prefix;
c010eb33:	8d 7f 01             	lea    0x1(%edi),%edi
        for (; *prefix; ++prefix) {
c010eb36:	0f b6 11             	movzbl (%ecx),%edx
c010eb39:	84 d2                	test   %dl,%dl
c010eb3b:	75 f0                	jne    c010eb2d <__sprintf_internal+0x4f4>
c010eb3d:	8b 55 b4             	mov    -0x4c(%ebp),%edx
c010eb40:	eb 0f                	jmp    c010eb51 <__sprintf_internal+0x518>
c010eb42:	8b 4d b8             	mov    -0x48(%ebp),%ecx
c010eb45:	eb ef                	jmp    c010eb36 <__sprintf_internal+0x4fd>
            buffer[ptr++] = '0';
c010eb47:	c6 04 3e 30          	movb   $0x30,(%esi,%edi,1)
        for (; zeros > 0; --zeros) {
c010eb4b:	83 ea 01             	sub    $0x1,%edx
            buffer[ptr++] = '0';
c010eb4e:	8d 7f 01             	lea    0x1(%edi),%edi
        for (; zeros > 0; --zeros) {
c010eb51:	85 d2                	test   %edx,%edx
c010eb53:	7f f2                	jg     c010eb47 <__sprintf_internal+0x50e>
c010eb55:	89 45 c0             	mov    %eax,-0x40(%ebp)
c010eb58:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
c010eb5b:	8b 55 bc             	mov    -0x44(%ebp),%edx
c010eb5e:	eb 0f                	jmp    c010eb6f <__sprintf_internal+0x536>
            buffer[ptr++] = *data;
c010eb60:	0f b6 01             	movzbl (%ecx),%eax
c010eb63:	88 04 3e             	mov    %al,(%esi,%edi,1)
        for (; len > 0; ++data, --len) {
c010eb66:	83 c1 01             	add    $0x1,%ecx
c010eb69:	83 ea 01             	sub    $0x1,%edx
            buffer[ptr++] = *data;
c010eb6c:	8d 7f 01             	lea    0x1(%edi),%edi
        for (; len > 0; ++data, --len) {
c010eb6f:	85 d2                	test   %edx,%edx
c010eb71:	7f ed                	jg     c010eb60 <__sprintf_internal+0x527>
c010eb73:	8b 45 c0             	mov    -0x40(%ebp),%eax
c010eb76:	eb 0a                	jmp    c010eb82 <__sprintf_internal+0x549>
            buffer[ptr++] = ' ';
c010eb78:	c6 04 3e 20          	movb   $0x20,(%esi,%edi,1)
        for (; width > 0; --width) {
c010eb7c:	83 e8 01             	sub    $0x1,%eax
            buffer[ptr++] = ' ';
c010eb7f:	8d 7f 01             	lea    0x1(%edi),%edi
        for (; width > 0; --width) {
c010eb82:	85 c0                	test   %eax,%eax
c010eb84:	7f f2                	jg     c010eb78 <__sprintf_internal+0x53f>
c010eb86:	e9 d2 fa ff ff       	jmp    c010e65d <__sprintf_internal+0x24>

c010eb8b <sprintf>:

void
sprintf(char* buffer, char* fmt, ...)
{
c010eb8b:	55                   	push   %ebp
c010eb8c:	89 e5                	mov    %esp,%ebp
c010eb8e:	83 ec 08             	sub    $0x8,%esp
    va_list args;
    va_start(args, fmt);
c010eb91:	8d 45 10             	lea    0x10(%ebp),%eax
    __sprintf_internal(buffer, fmt, 0, args);
c010eb94:	50                   	push   %eax
c010eb95:	6a 00                	push   $0x0
c010eb97:	ff 75 0c             	push   0xc(%ebp)
c010eb9a:	ff 75 08             	push   0x8(%ebp)
c010eb9d:	e8 97 fa ff ff       	call   c010e639 <__sprintf_internal>
    va_end(args);
}
c010eba2:	83 c4 10             	add    $0x10,%esp
c010eba5:	c9                   	leave  
c010eba6:	c3                   	ret    

c010eba7 <snprintf>:

void
snprintf(char* buffer, size_t n, char* fmt, ...)
{
c010eba7:	55                   	push   %ebp
c010eba8:	89 e5                	mov    %esp,%ebp
c010ebaa:	83 ec 08             	sub    $0x8,%esp
    va_list args;
    va_start(args, fmt);
c010ebad:	8d 45 14             	lea    0x14(%ebp),%eax
    __sprintf_internal(buffer, fmt, n, args);
c010ebb0:	50                   	push   %eax
c010ebb1:	ff 75 0c             	push   0xc(%ebp)
c010ebb4:	ff 75 10             	push   0x10(%ebp)
c010ebb7:	ff 75 08             	push   0x8(%ebp)
c010ebba:	e8 7a fa ff ff       	call   c010e639 <__sprintf_internal>
    va_end(args);
c010ebbf:	83 c4 10             	add    $0x10,%esp
c010ebc2:	c9                   	leave  
c010ebc3:	c3                   	ret    

c010ebc4 <strcpy>:
#include <klibc/string.h>

char*
strcpy(char* dest, const char* src) {
c010ebc4:	55                   	push   %ebp
c010ebc5:	89 e5                	mov    %esp,%ebp
c010ebc7:	53                   	push   %ebx
c010ebc8:	8b 4d 08             	mov    0x8(%ebp),%ecx
c010ebcb:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    char c;
    unsigned int i = 0;
c010ebce:	b8 00 00 00 00       	mov    $0x0,%eax
    while ((c = src[i]))
c010ebd3:	eb 06                	jmp    c010ebdb <strcpy+0x17>
    {
        dest[i] = c;
c010ebd5:	88 14 01             	mov    %dl,(%ecx,%eax,1)
        i++;
c010ebd8:	83 c0 01             	add    $0x1,%eax
    while ((c = src[i]))
c010ebdb:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
c010ebdf:	84 d2                	test   %dl,%dl
c010ebe1:	75 f2                	jne    c010ebd5 <strcpy+0x11>
    }
    dest[i] = '\0';
c010ebe3:	c6 04 01 00          	movb   $0x0,(%ecx,%eax,1)
    return dest;
}
c010ebe7:	89 c8                	mov    %ecx,%eax
c010ebe9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c010ebec:	c9                   	leave  
c010ebed:	c3                   	ret    

c010ebee <strncpy>:

char*
strncpy(char* dest, const char* src, size_t n) {
c010ebee:	55                   	push   %ebp
c010ebef:	89 e5                	mov    %esp,%ebp
c010ebf1:	56                   	push   %esi
c010ebf2:	53                   	push   %ebx
c010ebf3:	8b 5d 08             	mov    0x8(%ebp),%ebx
c010ebf6:	8b 75 0c             	mov    0xc(%ebp),%esi
c010ebf9:	8b 4d 10             	mov    0x10(%ebp),%ecx
    char c;
    unsigned int i = 0;
c010ebfc:	b8 00 00 00 00       	mov    $0x0,%eax
    while ((c = src[i]) && i < n) dest[i++] = c;
c010ec01:	eb 06                	jmp    c010ec09 <strncpy+0x1b>
c010ec03:	88 14 03             	mov    %dl,(%ebx,%eax,1)
c010ec06:	8d 40 01             	lea    0x1(%eax),%eax
c010ec09:	0f b6 14 06          	movzbl (%esi,%eax,1),%edx
c010ec0d:	84 d2                	test   %dl,%dl
c010ec0f:	74 04                	je     c010ec15 <strncpy+0x27>
c010ec11:	39 c8                	cmp    %ecx,%eax
c010ec13:	72 ee                	jb     c010ec03 <strncpy+0x15>
    while (i < n) dest[i++] = 0;
c010ec15:	39 c8                	cmp    %ecx,%eax
c010ec17:	73 09                	jae    c010ec22 <strncpy+0x34>
c010ec19:	c6 04 03 00          	movb   $0x0,(%ebx,%eax,1)
c010ec1d:	8d 40 01             	lea    0x1(%eax),%eax
c010ec20:	eb f3                	jmp    c010ec15 <strncpy+0x27>
    return dest;
c010ec22:	89 d8                	mov    %ebx,%eax
c010ec24:	5b                   	pop    %ebx
c010ec25:	5e                   	pop    %esi
c010ec26:	5d                   	pop    %ebp
c010ec27:	c3                   	ret    

c010ec28 <memcpy>:
#include <klibc/string.h>
#include <stdint.h>

void*
memcpy(void* dest, const void* src, size_t num)
{
c010ec28:	55                   	push   %ebp
c010ec29:	89 e5                	mov    %esp,%ebp
c010ec2b:	57                   	push   %edi
c010ec2c:	56                   	push   %esi
c010ec2d:	8b 45 08             	mov    0x8(%ebp),%eax
    asm volatile("movl %1, %%edi\n"
c010ec30:	8b 4d 10             	mov    0x10(%ebp),%ecx
c010ec33:	8b 75 0c             	mov    0xc(%ebp),%esi
c010ec36:	89 c7                	mov    %eax,%edi
c010ec38:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
                 "rep movsb\n" ::"S"(src),
                 "r"(dest),
                 "c"(num)
                 : "edi", "memory");
    return dest;
}
c010ec3a:	5e                   	pop    %esi
c010ec3b:	5f                   	pop    %edi
c010ec3c:	5d                   	pop    %ebp
c010ec3d:	c3                   	ret    

c010ec3e <memmove>:

void*
memmove(void* dest, const void* src, size_t num)
{
c010ec3e:	55                   	push   %ebp
c010ec3f:	89 e5                	mov    %esp,%ebp
c010ec41:	56                   	push   %esi
c010ec42:	53                   	push   %ebx
c010ec43:	8b 4d 08             	mov    0x8(%ebp),%ecx
c010ec46:	8b 5d 0c             	mov    0xc(%ebp),%ebx
c010ec49:	8b 75 10             	mov    0x10(%ebp),%esi
    uint8_t* dest_ptr = (uint8_t*)dest;
    const uint8_t* src_ptr = (const uint8_t*)src;
    if (dest_ptr < src_ptr) {
c010ec4c:	39 d9                	cmp    %ebx,%ecx
c010ec4e:	73 25                	jae    c010ec75 <memmove+0x37>
        for (size_t i = 0; i < num; i++) {
c010ec50:	ba 00 00 00 00       	mov    $0x0,%edx
c010ec55:	eb 0a                	jmp    c010ec61 <memmove+0x23>
            *(dest_ptr + i) = *(src_ptr + i);
c010ec57:	0f b6 04 13          	movzbl (%ebx,%edx,1),%eax
c010ec5b:	88 04 11             	mov    %al,(%ecx,%edx,1)
        for (size_t i = 0; i < num; i++) {
c010ec5e:	83 c2 01             	add    $0x1,%edx
c010ec61:	39 f2                	cmp    %esi,%edx
c010ec63:	72 f2                	jb     c010ec57 <memmove+0x19>
        for (size_t i = num; i != 0; i--) {
            *(dest_ptr + i - 1) = *(src_ptr + i - 1);
        }
    }
    return dest;
}
c010ec65:	89 c8                	mov    %ecx,%eax
c010ec67:	5b                   	pop    %ebx
c010ec68:	5e                   	pop    %esi
c010ec69:	5d                   	pop    %ebp
c010ec6a:	c3                   	ret    
            *(dest_ptr + i - 1) = *(src_ptr + i - 1);
c010ec6b:	83 ee 01             	sub    $0x1,%esi
c010ec6e:	0f b6 14 33          	movzbl (%ebx,%esi,1),%edx
c010ec72:	88 14 31             	mov    %dl,(%ecx,%esi,1)
        for (size_t i = num; i != 0; i--) {
c010ec75:	85 f6                	test   %esi,%esi
c010ec77:	75 f2                	jne    c010ec6b <memmove+0x2d>
c010ec79:	eb ea                	jmp    c010ec65 <memmove+0x27>

c010ec7b <memset>:

void*
memset(void* ptr, int value, size_t num)
{
c010ec7b:	55                   	push   %ebp
c010ec7c:	89 e5                	mov    %esp,%ebp
c010ec7e:	57                   	push   %edi
c010ec7f:	8b 55 08             	mov    0x8(%ebp),%edx
    asm volatile("movl %1, %%edi\n"
c010ec82:	8b 45 0c             	mov    0xc(%ebp),%eax
c010ec85:	8b 4d 10             	mov    0x10(%ebp),%ecx
c010ec88:	89 d7                	mov    %edx,%edi
c010ec8a:	f3 aa                	rep stos %al,%es:(%edi)
                 "rep stosb\n" ::"c"(num),
                 "r"(ptr),
                 "a"(value)
                 : "edi", "memory");
    return ptr;
}
c010ec8c:	89 d0                	mov    %edx,%eax
c010ec8e:	8b 7d fc             	mov    -0x4(%ebp),%edi
c010ec91:	c9                   	leave  
c010ec92:	c3                   	ret    

c010ec93 <memcmp>:

int
memcmp(const void* ptr1, const void* ptr2, size_t num)
{
c010ec93:	55                   	push   %ebp
c010ec94:	89 e5                	mov    %esp,%ebp
c010ec96:	57                   	push   %edi
c010ec97:	56                   	push   %esi
c010ec98:	53                   	push   %ebx
c010ec99:	8b 7d 08             	mov    0x8(%ebp),%edi
c010ec9c:	8b 75 0c             	mov    0xc(%ebp),%esi
c010ec9f:	8b 5d 10             	mov    0x10(%ebp),%ebx
    uint8_t* p1 = (uint8_t*)ptr1;
    uint8_t* p2 = (uint8_t*)ptr2;
    for (size_t i = 0; i < num; i++) {
c010eca2:	ba 00 00 00 00       	mov    $0x0,%edx
c010eca7:	eb 03                	jmp    c010ecac <memcmp+0x19>
c010eca9:	83 c2 01             	add    $0x1,%edx
c010ecac:	39 da                	cmp    %ebx,%edx
c010ecae:	73 0e                	jae    c010ecbe <memcmp+0x2b>
        int diff = *(p1 + i) - *(p2 + i);
c010ecb0:	0f b6 04 17          	movzbl (%edi,%edx,1),%eax
c010ecb4:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
        if (diff != 0) {
c010ecb8:	29 c8                	sub    %ecx,%eax
c010ecba:	74 ed                	je     c010eca9 <memcmp+0x16>
c010ecbc:	eb 05                	jmp    c010ecc3 <memcmp+0x30>
            return diff;
        }
    }
    return 0;
c010ecbe:	b8 00 00 00 00       	mov    $0x0,%eax
c010ecc3:	5b                   	pop    %ebx
c010ecc4:	5e                   	pop    %esi
c010ecc5:	5f                   	pop    %edi
c010ecc6:	5d                   	pop    %ebp
c010ecc7:	c3                   	ret    

c010ecc8 <strchr>:
#include <klibc/string.h>

const char*
strchr(const char* str, int character)
{
c010ecc8:	55                   	push   %ebp
c010ecc9:	89 e5                	mov    %esp,%ebp
c010eccb:	8b 45 08             	mov    0x8(%ebp),%eax
    char c = (char)character;
c010ecce:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
    while ((*str)) {
c010ecd2:	eb 03                	jmp    c010ecd7 <strchr+0xf>
        if (*str == c) {
            return str;
        }
        str++;
c010ecd4:	83 c0 01             	add    $0x1,%eax
    while ((*str)) {
c010ecd7:	0f b6 10             	movzbl (%eax),%edx
c010ecda:	84 d2                	test   %dl,%dl
c010ecdc:	74 06                	je     c010ece4 <strchr+0x1c>
        if (*str == c) {
c010ecde:	38 ca                	cmp    %cl,%dl
c010ece0:	75 f2                	jne    c010ecd4 <strchr+0xc>
    }
    return c == '\0' ? str : NULL;
c010ece2:	5d                   	pop    %ebp
c010ece3:	c3                   	ret    
    return c == '\0' ? str : NULL;
c010ece4:	80 7d 0c 00          	cmpb   $0x0,0xc(%ebp)
c010ece8:	74 f8                	je     c010ece2 <strchr+0x1a>
c010ecea:	b8 00 00 00 00       	mov    $0x0,%eax
c010ecef:	eb f1                	jmp    c010ece2 <strchr+0x1a>

c010ecf1 <strlen>:
#include <klibc/string.h>

size_t
strlen(const char* str)
{
c010ecf1:	55                   	push   %ebp
c010ecf2:	89 e5                	mov    %esp,%ebp
c010ecf4:	8b 55 08             	mov    0x8(%ebp),%edx
    size_t len = 0;
c010ecf7:	b8 00 00 00 00       	mov    $0x0,%eax
    while (str[len])
c010ecfc:	eb 03                	jmp    c010ed01 <strlen+0x10>
        len++;
c010ecfe:	83 c0 01             	add    $0x1,%eax
    while (str[len])
c010ed01:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
c010ed05:	75 f7                	jne    c010ecfe <strlen+0xd>
    return len;
}
c010ed07:	5d                   	pop    %ebp
c010ed08:	c3                   	ret    

c010ed09 <strnlen>:

size_t
strnlen(const char* str, size_t max_len) {
c010ed09:	55                   	push   %ebp
c010ed0a:	89 e5                	mov    %esp,%ebp
c010ed0c:	8b 55 08             	mov    0x8(%ebp),%edx
c010ed0f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    size_t len = 0;
c010ed12:	b8 00 00 00 00       	mov    $0x0,%eax
    while (str[len] && len <= max_len)
c010ed17:	eb 03                	jmp    c010ed1c <strnlen+0x13>
        len++;
c010ed19:	83 c0 01             	add    $0x1,%eax
    while (str[len] && len <= max_len)
c010ed1c:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
c010ed20:	74 04                	je     c010ed26 <strnlen+0x1d>
c010ed22:	39 c8                	cmp    %ecx,%eax
c010ed24:	76 f3                	jbe    c010ed19 <strnlen+0x10>
    return len;
c010ed26:	5d                   	pop    %ebp
c010ed27:	c3                   	ret    

c010ed28 <__uitoa_internal>:

char base_char[] = "0123456789abcdefghijklmnopqrstuvwxyz";

char*
__uitoa_internal(unsigned int value, char* str, int base, unsigned int* size)
{
c010ed28:	55                   	push   %ebp
c010ed29:	89 e5                	mov    %esp,%ebp
c010ed2b:	57                   	push   %edi
c010ed2c:	56                   	push   %esi
c010ed2d:	53                   	push   %ebx
c010ed2e:	83 ec 04             	sub    $0x4,%esp
c010ed31:	8b 5d 08             	mov    0x8(%ebp),%ebx
c010ed34:	8b 75 0c             	mov    0xc(%ebp),%esi
c010ed37:	8b 7d 10             	mov    0x10(%ebp),%edi
    unsigned int ptr = 0;
c010ed3a:	b9 00 00 00 00       	mov    $0x0,%ecx
    do {
        str[ptr] = base_char[value % base];
c010ed3f:	89 d8                	mov    %ebx,%eax
c010ed41:	ba 00 00 00 00       	mov    $0x0,%edx
c010ed46:	f7 f7                	div    %edi
c010ed48:	0f b6 92 40 26 d1 c0 	movzbl -0x3f2ed9c0(%edx),%edx
c010ed4f:	88 14 0e             	mov    %dl,(%esi,%ecx,1)
        value = value / base;
c010ed52:	89 da                	mov    %ebx,%edx
c010ed54:	89 c3                	mov    %eax,%ebx
        ptr++;
c010ed56:	83 c1 01             	add    $0x1,%ecx
    } while (value);
c010ed59:	39 d7                	cmp    %edx,%edi
c010ed5b:	76 e2                	jbe    c010ed3f <__uitoa_internal+0x17>

    for (unsigned int i = 0; i < (ptr >> 1); i++) {
c010ed5d:	b8 00 00 00 00       	mov    $0x0,%eax
c010ed62:	89 4d f0             	mov    %ecx,-0x10(%ebp)
c010ed65:	eb 1b                	jmp    c010ed82 <__uitoa_internal+0x5a>
        char c = str[i];
c010ed67:	8d 1c 06             	lea    (%esi,%eax,1),%ebx
c010ed6a:	0f b6 3b             	movzbl (%ebx),%edi
        str[i] = str[ptr - i - 1];
c010ed6d:	8b 4d f0             	mov    -0x10(%ebp),%ecx
c010ed70:	29 c1                	sub    %eax,%ecx
c010ed72:	8d 54 0e ff          	lea    -0x1(%esi,%ecx,1),%edx
c010ed76:	0f b6 0a             	movzbl (%edx),%ecx
c010ed79:	88 0b                	mov    %cl,(%ebx)
        str[ptr - i - 1] = c;
c010ed7b:	89 f9                	mov    %edi,%ecx
c010ed7d:	88 0a                	mov    %cl,(%edx)
    for (unsigned int i = 0; i < (ptr >> 1); i++) {
c010ed7f:	83 c0 01             	add    $0x1,%eax
c010ed82:	8b 4d f0             	mov    -0x10(%ebp),%ecx
c010ed85:	d1 e9                	shr    %ecx
c010ed87:	39 c1                	cmp    %eax,%ecx
c010ed89:	77 dc                	ja     c010ed67 <__uitoa_internal+0x3f>
    }
    str[ptr] = '\0';
c010ed8b:	8b 4d f0             	mov    -0x10(%ebp),%ecx
c010ed8e:	c6 04 0e 00          	movb   $0x0,(%esi,%ecx,1)
    if (size) {
c010ed92:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
c010ed96:	74 05                	je     c010ed9d <__uitoa_internal+0x75>
        *size = ptr;
c010ed98:	8b 45 14             	mov    0x14(%ebp),%eax
c010ed9b:	89 08                	mov    %ecx,(%eax)
    }
    return str;
}
c010ed9d:	89 f0                	mov    %esi,%eax
c010ed9f:	83 c4 04             	add    $0x4,%esp
c010eda2:	5b                   	pop    %ebx
c010eda3:	5e                   	pop    %esi
c010eda4:	5f                   	pop    %edi
c010eda5:	5d                   	pop    %ebp
c010eda6:	c3                   	ret    

c010eda7 <__itoa_internal>:

char*
__itoa_internal(int value, char* str, int base, unsigned int* size)
{
c010eda7:	55                   	push   %ebp
c010eda8:	89 e5                	mov    %esp,%ebp
c010edaa:	57                   	push   %edi
c010edab:	56                   	push   %esi
c010edac:	53                   	push   %ebx
c010edad:	8b 5d 0c             	mov    0xc(%ebp),%ebx
c010edb0:	8b 55 10             	mov    0x10(%ebp),%edx
c010edb3:	8b 75 14             	mov    0x14(%ebp),%esi
    if (value < 0 && base == 10) {
c010edb6:	8b 45 08             	mov    0x8(%ebp),%eax
c010edb9:	c1 e8 1f             	shr    $0x1f,%eax
c010edbc:	89 c1                	mov    %eax,%ecx
c010edbe:	83 fa 0a             	cmp    $0xa,%edx
c010edc1:	0f 94 c0             	sete   %al
c010edc4:	84 c8                	test   %cl,%al
c010edc6:	74 21                	je     c010ede9 <__itoa_internal+0x42>
        str[0] = '-';
c010edc8:	c6 03 2d             	movb   $0x2d,(%ebx)
        unsigned int _v = (unsigned int)(-value);
c010edcb:	8b 45 08             	mov    0x8(%ebp),%eax
c010edce:	f7 d8                	neg    %eax
        __uitoa_internal(_v, str + 1, base, size);
c010edd0:	56                   	push   %esi
c010edd1:	52                   	push   %edx
c010edd2:	8d 53 01             	lea    0x1(%ebx),%edx
c010edd5:	52                   	push   %edx
c010edd6:	50                   	push   %eax
c010edd7:	e8 4c ff ff ff       	call   c010ed28 <__uitoa_internal>
c010eddc:	83 c4 10             	add    $0x10,%esp
    } else {
        __uitoa_internal(value, str, base, size);
    }

    return str;
}
c010eddf:	89 d8                	mov    %ebx,%eax
c010ede1:	8d 65 f4             	lea    -0xc(%ebp),%esp
c010ede4:	5b                   	pop    %ebx
c010ede5:	5e                   	pop    %esi
c010ede6:	5f                   	pop    %edi
c010ede7:	5d                   	pop    %ebp
c010ede8:	c3                   	ret    
        __uitoa_internal(value, str, base, size);
c010ede9:	56                   	push   %esi
c010edea:	52                   	push   %edx
c010edeb:	53                   	push   %ebx
c010edec:	ff 75 08             	push   0x8(%ebp)
c010edef:	e8 34 ff ff ff       	call   c010ed28 <__uitoa_internal>
c010edf4:	83 c4 10             	add    $0x10,%esp
c010edf7:	eb e6                	jmp    c010eddf <__itoa_internal+0x38>

c010edf9 <itoa>:

char*
itoa(int value, char* str, int base)
{
c010edf9:	55                   	push   %ebp
c010edfa:	89 e5                	mov    %esp,%ebp
    return __itoa_internal(value, str, base, NULL);
c010edfc:	6a 00                	push   $0x0
c010edfe:	ff 75 10             	push   0x10(%ebp)
c010ee01:	ff 75 0c             	push   0xc(%ebp)
c010ee04:	ff 75 08             	push   0x8(%ebp)
c010ee07:	e8 9b ff ff ff       	call   c010eda7 <__itoa_internal>
c010ee0c:	c9                   	leave  
c010ee0d:	c3                   	ret    

Disassembly of section .usrtext:

c010f000 <default_sighandler_term>:
{
c010f000:	55                   	push   %ebp
c010f001:	89 e5                	mov    %esp,%ebp
c010f003:	83 ec 08             	sub    $0x8,%esp
    _exit(signum);
c010f006:	8b 45 08             	mov    0x8(%ebp),%eax
c010f009:	e8 a0 c6 ff ff       	call   c010b6ae <_exit>
}
c010f00e:	c9                   	leave  
c010f00f:	c3                   	ret    

c010f010 <sig_wrapper>:
c010f010:	89 e0                	mov    %esp,%eax
c010f012:	83 e4 f0             	and    $0xfffffff0,%esp
c010f015:	83 ec 08             	sub    $0x8,%esp
c010f018:	50                   	push   %eax
c010f019:	ff 70 04             	push   0x4(%eax)
c010f01c:	ff 10                	call   *(%eax)
c010f01e:	b8 0b 00 00 00       	mov    $0xb,%eax
c010f023:	8b 5c 24 04          	mov    0x4(%esp),%ebx
c010f027:	cd 21                	int    $0x21
c010f029:	0f 0b                	ud2    

c010f02b <sigchild_handler>:

void __USER__
sigchild_handler(int signum)
{
c010f02b:	55                   	push   %ebp
c010f02c:	89 e5                	mov    %esp,%ebp
c010f02e:	83 ec 14             	sub    $0x14,%esp
    kprintf(KINFO "SIGCHLD received\n");
c010f031:	68 02 34 d1 c0       	push   $0xc0d13402
c010f036:	e8 30 da ff ff       	call   c010ca6b <kprintf>
}
c010f03b:	83 c4 10             	add    $0x10,%esp
c010f03e:	c9                   	leave  
c010f03f:	c3                   	ret    

c010f040 <sigsegv_handler>:

void __USER__
sigsegv_handler(int signum)
{
c010f040:	55                   	push   %ebp
c010f041:	89 e5                	mov    %esp,%ebp
c010f043:	83 ec 08             	sub    $0x8,%esp
    pid_t pid = getpid();
c010f046:	e8 b6 d9 ff ff       	call   c010ca01 <getpid>
    kprintf(KWARN "SIGSEGV received on process %d\n", pid);
c010f04b:	83 ec 08             	sub    $0x8,%esp
c010f04e:	50                   	push   %eax
c010f04f:	68 c8 36 d1 c0       	push   $0xc0d136c8
c010f054:	e8 12 da ff ff       	call   c010ca6b <kprintf>
    _exit(signum);
c010f059:	8b 45 08             	mov    0x8(%ebp),%eax
c010f05c:	e8 a8 d9 ff ff       	call   c010ca09 <_exit>
}
c010f061:	83 c4 10             	add    $0x10,%esp
c010f064:	c9                   	leave  
c010f065:	c3                   	ret    

c010f066 <sigalrm_handler>:

void __USER__
sigalrm_handler(int signum)
{
c010f066:	55                   	push   %ebp
c010f067:	89 e5                	mov    %esp,%ebp
c010f069:	83 ec 08             	sub    $0x8,%esp
    pid_t pid = getpid();
c010f06c:	e8 90 d9 ff ff       	call   c010ca01 <getpid>
    kprintf(KWARN "I, pid %d, have received an alarm!\n", pid);
c010f071:	83 ec 08             	sub    $0x8,%esp
c010f074:	50                   	push   %eax
c010f075:	68 ec 36 d1 c0       	push   $0xc0d136ec
c010f07a:	e8 ec d9 ff ff       	call   c010ca6b <kprintf>
}
c010f07f:	83 c4 10             	add    $0x10,%esp
c010f082:	c9                   	leave  
c010f083:	c3                   	ret    

c010f084 <_signal_demo_main>:

void __USER__
_signal_demo_main()
{
c010f084:	55                   	push   %ebp
c010f085:	89 e5                	mov    %esp,%ebp
c010f087:	56                   	push   %esi
c010f088:	53                   	push   %ebx
c010f089:	83 ec 10             	sub    $0x10,%esp
    signal(_SIGCHLD, sigchild_handler);
c010f08c:	ba 2b f0 10 c0       	mov    $0xc010f02b,%edx
c010f091:	b8 03 00 00 00       	mov    $0x3,%eax
c010f096:	e8 bc d9 ff ff       	call   c010ca57 <signal>
    signal(_SIGSEGV, sigsegv_handler);
c010f09b:	ba 40 f0 10 c0       	mov    $0xc010f040,%edx
c010f0a0:	b8 01 00 00 00       	mov    $0x1,%eax
c010f0a5:	e8 ad d9 ff ff       	call   c010ca57 <signal>
    signal(_SIGALRM, sigalrm_handler);
c010f0aa:	ba 66 f0 10 c0       	mov    $0xc010f066,%edx
c010f0af:	b8 02 00 00 00       	mov    $0x2,%eax
c010f0b4:	e8 9e d9 ff ff       	call   c010ca57 <signal>

    alarm(5);
c010f0b9:	b8 05 00 00 00       	mov    $0x5,%eax
c010f0be:	e8 72 d9 ff ff       	call   c010ca35 <alarm>

    int status;
    pid_t p = 0;

    kprintf(KINFO "Child sleep 3s, parent pause.\n");
c010f0c3:	83 ec 0c             	sub    $0xc,%esp
c010f0c6:	68 14 37 d1 c0       	push   $0xc0d13714
c010f0cb:	e8 9b d9 ff ff       	call   c010ca6b <kprintf>
    if (!fork()) {
c010f0d0:	e8 24 d9 ff ff       	call   c010c9f9 <fork>
c010f0d5:	83 c4 10             	add    $0x10,%esp
c010f0d8:	85 c0                	test   %eax,%eax
c010f0da:	74 1c                	je     c010f0f8 <_signal_demo_main+0x74>
        sleep(3);
        _exit(0);
    }

    pause();
c010f0dc:	e8 4c d9 ff ff       	call   c010ca2d <pause>

    kprintf("Parent resumed on SIGCHILD\n");
c010f0e1:	83 ec 0c             	sub    $0xc,%esp
c010f0e4:	68 16 34 d1 c0       	push   $0xc0d13416
c010f0e9:	e8 7d d9 ff ff       	call   c010ca6b <kprintf>

    for (int i = 0; i < 5; i++) {
c010f0ee:	83 c4 10             	add    $0x10,%esp
c010f0f1:	be 00 00 00 00       	mov    $0x0,%esi
c010f0f6:	eb 45                	jmp    c010f13d <_signal_demo_main+0xb9>
        sleep(3);
c010f0f8:	b8 03 00 00 00       	mov    $0x3,%eax
c010f0fd:	e8 19 d9 ff ff       	call   c010ca1b <sleep>
        _exit(0);
c010f102:	b8 00 00 00 00       	mov    $0x0,%eax
c010f107:	e8 fd d8 ff ff       	call   c010ca09 <_exit>
c010f10c:	eb ce                	jmp    c010f0dc <_signal_demo_main+0x58>
            signal(_SIGSEGV, sigsegv_handler);
            sleep(i);
            if (i == 3) {
                i = *(int*)0xdeadc0de; // seg fault!
            }
            kprintf(KINFO "%d\n", i);
c010f10e:	83 ec 08             	sub    $0x8,%esp
c010f111:	56                   	push   %esi
c010f112:	68 32 34 d1 c0       	push   $0xc0d13432
c010f117:	e8 4f d9 ff ff       	call   c010ca6b <kprintf>
            _exit(0);
c010f11c:	b8 00 00 00 00       	mov    $0x0,%eax
c010f121:	e8 e3 d8 ff ff       	call   c010ca09 <_exit>
c010f126:	83 c4 10             	add    $0x10,%esp
        }
        kprintf(KINFO "Forked %d\n", pid);
c010f129:	83 ec 08             	sub    $0x8,%esp
c010f12c:	53                   	push   %ebx
c010f12d:	68 38 34 d1 c0       	push   $0xc0d13438
c010f132:	e8 34 d9 ff ff       	call   c010ca6b <kprintf>
    for (int i = 0; i < 5; i++) {
c010f137:	83 c6 01             	add    $0x1,%esi
c010f13a:	83 c4 10             	add    $0x10,%esp
c010f13d:	83 fe 04             	cmp    $0x4,%esi
c010f140:	7f 5a                	jg     c010f19c <_signal_demo_main+0x118>
        if (!(pid = fork())) {
c010f142:	e8 b2 d8 ff ff       	call   c010c9f9 <fork>
c010f147:	89 c3                	mov    %eax,%ebx
c010f149:	85 c0                	test   %eax,%eax
c010f14b:	75 dc                	jne    c010f129 <_signal_demo_main+0xa5>
            signal(_SIGSEGV, sigsegv_handler);
c010f14d:	ba 40 f0 10 c0       	mov    $0xc010f040,%edx
c010f152:	b8 01 00 00 00       	mov    $0x1,%eax
c010f157:	e8 fb d8 ff ff       	call   c010ca57 <signal>
            sleep(i);
c010f15c:	89 f0                	mov    %esi,%eax
c010f15e:	e8 b8 d8 ff ff       	call   c010ca1b <sleep>
            if (i == 3) {
c010f163:	83 fe 03             	cmp    $0x3,%esi
c010f166:	75 a6                	jne    c010f10e <_signal_demo_main+0x8a>
                i = *(int*)0xdeadc0de; // seg fault!
c010f168:	8b 35 de c0 ad de    	mov    0xdeadc0de,%esi
c010f16e:	eb 9e                	jmp    c010f10e <_signal_demo_main+0x8a>
    }

    while ((p = wait(&status)) >= 0) {
        short code = WEXITSTATUS(status);
        if (WIFSIGNALED(status)) {
            kprintf(KINFO "Process %d terminated by signal, exit_code: %d\n",
c010f170:	83 ec 04             	sub    $0x4,%esp
c010f173:	0f bf c9             	movswl %cx,%ecx
c010f176:	51                   	push   %ecx
c010f177:	50                   	push   %eax
c010f178:	68 38 37 d1 c0       	push   $0xc0d13738
c010f17d:	e8 e9 d8 ff ff       	call   c010ca6b <kprintf>
c010f182:	83 c4 10             	add    $0x10,%esp
c010f185:	eb 15                	jmp    c010f19c <_signal_demo_main+0x118>
                    p,
                    code);
        } else if (WIFEXITED(status)) {
            kprintf(KINFO "Process %d exited with code %d\n", p, code);
        } else {
            kprintf(KWARN "Process %d aborted with code %d\n", p, code);
c010f187:	83 ec 04             	sub    $0x4,%esp
c010f18a:	0f bf c9             	movswl %cx,%ecx
c010f18d:	51                   	push   %ecx
c010f18e:	50                   	push   %eax
c010f18f:	68 90 37 d1 c0       	push   $0xc0d13790
c010f194:	e8 d2 d8 ff ff       	call   c010ca6b <kprintf>
c010f199:	83 c4 10             	add    $0x10,%esp
    while ((p = wait(&status)) >= 0) {
c010f19c:	8d 45 f4             	lea    -0xc(%ebp),%eax
c010f19f:	e8 a1 d8 ff ff       	call   c010ca45 <wait>
c010f1a4:	85 c0                	test   %eax,%eax
c010f1a6:	78 2b                	js     c010f1d3 <_signal_demo_main+0x14f>
        short code = WEXITSTATUS(status);
c010f1a8:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010f1ab:	0f b6 ca             	movzbl %dl,%ecx
        if (WIFSIGNALED(status)) {
c010f1ae:	f6 c6 04             	test   $0x4,%dh
c010f1b1:	75 bd                	jne    c010f170 <_signal_demo_main+0xec>
        } else if (WIFEXITED(status)) {
c010f1b3:	f6 c6 01             	test   $0x1,%dh
c010f1b6:	74 cf                	je     c010f187 <_signal_demo_main+0x103>
c010f1b8:	84 d2                	test   %dl,%dl
c010f1ba:	78 cb                	js     c010f187 <_signal_demo_main+0x103>
            kprintf(KINFO "Process %d exited with code %d\n", p, code);
c010f1bc:	83 ec 04             	sub    $0x4,%esp
c010f1bf:	0f bf c9             	movswl %cx,%ecx
c010f1c2:	51                   	push   %ecx
c010f1c3:	50                   	push   %eax
c010f1c4:	68 6c 37 d1 c0       	push   $0xc0d1376c
c010f1c9:	e8 9d d8 ff ff       	call   c010ca6b <kprintf>
c010f1ce:	83 c4 10             	add    $0x10,%esp
c010f1d1:	eb c9                	jmp    c010f19c <_signal_demo_main+0x118>
        }
    }

    kprintf("done\n");
c010f1d3:	83 ec 0c             	sub    $0xc,%esp
c010f1d6:	68 45 34 d1 c0       	push   $0xc0d13445
c010f1db:	e8 8b d8 ff ff       	call   c010ca6b <kprintf>
c010f1e0:	83 c4 10             	add    $0x10,%esp
c010f1e3:	eb fe                	jmp    c010f1e3 <_signal_demo_main+0x15f>

c010f1e5 <_lxinit_main>:
#define WAIT_DEMO
#define IN_USER_MODE

void __USER__
_lxinit_main()
{
c010f1e5:	55                   	push   %ebp
c010f1e6:	89 e5                	mov    %esp,%ebp
c010f1e8:	56                   	push   %esi
c010f1e9:	53                   	push   %ebx
c010f1ea:	83 ec 5c             	sub    $0x5c,%esp
#endif

    int status;
#ifdef WAIT_DEMO
    // 测试wait
    kprintf("I am parent, going to fork my child and wait.\n");
c010f1ed:	68 4c 38 d1 c0       	push   $0xc0d1384c
c010f1f2:	e8 bc e2 ff ff       	call   c010d4b3 <kprintf>
    if (!fork()) {
c010f1f7:	e8 59 e2 ff ff       	call   c010d455 <fork>
c010f1fc:	83 c4 10             	add    $0x10,%esp
c010f1ff:	85 c0                	test   %eax,%eax
c010f201:	74 4b                	je     c010f24e <_lxinit_main+0x69>
        kprintf("I am child, going to sleep for 2 seconds\n");
        sleep(2);
        kprintf("I am child, I am about to terminated\n");
        _exit(1);
    }
    wait(&status);
c010f203:	8d 45 f4             	lea    -0xc(%ebp),%eax
c010f206:	e8 7e e2 ff ff       	call   c010d489 <wait>
    pid_t child = wait(&status);
c010f20b:	8d 45 f4             	lea    -0xc(%ebp),%eax
c010f20e:	e8 76 e2 ff ff       	call   c010d489 <wait>
    kprintf("I am parent, my child (%d) terminated normally with code: %d.\n",
c010f213:	83 ec 04             	sub    $0x4,%esp
c010f216:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
c010f21a:	52                   	push   %edx
c010f21b:	50                   	push   %eax
c010f21c:	68 d0 38 d1 c0       	push   $0xc0d138d0
c010f221:	e8 8d e2 ff ff       	call   c010d4b3 <kprintf>
            WEXITSTATUS(status));
#endif

    pid_t p = 0;

    if (!fork()) {
c010f226:	e8 2a e2 ff ff       	call   c010d455 <fork>
c010f22b:	83 c4 10             	add    $0x10,%esp
c010f22e:	85 c0                	test   %eax,%eax
c010f230:	74 4e                	je     c010f280 <_lxinit_main+0x9b>
        kprintf("Test no hang!\n");
        sleep(6);
        _exit(0);
    }

    waitpid(-1, &status, WNOHANG);
c010f232:	b9 01 00 00 00       	mov    $0x1,%ecx
c010f237:	8d 55 f4             	lea    -0xc(%ebp),%edx
c010f23a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c010f23f:	e8 57 e2 ff ff       	call   c010d49b <waitpid>

    for (size_t i = 0; i < 5; i++) {
c010f244:	be 00 00 00 00       	mov    $0x0,%esi
c010f249:	e9 87 00 00 00       	jmp    c010f2d5 <_lxinit_main+0xf0>
        kprintf("I am child, going to sleep for 2 seconds\n");
c010f24e:	83 ec 0c             	sub    $0xc,%esp
c010f251:	68 7c 38 d1 c0       	push   $0xc0d1387c
c010f256:	e8 58 e2 ff ff       	call   c010d4b3 <kprintf>
        sleep(2);
c010f25b:	b8 02 00 00 00       	mov    $0x2,%eax
c010f260:	e8 0a e2 ff ff       	call   c010d46f <sleep>
        kprintf("I am child, I am about to terminated\n");
c010f265:	c7 04 24 a8 38 d1 c0 	movl   $0xc0d138a8,(%esp)
c010f26c:	e8 42 e2 ff ff       	call   c010d4b3 <kprintf>
        _exit(1);
c010f271:	b8 01 00 00 00       	mov    $0x1,%eax
c010f276:	e8 e2 e1 ff ff       	call   c010d45d <_exit>
c010f27b:	83 c4 10             	add    $0x10,%esp
c010f27e:	eb 83                	jmp    c010f203 <_lxinit_main+0x1e>
        kprintf("Test no hang!\n");
c010f280:	83 ec 0c             	sub    $0xc,%esp
c010f283:	68 57 34 d1 c0       	push   $0xc0d13457
c010f288:	e8 26 e2 ff ff       	call   c010d4b3 <kprintf>
        sleep(6);
c010f28d:	b8 06 00 00 00       	mov    $0x6,%eax
c010f292:	e8 d8 e1 ff ff       	call   c010d46f <sleep>
        _exit(0);
c010f297:	b8 00 00 00 00       	mov    $0x0,%eax
c010f29c:	e8 bc e1 ff ff       	call   c010d45d <_exit>
c010f2a1:	83 c4 10             	add    $0x10,%esp
c010f2a4:	eb 8c                	jmp    c010f232 <_lxinit_main+0x4d>
        if (!(pid = fork())) {
            sleep(i);
            if (i == 3) {
                i = *(int*)0xdeadc0de; // seg fault!
            }
            kprintf(KINFO "%d\n", i);
c010f2a6:	83 ec 08             	sub    $0x8,%esp
c010f2a9:	56                   	push   %esi
c010f2aa:	68 32 34 d1 c0       	push   $0xc0d13432
c010f2af:	e8 ff e1 ff ff       	call   c010d4b3 <kprintf>
            _exit(0);
c010f2b4:	b8 00 00 00 00       	mov    $0x0,%eax
c010f2b9:	e8 9f e1 ff ff       	call   c010d45d <_exit>
c010f2be:	83 c4 10             	add    $0x10,%esp
        }
        kprintf(KINFO "Forked %d\n", pid);
c010f2c1:	83 ec 08             	sub    $0x8,%esp
c010f2c4:	53                   	push   %ebx
c010f2c5:	68 38 34 d1 c0       	push   $0xc0d13438
c010f2ca:	e8 e4 e1 ff ff       	call   c010d4b3 <kprintf>
    for (size_t i = 0; i < 5; i++) {
c010f2cf:	83 c6 01             	add    $0x1,%esi
c010f2d2:	83 c4 10             	add    $0x10,%esp
c010f2d5:	83 fe 04             	cmp    $0x4,%esi
c010f2d8:	77 34                	ja     c010f30e <_lxinit_main+0x129>
        if (!(pid = fork())) {
c010f2da:	e8 76 e1 ff ff       	call   c010d455 <fork>
c010f2df:	89 c3                	mov    %eax,%ebx
c010f2e1:	85 c0                	test   %eax,%eax
c010f2e3:	75 dc                	jne    c010f2c1 <_lxinit_main+0xdc>
            sleep(i);
c010f2e5:	89 f0                	mov    %esi,%eax
c010f2e7:	e8 83 e1 ff ff       	call   c010d46f <sleep>
            if (i == 3) {
c010f2ec:	83 fe 03             	cmp    $0x3,%esi
c010f2ef:	75 b5                	jne    c010f2a6 <_lxinit_main+0xc1>
                i = *(int*)0xdeadc0de; // seg fault!
c010f2f1:	8b 35 de c0 ad de    	mov    0xdeadc0de,%esi
c010f2f7:	eb ad                	jmp    c010f2a6 <_lxinit_main+0xc1>
    while ((p = wait(&status)) >= 0) {
        short code = WEXITSTATUS(status);
        if (WIFEXITED(status)) {
            kprintf(KINFO "Process %d exited with code %d\n", p, code);
        } else {
            kprintf(KWARN "Process %d aborted with code %d\n", p, code);
c010f2f9:	83 ec 04             	sub    $0x4,%esp
c010f2fc:	0f bf d2             	movswl %dx,%edx
c010f2ff:	52                   	push   %edx
c010f300:	50                   	push   %eax
c010f301:	68 90 37 d1 c0       	push   $0xc0d13790
c010f306:	e8 a8 e1 ff ff       	call   c010d4b3 <kprintf>
c010f30b:	83 c4 10             	add    $0x10,%esp
    while ((p = wait(&status)) >= 0) {
c010f30e:	8d 45 f4             	lea    -0xc(%ebp),%eax
c010f311:	e8 73 e1 ff ff       	call   c010d489 <wait>
c010f316:	85 c0                	test   %eax,%eax
c010f318:	78 26                	js     c010f340 <_lxinit_main+0x15b>
        short code = WEXITSTATUS(status);
c010f31a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c010f31d:	0f b6 d1             	movzbl %cl,%edx
        if (WIFEXITED(status)) {
c010f320:	f6 c5 01             	test   $0x1,%ch
c010f323:	74 d4                	je     c010f2f9 <_lxinit_main+0x114>
c010f325:	84 c9                	test   %cl,%cl
c010f327:	78 d0                	js     c010f2f9 <_lxinit_main+0x114>
            kprintf(KINFO "Process %d exited with code %d\n", p, code);
c010f329:	83 ec 04             	sub    $0x4,%esp
c010f32c:	0f bf d2             	movswl %dx,%edx
c010f32f:	52                   	push   %edx
c010f330:	50                   	push   %eax
c010f331:	68 6c 37 d1 c0       	push   $0xc0d1376c
c010f336:	e8 78 e1 ff ff       	call   c010d4b3 <kprintf>
c010f33b:	83 c4 10             	add    $0x10,%esp
c010f33e:	eb ce                	jmp    c010f30e <_lxinit_main+0x129>
        }
    }

    char buf[64];

    kprintf(KINFO "Hello processes!\n");
c010f340:	83 ec 0c             	sub    $0xc,%esp
c010f343:	68 66 34 d1 c0       	push   $0xc0d13466
c010f348:	e8 66 e1 ff ff       	call   c010d4b3 <kprintf>

    cpu_get_brand(buf);
c010f34d:	8d 5d b4             	lea    -0x4c(%ebp),%ebx
c010f350:	89 1c 24             	mov    %ebx,(%esp)
c010f353:	e8 98 f1 ff ff       	call   c010e4f0 <cpu_get_brand>
    kprintf("CPU: %s\n\n", buf);
c010f358:	83 c4 08             	add    $0x8,%esp
c010f35b:	53                   	push   %ebx
c010f35c:	68 7a 34 d1 c0       	push   $0xc0d1347a
c010f361:	e8 4d e1 ff ff       	call   c010d4b3 <kprintf>
c010f366:	83 c4 10             	add    $0x10,%esp
c010f369:	eb 21                	jmp    c010f38c <_lxinit_main+0x1a7>
    while (1) {
        if (!kbd_recv_key(&keyevent)) {
            yield();
            continue;
        }
        if ((keyevent.state & KBD_KEY_FPRESSED)) {
c010f36b:	f6 45 ac 01          	testb  $0x1,-0x54(%ebp)
c010f36f:	74 1b                	je     c010f38c <_lxinit_main+0x1a7>
            if ((keyevent.keycode & 0xff00) <= KEYPAD) {
c010f371:	0f b7 45 aa          	movzwl -0x56(%ebp),%eax
c010f375:	89 c2                	mov    %eax,%edx
c010f377:	b2 00                	mov    $0x0,%dl
c010f379:	66 81 fa 00 01       	cmp    $0x100,%dx
c010f37e:	76 26                	jbe    c010f3a6 <_lxinit_main+0x1c1>
                console_write_char((char)(keyevent.keycode & 0x00ff));
            } else if (keyevent.keycode == KEY_UP) {
c010f380:	66 3d 02 03          	cmp    $0x302,%ax
c010f384:	74 31                	je     c010f3b7 <_lxinit_main+0x1d2>
                console_view_up();
            } else if (keyevent.keycode == KEY_DOWN) {
c010f386:	66 3d 03 03          	cmp    $0x303,%ax
c010f38a:	74 32                	je     c010f3be <_lxinit_main+0x1d9>
        if (!kbd_recv_key(&keyevent)) {
c010f38c:	83 ec 0c             	sub    $0xc,%esp
c010f38f:	8d 45 a8             	lea    -0x58(%ebp),%eax
c010f392:	50                   	push   %eax
c010f393:	e8 34 e0 ff ff       	call   c010d3cc <kbd_recv_key>
c010f398:	83 c4 10             	add    $0x10,%esp
c010f39b:	85 c0                	test   %eax,%eax
c010f39d:	75 cc                	jne    c010f36b <_lxinit_main+0x186>
            yield();
c010f39f:	e8 dd e0 ff ff       	call   c010d481 <yield>
            continue;
c010f3a4:	eb e6                	jmp    c010f38c <_lxinit_main+0x1a7>
                console_write_char((char)(keyevent.keycode & 0x00ff));
c010f3a6:	83 ec 0c             	sub    $0xc,%esp
c010f3a9:	0f be c0             	movsbl %al,%eax
c010f3ac:	50                   	push   %eax
c010f3ad:	e8 c0 d9 ff ff       	call   c010cd72 <console_write_char>
c010f3b2:	83 c4 10             	add    $0x10,%esp
c010f3b5:	eb d5                	jmp    c010f38c <_lxinit_main+0x1a7>
                console_view_up();
c010f3b7:	e8 d3 d7 ff ff       	call   c010cb8f <console_view_up>
c010f3bc:	eb ce                	jmp    c010f38c <_lxinit_main+0x1a7>
                console_view_down();
c010f3be:	e8 65 d8 ff ff       	call   c010cc28 <console_view_down>
c010f3c3:	eb c7                	jmp    c010f38c <_lxinit_main+0x1a7>

c010f3c5 <__proc0_usr>:
{
c010f3c5:	55                   	push   %ebp
c010f3c6:	89 e5                	mov    %esp,%ebp
c010f3c8:	83 ec 08             	sub    $0x8,%esp
    if (!fork()) {
c010f3cb:	e8 1e e9 ff ff       	call   c010dcee <fork>
c010f3d0:	85 c0                	test   %eax,%eax
c010f3d2:	75 05                	jne    c010f3d9 <__proc0_usr+0x14>
        asm("jmp _lxinit_main");
c010f3d4:	e9 0c fe ff ff       	jmp    c010f1e5 <_lxinit_main>
        yield();
c010f3d9:	e8 18 e9 ff ff       	call   c010dcf6 <yield>
    while (1) {
c010f3de:	eb f9                	jmp    c010f3d9 <__proc0_usr+0x14>
